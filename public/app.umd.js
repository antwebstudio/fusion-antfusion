(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(require("vue")) : typeof define === "function" && define.amd ? define(["vue"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.Vue));
})(this, function(require$$0$1) {
  "use strict";
  window.Fusion.booting(function(Vue, router, store2) {
    Vue.component("antfusion-form", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => AntFusionForm$1)));
    Vue.component("antfusion-datatable", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => DataTable)));
    Vue.component("panel-body", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => PanelBody$1)));
    Vue.component("antfusion-edit-link", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => EditResourceLink$1)));
    Vue.component("page-as-component", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => PageAsComponent$1)));
    Vue.component("spinner", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => Spinner$1)));
    Vue.component("parent-value", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => ParentValue$1)));
    Vue.component("print-button", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => PrintButton$1)));
    Vue.component("action-button", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => ActionButton$1)));
    Vue.component("action-dropdown-link", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => ActionDropDownLink$1)));
    Vue.component("submit-button", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => SubmitButton$1)));
    Vue.component("nested-component", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => NestedComponent$1)));
    Vue.component("report-datatable", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => ReportDataTable$1)));
    Vue.component("resource-datatable", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => ResourceDataTable$1)));
    Vue.component("resource-datetime", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => ResourceDateTime$1)));
    Vue.component("resource-date", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => ResourceDate$1)));
    Vue.component("resource-fieldtype", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => Field$1)));
    Vue.component("resource-fieldtype-setting", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => Settings$1)));
    Vue.component("filter-tabs", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => FilterTabs$1)));
    Vue.component("antfusion-simple-wizard", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => SimpleWizard$1)));
    Vue.component("antfusion-html-table", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => Table$1)));
    Vue.component("antfusion-html-table-header-row", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => TableHeaderRow$1)));
    Vue.component("metric-item", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => MetricItem$1)));
    Vue.component("component-container", require$$0$1.defineAsyncComponent(() => Promise.resolve().then(() => ComponentContainer$1)));
    const routes = [
      {
        path: "/resource/:resource",
        component: () => Promise.resolve().then(() => Index$5),
        name: "antfusion.resource",
        meta: {
          requiresAuth: true,
          layout: "admin"
        }
      },
      {
        path: "/resource/:resource/create",
        component: () => Promise.resolve().then(() => Create$1),
        name: "antfusion.resource.create",
        meta: {
          requiresAuth: true,
          layout: "admin"
        }
      },
      {
        path: "/resource/:resource/:id/edit",
        component: () => Promise.resolve().then(() => Edit$1),
        name: "antfusion.resource.edit",
        meta: {
          requiresAuth: true,
          layout: "admin"
        }
      },
      {
        path: "/report/:report",
        component: () => Promise.resolve().then(() => Index$3),
        name: "antfusion.report",
        meta: {
          requiresAuth: true,
          layout: "admin"
        }
      },
      {
        path: "/page/:page",
        component: () => Promise.resolve().then(() => Index$1),
        name: "antfusion.report",
        meta: {
          requiresAuth: true,
          layout: "admin"
        }
      }
    ];
    routes.forEach((route) => {
      router.addRoute(route);
    });
  });
  window.addEventListener("DOMContentLoaded", function() {
  });
  class Errors {
    constructor(errors = {}) {
      this.errors = errors;
    }
    has(field) {
      return this.errors.hasOwnProperty(field);
    }
    any() {
      return Object.keys(this.errors).length > 0;
    }
    get(field) {
      if (this.errors[field]) {
        return this.errors[field][0];
      }
    }
    record(response) {
      this.errors = response.errors;
    }
    clear(field) {
      if (field) {
        delete this.errors[field];
        return;
      }
      this.errors = {};
    }
  }
  function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
  }
  function getTarget() {
    return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
  }
  const isProxyAvailable = typeof Proxy === "function";
  const HOOK_SETUP = "devtools-plugin:setup";
  const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
  let supported;
  let perf;
  function isPerformanceSupported() {
    var _a;
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else if (typeof global !== "undefined" && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
      supported = true;
      perf = global.perf_hooks.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function now() {
    return isPerformanceSupported() ? perf.now() : Date.now();
  }
  class ApiProxy {
    constructor(plugin, hook) {
      this.target = null;
      this.targetQueue = [];
      this.onQueue = [];
      this.plugin = plugin;
      this.hook = hook;
      const defaultSettings = {};
      if (plugin.settings) {
        for (const id in plugin.settings) {
          const item = plugin.settings[id];
          defaultSettings[id] = item.defaultValue;
        }
      }
      const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
      let currentSettings = Object.assign({}, defaultSettings);
      try {
        const raw = localStorage.getItem(localSettingsSaveId);
        const data = JSON.parse(raw);
        Object.assign(currentSettings, data);
      } catch (e) {
      }
      this.fallbacks = {
        getSettings() {
          return currentSettings;
        },
        setSettings(value) {
          try {
            localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
          } catch (e) {
          }
          currentSettings = value;
        },
        now() {
          return now();
        }
      };
      if (hook) {
        hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
          if (pluginId === this.plugin.id) {
            this.fallbacks.setSettings(value);
          }
        });
      }
      this.proxiedOn = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target.on[prop];
          } else {
            return (...args) => {
              this.onQueue.push({
                method: prop,
                args
              });
            };
          }
        }
      });
      this.proxiedTarget = new Proxy({}, {
        get: (_target, prop) => {
          if (this.target) {
            return this.target[prop];
          } else if (prop === "on") {
            return this.proxiedOn;
          } else if (Object.keys(this.fallbacks).includes(prop)) {
            return (...args) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve: () => {
                }
              });
              return this.fallbacks[prop](...args);
            };
          } else {
            return (...args) => {
              return new Promise((resolve) => {
                this.targetQueue.push({
                  method: prop,
                  args,
                  resolve
                });
              });
            };
          }
        }
      });
    }
    async setRealTarget(target) {
      this.target = target;
      for (const item of this.onQueue) {
        this.target.on[item.method](...item.args);
      }
      for (const item of this.targetQueue) {
        item.resolve(await this.target[item.method](...item.args));
      }
    }
  }
  function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const descriptor = pluginDescriptor;
    const target = getTarget();
    const hook = getDevtoolsGlobalHook();
    const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
      hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
    } else {
      const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
      const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
      list.push({
        pluginDescriptor: descriptor,
        setupFn,
        proxy
      });
      if (proxy)
        setupFn(proxy.proxiedTarget);
    }
  }
  /*!
   * vuex v4.1.0
   * (c) 2022 Evan You
   * @license MIT
   */
  var storeKey = "store";
  function forEachValue(obj, fn) {
    Object.keys(obj).forEach(function(key) {
      return fn(obj[key], key);
    });
  }
  function isObject$1(obj) {
    return obj !== null && typeof obj === "object";
  }
  function isPromise(val) {
    return val && typeof val.then === "function";
  }
  function partial(fn, arg) {
    return function() {
      return fn(arg);
    };
  }
  function genericSubscribe(fn, subs, options) {
    if (subs.indexOf(fn) < 0) {
      options && options.prepend ? subs.unshift(fn) : subs.push(fn);
    }
    return function() {
      var i = subs.indexOf(fn);
      if (i > -1) {
        subs.splice(i, 1);
      }
    };
  }
  function resetStore(store2, hot) {
    store2._actions = /* @__PURE__ */ Object.create(null);
    store2._mutations = /* @__PURE__ */ Object.create(null);
    store2._wrappedGetters = /* @__PURE__ */ Object.create(null);
    store2._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
    var state = store2.state;
    installModule(store2, state, [], store2._modules.root, true);
    resetStoreState(store2, state, hot);
  }
  function resetStoreState(store2, state, hot) {
    var oldState = store2._state;
    var oldScope = store2._scope;
    store2.getters = {};
    store2._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
    var wrappedGetters = store2._wrappedGetters;
    var computedObj = {};
    var computedCache = {};
    var scope = require$$0$1.effectScope(true);
    scope.run(function() {
      forEachValue(wrappedGetters, function(fn, key) {
        computedObj[key] = partial(fn, store2);
        computedCache[key] = require$$0$1.computed(function() {
          return computedObj[key]();
        });
        Object.defineProperty(store2.getters, key, {
          get: function() {
            return computedCache[key].value;
          },
          enumerable: true
          // for local getters
        });
      });
    });
    store2._state = require$$0$1.reactive({
      data: state
    });
    store2._scope = scope;
    if (store2.strict) {
      enableStrictMode(store2);
    }
    if (oldState) {
      if (hot) {
        store2._withCommit(function() {
          oldState.data = null;
        });
      }
    }
    if (oldScope) {
      oldScope.stop();
    }
  }
  function installModule(store2, rootState, path, module2, hot) {
    var isRoot = !path.length;
    var namespace = store2._modules.getNamespace(path);
    if (module2.namespaced) {
      if (store2._modulesNamespaceMap[namespace] && { "NODE_ENV": "production" }.NODE_ENV !== "production") {
        console.error("[vuex] duplicate namespace " + namespace + " for the namespaced module " + path.join("/"));
      }
      store2._modulesNamespaceMap[namespace] = module2;
    }
    if (!isRoot && !hot) {
      var parentState = getNestedState(rootState, path.slice(0, -1));
      var moduleName = path[path.length - 1];
      store2._withCommit(function() {
        parentState[moduleName] = module2.state;
      });
    }
    var local = module2.context = makeLocalContext(store2, namespace, path);
    module2.forEachMutation(function(mutation, key) {
      var namespacedType = namespace + key;
      registerMutation(store2, namespacedType, mutation, local);
    });
    module2.forEachAction(function(action, key) {
      var type = action.root ? key : namespace + key;
      var handler = action.handler || action;
      registerAction(store2, type, handler, local);
    });
    module2.forEachGetter(function(getter, key) {
      var namespacedType = namespace + key;
      registerGetter(store2, namespacedType, getter, local);
    });
    module2.forEachChild(function(child, key) {
      installModule(store2, rootState, path.concat(key), child, hot);
    });
  }
  function makeLocalContext(store2, namespace, path) {
    var noNamespace = namespace === "";
    var local = {
      dispatch: noNamespace ? store2.dispatch : function(_type, _payload, _options) {
        var args = unifyObjectStyle(_type, _payload, _options);
        var payload = args.payload;
        var options = args.options;
        var type = args.type;
        if (!options || !options.root) {
          type = namespace + type;
        }
        return store2.dispatch(type, payload);
      },
      commit: noNamespace ? store2.commit : function(_type, _payload, _options) {
        var args = unifyObjectStyle(_type, _payload, _options);
        var payload = args.payload;
        var options = args.options;
        var type = args.type;
        if (!options || !options.root) {
          type = namespace + type;
        }
        store2.commit(type, payload, options);
      }
    };
    Object.defineProperties(local, {
      getters: {
        get: noNamespace ? function() {
          return store2.getters;
        } : function() {
          return makeLocalGetters(store2, namespace);
        }
      },
      state: {
        get: function() {
          return getNestedState(store2.state, path);
        }
      }
    });
    return local;
  }
  function makeLocalGetters(store2, namespace) {
    if (!store2._makeLocalGettersCache[namespace]) {
      var gettersProxy = {};
      var splitPos = namespace.length;
      Object.keys(store2.getters).forEach(function(type) {
        if (type.slice(0, splitPos) !== namespace) {
          return;
        }
        var localType = type.slice(splitPos);
        Object.defineProperty(gettersProxy, localType, {
          get: function() {
            return store2.getters[type];
          },
          enumerable: true
        });
      });
      store2._makeLocalGettersCache[namespace] = gettersProxy;
    }
    return store2._makeLocalGettersCache[namespace];
  }
  function registerMutation(store2, type, handler, local) {
    var entry = store2._mutations[type] || (store2._mutations[type] = []);
    entry.push(function wrappedMutationHandler(payload) {
      handler.call(store2, local.state, payload);
    });
  }
  function registerAction(store2, type, handler, local) {
    var entry = store2._actions[type] || (store2._actions[type] = []);
    entry.push(function wrappedActionHandler(payload) {
      var res = handler.call(store2, {
        dispatch: local.dispatch,
        commit: local.commit,
        getters: local.getters,
        state: local.state,
        rootGetters: store2.getters,
        rootState: store2.state
      }, payload);
      if (!isPromise(res)) {
        res = Promise.resolve(res);
      }
      if (store2._devtoolHook) {
        return res.catch(function(err) {
          store2._devtoolHook.emit("vuex:error", err);
          throw err;
        });
      } else {
        return res;
      }
    });
  }
  function registerGetter(store2, type, rawGetter, local) {
    if (store2._wrappedGetters[type]) {
      return;
    }
    store2._wrappedGetters[type] = function wrappedGetter(store3) {
      return rawGetter(
        local.state,
        // local state
        local.getters,
        // local getters
        store3.state,
        // root state
        store3.getters
        // root getters
      );
    };
  }
  function enableStrictMode(store2) {
    require$$0$1.watch(function() {
      return store2._state.data;
    }, function() {
    }, { deep: true, flush: "sync" });
  }
  function getNestedState(state, path) {
    return path.reduce(function(state2, key) {
      return state2[key];
    }, state);
  }
  function unifyObjectStyle(type, payload, options) {
    if (isObject$1(type) && type.type) {
      options = payload;
      payload = type;
      type = type.type;
    }
    return { type, payload, options };
  }
  var LABEL_VUEX_BINDINGS = "vuex bindings";
  var MUTATIONS_LAYER_ID = "vuex:mutations";
  var ACTIONS_LAYER_ID = "vuex:actions";
  var INSPECTOR_ID = "vuex";
  var actionId = 0;
  function addDevtools(app, store2) {
    setupDevtoolsPlugin(
      {
        id: "org.vuejs.vuex",
        app,
        label: "Vuex",
        homepage: "https://next.vuex.vuejs.org/",
        logo: "https://vuejs.org/images/icons/favicon-96x96.png",
        packageName: "vuex",
        componentStateTypes: [LABEL_VUEX_BINDINGS]
      },
      function(api) {
        api.addTimelineLayer({
          id: MUTATIONS_LAYER_ID,
          label: "Vuex Mutations",
          color: COLOR_LIME_500
        });
        api.addTimelineLayer({
          id: ACTIONS_LAYER_ID,
          label: "Vuex Actions",
          color: COLOR_LIME_500
        });
        api.addInspector({
          id: INSPECTOR_ID,
          label: "Vuex",
          icon: "storage",
          treeFilterPlaceholder: "Filter stores..."
        });
        api.on.getInspectorTree(function(payload) {
          if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
            if (payload.filter) {
              var nodes = [];
              flattenStoreForInspectorTree(nodes, store2._modules.root, payload.filter, "");
              payload.rootNodes = nodes;
            } else {
              payload.rootNodes = [
                formatStoreForInspectorTree(store2._modules.root, "")
              ];
            }
          }
        });
        api.on.getInspectorState(function(payload) {
          if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
            var modulePath = payload.nodeId;
            makeLocalGetters(store2, modulePath);
            payload.state = formatStoreForInspectorState(
              getStoreModule(store2._modules, modulePath),
              modulePath === "root" ? store2.getters : store2._makeLocalGettersCache,
              modulePath
            );
          }
        });
        api.on.editInspectorState(function(payload) {
          if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
            var modulePath = payload.nodeId;
            var path = payload.path;
            if (modulePath !== "root") {
              path = modulePath.split("/").filter(Boolean).concat(path);
            }
            store2._withCommit(function() {
              payload.set(store2._state.data, path, payload.state.value);
            });
          }
        });
        store2.subscribe(function(mutation, state) {
          var data = {};
          if (mutation.payload) {
            data.payload = mutation.payload;
          }
          data.state = state;
          api.notifyComponentUpdate();
          api.sendInspectorTree(INSPECTOR_ID);
          api.sendInspectorState(INSPECTOR_ID);
          api.addTimelineEvent({
            layerId: MUTATIONS_LAYER_ID,
            event: {
              time: Date.now(),
              title: mutation.type,
              data
            }
          });
        });
        store2.subscribeAction({
          before: function(action, state) {
            var data = {};
            if (action.payload) {
              data.payload = action.payload;
            }
            action._id = actionId++;
            action._time = Date.now();
            data.state = state;
            api.addTimelineEvent({
              layerId: ACTIONS_LAYER_ID,
              event: {
                time: action._time,
                title: action.type,
                groupId: action._id,
                subtitle: "start",
                data
              }
            });
          },
          after: function(action, state) {
            var data = {};
            var duration2 = Date.now() - action._time;
            data.duration = {
              _custom: {
                type: "duration",
                display: duration2 + "ms",
                tooltip: "Action duration",
                value: duration2
              }
            };
            if (action.payload) {
              data.payload = action.payload;
            }
            data.state = state;
            api.addTimelineEvent({
              layerId: ACTIONS_LAYER_ID,
              event: {
                time: Date.now(),
                title: action.type,
                groupId: action._id,
                subtitle: "end",
                data
              }
            });
          }
        });
      }
    );
  }
  var COLOR_LIME_500 = 8702998;
  var COLOR_DARK = 6710886;
  var COLOR_WHITE = 16777215;
  var TAG_NAMESPACED = {
    label: "namespaced",
    textColor: COLOR_WHITE,
    backgroundColor: COLOR_DARK
  };
  function extractNameFromPath(path) {
    return path && path !== "root" ? path.split("/").slice(-2, -1)[0] : "Root";
  }
  function formatStoreForInspectorTree(module2, path) {
    return {
      id: path || "root",
      // all modules end with a `/`, we want the last segment only
      // cart/ -> cart
      // nested/cart/ -> cart
      label: extractNameFromPath(path),
      tags: module2.namespaced ? [TAG_NAMESPACED] : [],
      children: Object.keys(module2._children).map(
        function(moduleName) {
          return formatStoreForInspectorTree(
            module2._children[moduleName],
            path + moduleName + "/"
          );
        }
      )
    };
  }
  function flattenStoreForInspectorTree(result, module2, filter, path) {
    if (path.includes(filter)) {
      result.push({
        id: path || "root",
        label: path.endsWith("/") ? path.slice(0, path.length - 1) : path || "Root",
        tags: module2.namespaced ? [TAG_NAMESPACED] : []
      });
    }
    Object.keys(module2._children).forEach(function(moduleName) {
      flattenStoreForInspectorTree(result, module2._children[moduleName], filter, path + moduleName + "/");
    });
  }
  function formatStoreForInspectorState(module2, getters, path) {
    getters = path === "root" ? getters : getters[path];
    var gettersKeys = Object.keys(getters);
    var storeState = {
      state: Object.keys(module2.state).map(function(key) {
        return {
          key,
          editable: true,
          value: module2.state[key]
        };
      })
    };
    if (gettersKeys.length) {
      var tree = transformPathsToObjectTree(getters);
      storeState.getters = Object.keys(tree).map(function(key) {
        return {
          key: key.endsWith("/") ? extractNameFromPath(key) : key,
          editable: false,
          value: canThrow(function() {
            return tree[key];
          })
        };
      });
    }
    return storeState;
  }
  function transformPathsToObjectTree(getters) {
    var result = {};
    Object.keys(getters).forEach(function(key) {
      var path = key.split("/");
      if (path.length > 1) {
        var target = result;
        var leafKey = path.pop();
        path.forEach(function(p) {
          if (!target[p]) {
            target[p] = {
              _custom: {
                value: {},
                display: p,
                tooltip: "Module",
                abstract: true
              }
            };
          }
          target = target[p]._custom.value;
        });
        target[leafKey] = canThrow(function() {
          return getters[key];
        });
      } else {
        result[key] = canThrow(function() {
          return getters[key];
        });
      }
    });
    return result;
  }
  function getStoreModule(moduleMap, path) {
    var names = path.split("/").filter(function(n) {
      return n;
    });
    return names.reduce(
      function(module2, moduleName, i) {
        var child = module2[moduleName];
        if (!child) {
          throw new Error('Missing module "' + moduleName + '" for path "' + path + '".');
        }
        return i === names.length - 1 ? child : child._children;
      },
      path === "root" ? moduleMap : moduleMap.root._children
    );
  }
  function canThrow(cb) {
    try {
      return cb();
    } catch (e) {
      return e;
    }
  }
  var Module = function Module2(rawModule, runtime) {
    this.runtime = runtime;
    this._children = /* @__PURE__ */ Object.create(null);
    this._rawModule = rawModule;
    var rawState = rawModule.state;
    this.state = (typeof rawState === "function" ? rawState() : rawState) || {};
  };
  var prototypeAccessors$1 = { namespaced: { configurable: true } };
  prototypeAccessors$1.namespaced.get = function() {
    return !!this._rawModule.namespaced;
  };
  Module.prototype.addChild = function addChild(key, module2) {
    this._children[key] = module2;
  };
  Module.prototype.removeChild = function removeChild(key) {
    delete this._children[key];
  };
  Module.prototype.getChild = function getChild(key) {
    return this._children[key];
  };
  Module.prototype.hasChild = function hasChild(key) {
    return key in this._children;
  };
  Module.prototype.update = function update2(rawModule) {
    this._rawModule.namespaced = rawModule.namespaced;
    if (rawModule.actions) {
      this._rawModule.actions = rawModule.actions;
    }
    if (rawModule.mutations) {
      this._rawModule.mutations = rawModule.mutations;
    }
    if (rawModule.getters) {
      this._rawModule.getters = rawModule.getters;
    }
  };
  Module.prototype.forEachChild = function forEachChild(fn) {
    forEachValue(this._children, fn);
  };
  Module.prototype.forEachGetter = function forEachGetter(fn) {
    if (this._rawModule.getters) {
      forEachValue(this._rawModule.getters, fn);
    }
  };
  Module.prototype.forEachAction = function forEachAction(fn) {
    if (this._rawModule.actions) {
      forEachValue(this._rawModule.actions, fn);
    }
  };
  Module.prototype.forEachMutation = function forEachMutation(fn) {
    if (this._rawModule.mutations) {
      forEachValue(this._rawModule.mutations, fn);
    }
  };
  Object.defineProperties(Module.prototype, prototypeAccessors$1);
  var ModuleCollection = function ModuleCollection2(rawRootModule) {
    this.register([], rawRootModule, false);
  };
  ModuleCollection.prototype.get = function get(path) {
    return path.reduce(function(module2, key) {
      return module2.getChild(key);
    }, this.root);
  };
  ModuleCollection.prototype.getNamespace = function getNamespace(path) {
    var module2 = this.root;
    return path.reduce(function(namespace, key) {
      module2 = module2.getChild(key);
      return namespace + (module2.namespaced ? key + "/" : "");
    }, "");
  };
  ModuleCollection.prototype.update = function update$1(rawRootModule) {
    update([], this.root, rawRootModule);
  };
  ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
    var this$1$1 = this;
    if (runtime === void 0)
      runtime = true;
    var newModule = new Module(rawModule, runtime);
    if (path.length === 0) {
      this.root = newModule;
    } else {
      var parent = this.get(path.slice(0, -1));
      parent.addChild(path[path.length - 1], newModule);
    }
    if (rawModule.modules) {
      forEachValue(rawModule.modules, function(rawChildModule, key) {
        this$1$1.register(path.concat(key), rawChildModule, runtime);
      });
    }
  };
  ModuleCollection.prototype.unregister = function unregister(path) {
    var parent = this.get(path.slice(0, -1));
    var key = path[path.length - 1];
    var child = parent.getChild(key);
    if (!child) {
      return;
    }
    if (!child.runtime) {
      return;
    }
    parent.removeChild(key);
  };
  ModuleCollection.prototype.isRegistered = function isRegistered(path) {
    var parent = this.get(path.slice(0, -1));
    var key = path[path.length - 1];
    if (parent) {
      return parent.hasChild(key);
    }
    return false;
  };
  function update(path, targetModule, newModule) {
    targetModule.update(newModule);
    if (newModule.modules) {
      for (var key in newModule.modules) {
        if (!targetModule.getChild(key)) {
          return;
        }
        update(
          path.concat(key),
          targetModule.getChild(key),
          newModule.modules[key]
        );
      }
    }
  }
  function createStore(options) {
    return new Store(options);
  }
  var Store = function Store2(options) {
    var this$1$1 = this;
    if (options === void 0)
      options = {};
    var plugins = options.plugins;
    if (plugins === void 0)
      plugins = [];
    var strict = options.strict;
    if (strict === void 0)
      strict = false;
    var devtools = options.devtools;
    this._committing = false;
    this._actions = /* @__PURE__ */ Object.create(null);
    this._actionSubscribers = [];
    this._mutations = /* @__PURE__ */ Object.create(null);
    this._wrappedGetters = /* @__PURE__ */ Object.create(null);
    this._modules = new ModuleCollection(options);
    this._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
    this._subscribers = [];
    this._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
    this._scope = null;
    this._devtools = devtools;
    var store2 = this;
    var ref = this;
    var dispatch = ref.dispatch;
    var commit = ref.commit;
    this.dispatch = function boundDispatch(type, payload) {
      return dispatch.call(store2, type, payload);
    };
    this.commit = function boundCommit(type, payload, options2) {
      return commit.call(store2, type, payload, options2);
    };
    this.strict = strict;
    var state = this._modules.root.state;
    installModule(this, state, [], this._modules.root);
    resetStoreState(this, state);
    plugins.forEach(function(plugin) {
      return plugin(this$1$1);
    });
  };
  var prototypeAccessors = { state: { configurable: true } };
  Store.prototype.install = function install(app, injectKey) {
    app.provide(injectKey || storeKey, this);
    app.config.globalProperties.$store = this;
    var useDevtools = this._devtools !== void 0 ? this._devtools : false;
    if (useDevtools) {
      addDevtools(app, this);
    }
  };
  prototypeAccessors.state.get = function() {
    return this._state.data;
  };
  prototypeAccessors.state.set = function(v) {
  };
  Store.prototype.commit = function commit(_type, _payload, _options) {
    var this$1$1 = this;
    var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var mutation = { type, payload };
    var entry = this._mutations[type];
    if (!entry) {
      return;
    }
    this._withCommit(function() {
      entry.forEach(function commitIterator(handler) {
        handler(payload);
      });
    });
    this._subscribers.slice().forEach(function(sub) {
      return sub(mutation, this$1$1.state);
    });
  };
  Store.prototype.dispatch = function dispatch(_type, _payload) {
    var this$1$1 = this;
    var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;
    var action = { type, payload };
    var entry = this._actions[type];
    if (!entry) {
      return;
    }
    try {
      this._actionSubscribers.slice().filter(function(sub) {
        return sub.before;
      }).forEach(function(sub) {
        return sub.before(action, this$1$1.state);
      });
    } catch (e) {
    }
    var result = entry.length > 1 ? Promise.all(entry.map(function(handler) {
      return handler(payload);
    })) : entry[0](payload);
    return new Promise(function(resolve, reject) {
      result.then(function(res) {
        try {
          this$1$1._actionSubscribers.filter(function(sub) {
            return sub.after;
          }).forEach(function(sub) {
            return sub.after(action, this$1$1.state);
          });
        } catch (e) {
        }
        resolve(res);
      }, function(error) {
        try {
          this$1$1._actionSubscribers.filter(function(sub) {
            return sub.error;
          }).forEach(function(sub) {
            return sub.error(action, this$1$1.state, error);
          });
        } catch (e) {
        }
        reject(error);
      });
    });
  };
  Store.prototype.subscribe = function subscribe(fn, options) {
    return genericSubscribe(fn, this._subscribers, options);
  };
  Store.prototype.subscribeAction = function subscribeAction(fn, options) {
    var subs = typeof fn === "function" ? { before: fn } : fn;
    return genericSubscribe(subs, this._actionSubscribers, options);
  };
  Store.prototype.watch = function watch$1(getter, cb, options) {
    var this$1$1 = this;
    return require$$0$1.watch(function() {
      return getter(this$1$1.state, this$1$1.getters);
    }, cb, Object.assign({}, options));
  };
  Store.prototype.replaceState = function replaceState(state) {
    var this$1$1 = this;
    this._withCommit(function() {
      this$1$1._state.data = state;
    });
  };
  Store.prototype.registerModule = function registerModule(path, rawModule, options) {
    if (options === void 0)
      options = {};
    if (typeof path === "string") {
      path = [path];
    }
    this._modules.register(path, rawModule);
    installModule(this, this.state, path, this._modules.get(path), options.preserveState);
    resetStoreState(this, this.state);
  };
  Store.prototype.unregisterModule = function unregisterModule(path) {
    var this$1$1 = this;
    if (typeof path === "string") {
      path = [path];
    }
    this._modules.unregister(path);
    this._withCommit(function() {
      var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
      delete parentState[path[path.length - 1]];
    });
    resetStore(this);
  };
  Store.prototype.hasModule = function hasModule(path) {
    if (typeof path === "string") {
      path = [path];
    }
    return this._modules.isRegistered(path);
  };
  Store.prototype.hotUpdate = function hotUpdate(newOptions) {
    this._modules.update(newOptions);
    resetStore(this, true);
  };
  Store.prototype._withCommit = function _withCommit(fn) {
    var committing = this._committing;
    this._committing = true;
    fn();
    this._committing = committing;
  };
  Object.defineProperties(Store.prototype, prototypeAccessors);
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  var js_cookie = { exports: {} };
  /*!
   * JavaScript Cookie v2.2.1
   * https://github.com/js-cookie/js-cookie
   *
   * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
   * Released under the MIT license
   */
  (function(module2, exports2) {
    (function(factory) {
      var registeredInModuleLoader;
      {
        module2.exports = factory();
        registeredInModuleLoader = true;
      }
      if (!registeredInModuleLoader) {
        var OldCookies = window.Cookies;
        var api = window.Cookies = factory();
        api.noConflict = function() {
          window.Cookies = OldCookies;
          return api;
        };
      }
    })(function() {
      function extend2() {
        var i = 0;
        var result = {};
        for (; i < arguments.length; i++) {
          var attributes = arguments[i];
          for (var key in attributes) {
            result[key] = attributes[key];
          }
        }
        return result;
      }
      function decode2(s) {
        return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
      }
      function init(converter) {
        function api() {
        }
        function set(key, value, attributes) {
          if (typeof document === "undefined") {
            return;
          }
          attributes = extend2({
            path: "/"
          }, api.defaults, attributes);
          if (typeof attributes.expires === "number") {
            attributes.expires = new Date(/* @__PURE__ */ new Date() * 1 + attributes.expires * 864e5);
          }
          attributes.expires = attributes.expires ? attributes.expires.toUTCString() : "";
          try {
            var result = JSON.stringify(value);
            if (/^[\{\[]/.test(result)) {
              value = result;
            }
          } catch (e) {
          }
          value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
          key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
          var stringifiedAttributes = "";
          for (var attributeName in attributes) {
            if (!attributes[attributeName]) {
              continue;
            }
            stringifiedAttributes += "; " + attributeName;
            if (attributes[attributeName] === true) {
              continue;
            }
            stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
          }
          return document.cookie = key + "=" + value + stringifiedAttributes;
        }
        function get(key, json) {
          if (typeof document === "undefined") {
            return;
          }
          var jar = {};
          var cookies2 = document.cookie ? document.cookie.split("; ") : [];
          var i = 0;
          for (; i < cookies2.length; i++) {
            var parts = cookies2[i].split("=");
            var cookie = parts.slice(1).join("=");
            if (!json && cookie.charAt(0) === '"') {
              cookie = cookie.slice(1, -1);
            }
            try {
              var name2 = decode2(parts[0]);
              cookie = (converter.read || converter)(cookie, name2) || decode2(cookie);
              if (json) {
                try {
                  cookie = JSON.parse(cookie);
                } catch (e) {
                }
              }
              jar[name2] = cookie;
              if (key === name2) {
                break;
              }
            } catch (e) {
            }
          }
          return key ? jar[key] : jar;
        }
        api.set = set;
        api.get = function(key) {
          return get(
            key,
            false
            /* read as raw */
          );
        };
        api.getJSON = function(key) {
          return get(
            key,
            true
            /* read as json */
          );
        };
        api.remove = function(key, attributes) {
          set(key, "", extend2(attributes, {
            expires: -1
          }));
        };
        api.defaults = {};
        api.withConverter = init;
        return api;
      }
      return init(function() {
      });
    });
  })(js_cookie);
  var js_cookieExports = js_cookie.exports;
  const Cookies = /* @__PURE__ */ getDefaultExportFromCjs(js_cookieExports);
  const auth = {
    namespaced: true,
    state: {
      user: null,
      isAuthenticated: false,
      requiresAuth: null
    },
    getters: {
      getUser: (state) => state.user,
      isAuthenticated: (state) => state.isAuthenticated,
      requiresAuth: (state) => state.requiresAuth
    },
    mutations: {
      setUser: (state, user) => {
        state.user = user;
      },
      setIsAuthenticated: (state, isAuthenticated) => {
        state.isAuthenticated = isAuthenticated;
      },
      setRequiresAuth: (state, requiresAuth) => {
        state.requiresAuth = requiresAuth;
      }
    },
    actions: {
      authenticate({ state, rootState, commit }, payload) {
        const session = Cookies.get("XSRF-TOKEN");
        const user = state.user;
        const isAuthenticated = !!session && !!user;
        commit("setIsAuthenticated", isAuthenticated);
        if (state.requiresAuth == true && !state.isAuthenticated) {
          Fusion.router.push(payload.guestNext);
        }
        if (state.requiresAuth == false && state.isAuthenticated) {
          Fusion.router.push(payload.adminNext);
        }
      }
    }
  };
  const blueprint = {
    namespaced: true,
    state: {
      remove_index: null
    },
    getters: {
      getRemoveIndex: (state) => {
        return state.remove_index;
      }
    },
    mutations: {
      setRemoveIndex: (state, remove_index) => {
        state.remove_index = remove_index;
      }
    }
  };
  const disks = {
    namespaced: true,
    state: {
      disks: []
    },
    getters: {
      getDisks: (state) => {
        return state.disks;
      }
    },
    mutations: {
      setDisks: (state, disks2) => {
        state.disks = disks2;
      }
    },
    actions: {
      fetchDisks: (context) => {
        axios.get("/api/disks").then((response) => context.commit("setDisks", response.data.data)).catch((error) => console.log(error));
      }
    }
  };
  const fieldtypes = {
    namespaced: true,
    state: {
      structure: false,
      structures: {},
      fieldtypes: {}
    },
    getters: {
      getFilteredFieldtypes: (state) => {
        let fieldtypes2 = {};
        if (state.structure && _.has(state.structures, state.structure)) {
          fieldtypes2 = _.reject(state.fieldtypes, (fieldtype2) => {
            const structure = state.structures[state.structure];
            const excluded = structure.excluded;
            return excluded.includes(fieldtype2.handle);
          });
        }
        return _.keyBy(fieldtypes2, "handle");
      },
      getFieldtypes: (state) => {
        return state.fieldtypes;
      },
      getStructures: (state) => {
        return state.structures;
      }
    },
    mutations: {
      setStructure: (state, structure) => {
        state.structure = _.isEmpty(structure) ? false : structure;
      },
      setStructures: (state, structures) => {
        state.structures = _.keyBy(structures, "handle");
      },
      setFieldtypes: (state, fieldtypes2) => {
        state.fieldtypes = _.keyBy(fieldtypes2, "handle");
      },
      updateStructure: (state, payload) => {
        if (_.has(state.structures, payload.handle)) {
          state.structures[payload.handle] = payload.structure;
        }
      }
    },
    actions: {
      updateStructure: ({ commit }, payload) => {
        commit("updateStructure", payload);
      },
      fetch: ({ state, commit }) => {
        axios.all([
          axios.get("/api/structures"),
          axios.get("/api/fieldtypes")
        ]).then(axios.spread((structures, fieldtypes2) => {
          commit("setStructures", structures.data.data);
          commit("setFieldtypes", fieldtypes2.data.data);
        }));
      }
    }
  };
  var lodash$1 = { exports: {} };
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  lodash$1.exports;
  (function(module2, exports2) {
    (function() {
      var undefined$1;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined$1 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined$1;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined$1 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined$1 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$1;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined$1 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined$1) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined$1) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer2(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined$1 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined$1, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined$1 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined$1;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined$1 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer2(object)) {
            if (!isBuffer2(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
          var isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined$1;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined$1;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString2(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined$1 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result2).set(new Uint8Array(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$1 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString2(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result2 = value;
            }
            if (other !== undefined$1) {
              if (result2 === undefined$1) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined$1;
            }
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString2(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$1;
          }
          ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined$1 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined$1;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined$1 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined$1;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined$1;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$1;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined$1, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined$1);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined$1;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined$1 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined$1;
            }
            return result2;
          };
        }
        var bind2 = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined$1;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now2());
          }
          function debounced() {
            var time = now2(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial2 = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial2));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread2(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial2(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer2 = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined2(value) {
          return value === undefined$1;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString2(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults2 = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith, undefined$1, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined$1 : baseGet(object, path);
          return result2 === undefined$1 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick2 = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined$1;
          }
          while (++index < length) {
            var value = object == null ? undefined$1 : object[toKey(path[index])];
            if (value === undefined$1) {
              index = length;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update2(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined$1;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString2(string).toLowerCase());
        }
        function deburr(string) {
          string = toString2(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString2(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape2(string) {
          string = toString2(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString2(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad2(string, length, chars) {
          string = toString2(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString2(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString2(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString2(string), n);
        }
        function replace() {
          var args = arguments, string = toString2(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString2(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString2(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings2 = lodash2.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$1;
          }
          string = toString2(string);
          options = assignInWith({}, options, settings2, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings2.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString2(value).toLowerCase();
        }
        function toUpper(value) {
          return toString2(value).toUpperCase();
        }
        function trim2(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined$1)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined$1)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString2(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined$1) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString2(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString2(string);
          pattern = guard ? undefined$1 : pattern;
          if (pattern === undefined$1) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind2(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined$1 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString2(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at;
        lodash2.before = before;
        lodash2.bind = bind2;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk;
        lodash2.compact = compact;
        lodash2.concat = concat;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant;
        lodash2.countBy = countBy;
        lodash2.create = create;
        lodash2.curry = curry;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce2;
        lodash2.defaults = defaults2;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter;
        lodash2.flatMap = flatMap;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip;
        lodash2.flow = flow;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys;
        lodash2.keysIn = keysIn;
        lodash2.map = map;
        lodash2.mapKeys = mapKeys;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize;
        lodash2.merge = merge2;
        lodash2.mergeWith = mergeWith;
        lodash2.method = method;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit;
        lodash2.omitBy = omitBy;
        lodash2.once = once;
        lodash2.orderBy = orderBy;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial2;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition;
        lodash2.pick = pick2;
        lodash2.pickBy = pickBy;
        lodash2.property = property;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull;
        lodash2.pullAll = pullAll;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove;
        lodash2.rest = rest;
        lodash2.reverse = reverse;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle;
        lodash2.slice = slice;
        lodash2.sortBy = sortBy;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split;
        lodash2.spread = spread2;
        lodash2.tail = tail;
        lodash2.take = take;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile;
        lodash2.tap = tap;
        lodash2.throttle = throttle;
        lodash2.thru = thru;
        lodash2.toArray = toArray;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject;
        lodash2.transform = transform;
        lodash2.unary = unary;
        lodash2.union = union;
        lodash2.unionBy = unionBy;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update2;
        lodash2.updateWith = updateWith;
        lodash2.values = values;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words;
        lodash2.wrap = wrap;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin(lodash2, lodash2);
        lodash2.add = add;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase;
        lodash2.capitalize = capitalize;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp;
        lodash2.clone = clone;
        lodash2.cloneDeep = cloneDeep;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith;
        lodash2.eq = eq;
        lodash2.escape = escape2;
        lodash2.escapeRegExp = escapeRegExp;
        lodash2.every = every;
        lodash2.find = find;
        lodash2.findIndex = findIndex;
        lodash2.findKey = findKey;
        lodash2.findLast = findLast;
        lodash2.findLastIndex = findLastIndex;
        lodash2.findLastKey = findLastKey;
        lodash2.floor = floor;
        lodash2.forEach = forEach2;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get;
        lodash2.gt = gt;
        lodash2.gte = gte;
        lodash2.has = has;
        lodash2.hasIn = hasIn;
        lodash2.head = head;
        lodash2.identity = identity;
        lodash2.includes = includes;
        lodash2.indexOf = indexOf;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments;
        lodash2.isArray = isArray2;
        lodash2.isArrayBuffer = isArrayBuffer2;
        lodash2.isArrayLike = isArrayLike;
        lodash2.isArrayLikeObject = isArrayLikeObject;
        lodash2.isBoolean = isBoolean;
        lodash2.isBuffer = isBuffer2;
        lodash2.isDate = isDate2;
        lodash2.isElement = isElement;
        lodash2.isEmpty = isEmpty;
        lodash2.isEqual = isEqual;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite;
        lodash2.isFunction = isFunction2;
        lodash2.isInteger = isInteger;
        lodash2.isLength = isLength;
        lodash2.isMap = isMap;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN2;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber2;
        lodash2.isObject = isObject2;
        lodash2.isObjectLike = isObjectLike;
        lodash2.isPlainObject = isPlainObject2;
        lodash2.isRegExp = isRegExp;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet;
        lodash2.isString = isString2;
        lodash2.isSymbol = isSymbol;
        lodash2.isTypedArray = isTypedArray;
        lodash2.isUndefined = isUndefined2;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join;
        lodash2.kebabCase = kebabCase;
        lodash2.last = last;
        lodash2.lastIndexOf = lastIndexOf;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max;
        lodash2.maxBy = maxBy;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min;
        lodash2.minBy = minBy;
        lodash2.stubArray = stubArray;
        lodash2.stubFalse = stubFalse;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop;
        lodash2.now = now2;
        lodash2.pad = pad2;
        lodash2.padEnd = padEnd;
        lodash2.padStart = padStart;
        lodash2.parseInt = parseInt2;
        lodash2.random = random;
        lodash2.reduce = reduce;
        lodash2.reduceRight = reduceRight;
        lodash2.repeat = repeat;
        lodash2.replace = replace;
        lodash2.result = result;
        lodash2.round = round;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase;
        lodash2.startsWith = startsWith;
        lodash2.subtract = subtract;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite;
        lodash2.toInteger = toInteger;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString2;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim2;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape2;
        lodash2.uniqueId = uniqueId;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst;
        lodash2.each = forEach2;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin(lodash2, function() {
          var source = {};
          baseForOwn(lodash2, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash2.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined$1
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      };
      var _2 = runInContext();
      if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root._ = _2;
      }
    }).call(commonjsGlobal);
  })(lodash$1, lodash$1.exports);
  var lodashExports$1 = lodash$1.exports;
  const _$2 = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports$1);
  const filemanager = {
    namespaced: true,
    state: {
      disk: {},
      loading: true,
      files: [],
      directory: 0,
      directories: [],
      selected: {
        files: [],
        directories: []
      },
      rootDirectory: 0,
      currentDirectory: 0,
      parentDirectory: 0,
      breadcrumbs: [],
      search: "",
      display: "everything",
      sort: "name",
      direction: "asc",
      view: "grid",
      currentPage: 1,
      totalPages: 1,
      uploadProgress: 0,
      uploadsVisible: false,
      uploadsMinimized: false,
      fileUploads: [],
      dropzoneVisible: false,
      dropzoneEnabled: true
    },
    getters: {
      getDisk(state) {
        return state.disk;
      },
      getLoading(state) {
        return state.loading;
      },
      getFiles(state) {
        return state.files;
      },
      getDirectories(state) {
        return state.directories;
      },
      getBreadcrumbs(state) {
        return state.breadcrumbs;
      },
      getView(state) {
        return state.view;
      },
      getSearch(state) {
        return state.search;
      },
      getRootDirectory(state) {
        return state.rootDirectory;
      },
      getCurrentDirectory(state) {
        return state.currentDirectory;
      },
      getParentDirectory(state) {
        return state.parentDirectory;
      },
      getDisplay(state) {
        return state.display;
      },
      getSort(state) {
        return state.sort;
      },
      getDirection(state) {
        return state.direction;
      },
      getSelectedFiles(state) {
        return state.selected.files;
      },
      getSelectedDirectories(state) {
        return state.selected.directories;
      },
      hasSelection(state) {
        return state.selected.files.length + state.selected.directories.length > 0;
      },
      selectionCount(state) {
        return state.selected.files.length + state.selected.directories.length;
      },
      getCurrentPage(state) {
        return state.currentPage;
      },
      getTotalPages(state) {
        return state.totalPages;
      },
      getUploadProgress(state) {
        return state.uploadProgress;
      },
      getUploadsVisible(state) {
        return state.uploadsVisible;
      },
      getUploadsMinimized(state) {
        return state.uploadsMinimized;
      },
      getFileUploads(state) {
        return state.fileUploads;
      },
      getDropzoneVisible(state) {
        return state.dropzoneVisible && state.dropzoneEnabled;
      },
      getFileFilters(state) {
        return {
          "filter[directory_id]": state.currentDirectory,
          "filter[display]": state.display !== "everything" ? state.display : null,
          "filter[search]": state.search !== "" ? state.search : null,
          "sort": (state.direction === "asc" ? "" : "-") + state.sort,
          "page": state.currentPage,
          "perPage": state.perPage
        };
      },
      getDirectoryFilters(state) {
        return {
          "filter[search]": state.search !== "" ? state.search : null,
          "filter[parent_id]": state.currentDirectory,
          "sort": state.sort == "name" ? state.direction === "asc" ? "name" : "-name" : null
        };
      }
    },
    mutations: {
      setDisk(state, disk) {
        state.disk = disk;
      },
      setLoading(state, loading) {
        state.loading = loading;
      },
      setFiles(state, files) {
        state.files = files;
      },
      setDirectory(state, directory) {
        state.directory = directory;
      },
      setDirectories(state, directories) {
        state.directories = directories;
      },
      setRootDirectory(state, directory) {
        state.rootDirectory = directory;
      },
      setCurrentDirectory(state, directory) {
        state.currentDirectory = directory;
      },
      setParentDirectory(state, directory) {
        state.parentDirectory = directory;
      },
      setBreadcrumbs(state, breadcrumbs) {
        state.breadcrumbs = breadcrumbs;
      },
      setView(state, view) {
        state.view = view;
      },
      setSearch(state, query) {
        state.search = query;
      },
      setDisplay(state, display) {
        state.display = display;
      },
      setSort(state, sortBy) {
        state.sort = sortBy;
      },
      setDirection(state, direction) {
        state.direction = direction;
      },
      addFile(state, file) {
        state.files.push(file);
      },
      toggleFileSelection(state, file) {
        state.selected.files = _$2.xor(state.selected.files, [file]);
      },
      clearFileSelection(state) {
        state.selected.files = [];
      },
      toggleDirectorySelection(state, directory) {
        state.selected.directories = _$2.xor(state.selected.directories, [directory]);
      },
      clearDirectorySelection(state) {
        state.selected.directories = [];
      },
      removeFiles(state, files) {
        _$2.each(files, function(id) {
          let index = _$2.findIndex(state.files, function(file) {
            return file.id == id;
          });
          state.files.splice(index, 1);
        });
      },
      clearFiles(state) {
        state.files = [];
      },
      setCurrentPage(state, page) {
        state.currentPage = page;
      },
      setTotalPages(state, pages) {
        state.totalPages = pages;
      },
      setUploadProgress(state, progress) {
        state.uploadProgress = progress;
      },
      setUploadsMinimized(state, value) {
        state.uploadsMinimized = value;
      },
      setUploadsVisible(state, value) {
        state.uploadsVisible = value;
      },
      setFileUploads(state, files) {
        state.fileUploads = files;
      },
      addFileUpload(state, file) {
        state.fileUploads.push(file);
      },
      setDropzoneVisible(state, value) {
        state.dropzoneVisible = value;
      },
      setDropzoneEnabled(state, value) {
        state.dropzoneEnabled = value;
      }
    },
    actions: {
      reset({ commit }) {
        commit("setRootDirectory", 0);
        commit("setCurrentDirectory", null);
        commit("setParentDirectory", null);
        commit("clearFileSelection");
        commit("clearDirectorySelection");
      },
      setLoading(context, loading) {
        context.commit("setLoading", loading);
      },
      setFiles(context, files) {
        context.commit("setFiles", files);
      },
      addFile(context, file) {
        context.commit("addFile", file);
      },
      toggleFileSelection(context, file) {
        context.commit("toggleFileSelection", file);
      },
      toggleDirectorySelection(context, directory) {
        context.commit("toggleDirectorySelection", directory);
      },
      clearFiles(context) {
        context.commit("clearFiles");
      },
      removeFiles(context, files) {
        context.commit("removeFiles", files);
      },
      clearFileSelection(context) {
        context.commit("clearFileSelection");
      },
      clearDirectorySelection(context) {
        context.commit("clearDirectorySelection");
      },
      fetchDisk({ commit, dispatch }, disk) {
        axios.get(`/api/disks/${disk}`).then(({ data }) => {
          commit("setDisk", data.data);
          dispatch("fetchFilesAndDirectories");
        }).catch((errors) => console.log(errors));
      },
      fetchFilesAndDirectories: _$2.throttle(({ state, getters, commit, dispatch }) => {
        commit("setLoading", true);
        let getDirectory = null;
        if (state.currentDirectory > 0)
          getDirectory = axios.get(`/api/directories/${state.disk.id}/${state.currentDirectory}`);
        axios.all([
          axios.get(`/api/files/${state.disk.id}`, { params: getters.getFileFilters }),
          axios.get(`/api/directories/${state.disk.id}`, { params: getters.getDirectoryFilters }),
          getDirectory
        ]).then(
          axios.spread((files, directories, currentDirectory) => {
            commit("setFiles", files.data.data);
            commit("setTotalPages", files.data.meta.last_page);
            commit("setDirectories", directories.data.data);
            commit("setDirectory", currentDirectory ? currentDirectory.data.data : null);
            commit("setLoading", false);
            dispatch("setBreadcrumbs");
          })
        ).catch((errors) => {
          console.error(errors);
        });
      }, 500),
      fetchFiles: _$2.throttle(({ state, getters, commit, dispatch }) => {
        commit("setLoading", true);
        let getDirectory = null;
        if (state.currentDirectory > 0)
          getDirectory = axios.get(`/api/directories/${state.disk.id}/${state.currentDirectory}`);
        axios.all([
          axios.get(`/api/files/${state.disk.id}`, { params: getters.getFileFilters }),
          getDirectory
        ]).then(
          axios.spread((files, currentDirectory) => {
            commit("setFiles", files.data.data);
            commit("setTotalPages", files.data.meta.last_page);
            commit("setDirectory", currentDirectory ? currentDirectory.data.data : null);
            commit("setLoading", false);
            dispatch("setBreadcrumbs");
          })
        ).catch((errors) => {
          console.error(errors);
        });
      }, 500),
      fetchDirectories: _$2.throttle(({ state, getters, commit, dispatch }) => {
        commit("setLoading", true);
        let getDirectory = null;
        if (state.currentDirectory > 0)
          getDirectory = axios.get(`/api/directories/${state.disk.id}/${state.currentDirectory}`);
        axios.all([
          axios.get(`/api/directories/${state.disk.id}`, { params: getters.getDirectoryFilters }),
          getDirectory
        ]).then(
          axios.spread((directories, currentDirectory) => {
            commit("setDirectories", directories.data.data);
            commit("setDirectory", currentDirectory ? currentDirectory.data.data : null);
            commit("setLoading", false);
            dispatch("setBreadcrumbs");
          })
        ).catch((errors) => {
          console.error(errors);
        });
      }, 500),
      moveFileToDirectory({ commit, state, dispatch }, payload) {
        axios.post(`/api/files/${state.disk.id}/move`, {
          directory: payload.directory,
          moving: payload.moving
        }).then((response) => {
          dispatch("fetchFilesAndDirectories");
          toast("File(s) have been successfully moved!", "success");
        }).catch((errors) => {
          toast(errors.response.data.errors.moving[0], "failed");
        });
      },
      setSearch(context, query) {
        context.commit("setSearch", query);
      },
      setDisplay(context, display) {
        context.commit("setDisplay", display);
      },
      setSort(context, sortBy) {
        context.commit("setSort", sortBy);
      },
      setDirection(context, direction) {
        context.commit("setDirection", direction);
      },
      setBreadcrumbs({ state, commit }) {
        let breadcrumbs = [];
        let directory = state.directory;
        let root = state.rootDirectory;
        while (_$2.has(directory, "id") && directory.id != root) {
          breadcrumbs.unshift(directory);
          directory = directory.parent;
        }
        if (root == 0) {
          breadcrumbs.unshift({ id: null, name: "Root" });
        } else {
          breadcrumbs.unshift(directory);
        }
        commit("setBreadcrumbs", breadcrumbs);
      },
      setDirectories(context, directories) {
        context.commit("setDirectories", directories);
      },
      setRootDirectory(context, directory) {
        context.commit("setRootDirectory", directory);
      },
      setCurrentDirectory(context, directory) {
        context.commit("setCurrentDirectory", directory);
      },
      setParentDirectory(context, directory) {
        context.commit("setParentDirectory", directory);
      },
      setCurrentPage(context, page) {
        context.commit("setCurrentPage", page);
      },
      setTotalPages(context, pages) {
        context.commit("setTotalPages", pages);
      },
      setUploadProgress(context, progress) {
        context.commit("setUploadProgress", progress);
      },
      setUploadsVisible(context, value) {
        context.commit("setUploadsVisible", value);
      },
      setUploadsMinimized(context, value) {
        context.commit("setUploadsMinimized", value);
      },
      setFileUploads(context, files) {
        context.commit("fileUploads", files);
      },
      addFileUpload(context, file) {
        context.commit("addFileUpload", file);
      },
      setDropzoneVisible(context, value) {
        context.commit("setDropzoneVisible", value);
      },
      setDropzoneEnabled(context, value) {
        context.commit("setDropzoneEnabled", value);
      },
      toggleView(context) {
        if (context.state.view === "grid") {
          context.commit("setView", "list");
        } else {
          context.commit("setView", "grid");
        }
      },
      toggleDirection(context) {
        if (context.state.direction === "asc") {
          context.commit("setDirection", "desc");
        } else {
          context.commit("setDirection", "asc");
        }
      }
    }
  };
  const form = {
    namespaced: true,
    state: {
      preventNavigation: false,
      confirmModalVisible: false,
      confirmModalCallback: null
    },
    getters: {
      preventNavigation: (state) => state.preventNavigation,
      confirmModalVisible: (state) => state.confirmModalVisible,
      confirmModalCallback: (state) => state.confirmModalCallback
    },
    mutations: {
      setPreventNavigation: (state, preventNavigation) => {
        state.preventNavigation = preventNavigation;
      },
      setConfirmModalVisible: (state, confirmModalVisible) => {
        state.confirmModalVisible = confirmModalVisible;
      },
      setConfirmModalCallback: (state, confirmModalCallback) => {
        state.confirmModalCallback = confirmModalCallback;
      }
    }
  };
  const fusion = {
    namespaced: true,
    state: {
      version: null
    },
    getters: {
      getVersion: (state) => {
        return state.version;
      },
      getConfig: (state) => {
        return state.config;
      }
    },
    mutations: {
      setVersion: (state, version2) => {
        state.version = version2;
      },
      setConfig: (state, config) => {
        state.config = config;
      }
    }
  };
  const inbox = {
    namespaced: true,
    state: {
      page: 1,
      totalPages: 1,
      form: {},
      forms: [],
      fields: [],
      response: {},
      responses: [],
      loading: false
    },
    getters: {
      getPage(state) {
        return state.page;
      },
      getTotalPages(state) {
        return state.totalPages;
      },
      getLoading(state) {
        return state.loading;
      },
      getResponse(state) {
        return state.response;
      },
      getResponses(state) {
        return state.responses;
      },
      getForm(state) {
        return state.form;
      },
      getForms(state) {
        return state.forms;
      },
      getFields(state) {
        return state.fields;
      }
    },
    mutations: {
      setPage(state, page) {
        state.page = page;
      },
      setTotalPages(state, pages) {
        state.totalPages = pages;
      },
      setLoading(state, loading) {
        state.loading = loading;
      },
      setResponse(state, response) {
        state.response = response;
      },
      setResponses(state, responses) {
        state.responses = responses;
      },
      setForm(state, form2) {
        state.form = form2;
      },
      setForms(state, forms) {
        state.forms = forms;
      },
      setFields(state, fields) {
        state.fields = fields;
      }
    },
    actions: {
      fetchForms(context) {
        return axios.get("/api/forms").then((response) => {
          context.commit("setForms", response.data.data);
        });
      },
      fetchResponses(context) {
        if (context.state.form.slug) {
          context.dispatch("isLoading");
          return axios.get("/api/forms/" + context.state.form.slug + "/responses?page=" + context.state.page).then((response) => {
            context.commit("setResponses", response.data.data);
            context.commit("setTotalPages", response.data.meta.last_page);
            context.dispatch("doneLoading");
          });
        }
      },
      selectForm(context, form2) {
        context.dispatch("reset");
        context.commit("setForm", form2);
        context.dispatch("fetchResponses");
      },
      selectResponse(context, response) {
        context.commit("setResponse", response);
        context.dispatch("extractFields", response);
      },
      clearResponse(context) {
        context.commit("setResponse", {});
      },
      selectFirstResponse(context) {
        if (context.state.responses.length) {
          context.dispatch("selectResponse", _$2.head(context.state.responses));
        }
      },
      extractFields(context, response) {
        let fields = [];
        let sections = response.form.blueprint.sections;
        _$2.each(sections, (section) => {
          _$2.each(section.fields, (field) => {
            fields.push(field);
          });
        });
        context.commit("setFields", fields);
      },
      isLoading(context) {
        context.commit("setLoading", true);
      },
      doneLoading(context) {
        context.commit("setLoading", false);
      },
      jumpPage(context, page) {
        context.commit("setPage", page);
      },
      nextPage(context) {
        if (context.state.page !== context.state.totalPages) {
          context.commit("setPage", context.state.page + 1);
        }
      },
      prevPage(context) {
        if (context.state.page !== 1) {
          context.commit("setPage", context.state.page - 1);
        }
      },
      firstPage(context) {
        context.commit("setPage", 1);
      },
      lastPage(context) {
        context.commit("setPage", context.state.totalPages);
      },
      reset(context) {
        context.commit("setPage", 1);
        context.commit("setTotalPages", 1);
        context.commit("setForm", {});
        context.commit("setFields", []);
        context.commit("setResponse", {});
        context.commit("setResponses", []);
        context.commit("setLoading", false);
      }
    }
  };
  const navigation = {
    namespaced: true,
    state: {
      navigation: []
    },
    getters: {
      getNavigation: (state) => {
        return state.navigation;
      }
    },
    mutations: {
      SET_NAVIGATION: (state, links) => {
        state.navigation = links;
      }
    },
    actions: {
      fetchAdminNavigation: (context) => {
        axios.get("/api/admin/navigation").then((response) => {
          context.commit("SET_NAVIGATION", response.data.data);
        }).catch((error) => {
          console.log("There was an error fetching the navigation...");
        });
      }
    }
  };
  const notifications = {
    namespaced: true,
    state: {
      channels: [],
      notifications: []
    },
    getters: {
      getChannels: (state) => state.channels,
      getNotifications: (state) => state.notifications
    },
    mutations: {
      setChannels: (state, channels) => {
        state.channels = channels;
      },
      setNotifications: (state, notifications2) => {
        state.notifications = notifications2;
      }
    },
    actions: {
      fetch: ({ commit }) => {
        axios.all([
          axios.get("/api/channels"),
          axios.get("/api/notifications")
        ]).then(axios.spread((channels, notifications2) => {
          commit("setChannels", channels.data.data);
          commit("setNotifications", notifications2.data.data);
        }));
      }
    }
  };
  const settings = {
    namespaced: true,
    state: {
      groups: {},
      settings: {}
    },
    getters: {
      getGroup: (state) => (key) => {
        return state.groups[key];
      },
      getGroups: (state) => {
        return state.groups;
      },
      getGroupSections: (state) => {
        return _.groupBy(state.groups, "group");
      },
      getSetting: (state) => (key) => {
        return state.settings[key];
      },
      getSettings: (state) => {
        return state.settings;
      }
    },
    mutations: {
      setGroups(state, payload) {
        state.groups = _.keyBy(payload, "handle");
      },
      setSettings(state, payload) {
        let items = _.map(payload, "settings");
        let settings2 = {};
        _.forEach(items, (item) => _.merge(settings2, item));
        state.settings = settings2;
      }
    },
    actions: {
      fetchSettings(context) {
        axios.get("/api/settings").then((response) => {
          context.commit("setGroups", response.data.data);
          context.commit("setSettings", response.data.data);
        }).catch((error) => {
          console.error("There was an error fetching the system settings...");
          console.error(error.message);
        });
      }
    }
  };
  const store = createStore({
    modules: {
      auth,
      blueprint,
      disks,
      fieldtypes,
      filemanager,
      form,
      fusion,
      inbox,
      navigation,
      notifications,
      settings
    }
  });
  let onUpdate = _.debounce((obj) => {
    const hasChanges = !_.isEqual(obj.orig, obj.data());
    if (obj.blockNav && obj.hasChanges != hasChanges)
      store.commit("form/setPreventNavigation", hasChanges);
    obj.hasChanges = hasChanges;
  }, 250);
  class Form {
    constructor(data, blockNav = false) {
      this.blockNav = blockNav;
      this.orig = data;
      this.errors = new Errors();
      this.hasChanges = false;
      let form2 = this;
      let handler = {
        set(obj, key, val, rcvr) {
          Reflect.set(...arguments);
          onUpdate(form2);
          return true;
        }
      };
      _.each(data, (v, k) => {
        this[k] = this.proxify(v, handler);
      });
      return new Proxy(this, handler);
    }
    proxify(data, handler = {}) {
      if (_.isArray(data))
        return _.map(data, (v, k) => this.proxify(v, handler));
      else if (_.isObject(data))
        return new Proxy(_.mapValues(data, (v, k) => {
          return this.proxify(v, handler);
        }), handler);
      return data;
    }
    data() {
      return _.mapValues(this.orig, (v, k) => this[k]);
    }
    formdata(additional = {}) {
      let data = new FormData();
      let json = {};
      _.each(this.data(), (v, k) => {
        if (v instanceof FileList)
          _.each(v, (val) => data.append(`${k}[]`, val));
        else if (v instanceof File)
          data.append(k, v);
        else
          json[k] = v;
      });
      if (!_.isEmpty(json))
        data.append("_json", JSON.stringify(json));
      _.each(additional, (v, k) => data.append(k, v));
      return data;
    }
    post(url) {
      return this.submit("post", url, this.formdata());
    }
    patch(url) {
      return this.submit("post", url, this.formdata({ "_method": "PATCH" }));
    }
    put(url) {
      return this.submit("post", url, this.formdata({ "_method": "PUT" }));
    }
    delete(url) {
      return this.submit("post", url, this.formdata({ "_method": "DELETE" }));
    }
    submit(rType, url, data) {
      return new Promise((resolve, reject) => {
        axios[rType](url, data).then((response) => {
          this.onSuccess(response.data);
          resolve(response.data);
        }).catch((errors) => {
          this.onFailure(errors.response.data);
          reject(errors.response.data);
        });
      });
    }
    onSuccess(data) {
      this.orig = _.cloneDeep(this.data());
      this.hasChanges = false;
      this.errors.clear();
      if (this.blockNav)
        store.commit("form/setPreventNavigation", false);
    }
    onFailure(errors) {
      this.errors.record(errors);
    }
  }
  const DependantField = {
    methods: {
      registerComponentsDependency(children, form2) {
        _.each(children, (component, fieldKey) => {
          if (component.dependsOn) {
            this.registerWatch(form2, component, children, fieldKey);
          }
          if (component.children) {
            this.registerComponentsDependency(component.children, form2);
          }
        });
      },
      registerWatch(form2, fieldToBeUpdated, fieldCollections, fieldKey) {
        fieldToBeUpdated.dependsOn.forEach((attribute) => {
          this.$watch("form." + attribute, (value, oldValue) => {
            this.syncDependantFields(form2, fieldToBeUpdated, attribute, fieldCollections, fieldKey);
          }, { deep: true });
        });
      },
      syncDependantFields(form2, fieldToBeUpdated, dependsOnAttribute, fieldCollections, fieldKey) {
        let params = {
          field: fieldToBeUpdated.handle,
          path: fieldToBeUpdated.path,
          attribute: dependsOnAttribute,
          form: form2.data()
        };
        axios.patch(this.syncDependantFieldUrl, params).then((response) => {
          let field = response.data;
          this.$set(fieldCollections, fieldKey, field);
        });
      }
    }
  };
  const _export_sfc = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
      target[key] = val;
    }
    return target;
  };
  const _sfc_main$u = {
    mixins: [DependantField],
    props: {
      classes: {},
      debug: {
        default: false
      },
      name: {
        default: "_antfusion_form"
      },
      loading: {
        default: false
      },
      actions: {},
      children: {},
      fields: {},
      values: {
        default: {}
      },
      errors: {
        default: {}
      },
      syncDependantFieldUrl: {}
    },
    data() {
      return {
        // componentsByHandle: {},
        form: new Form()
      };
    },
    methods: {
      submitted() {
        this.$emit("submitted", this.form);
      },
      refreshed() {
        bus().$emit("refresh-form", this.form);
      }
    },
    mounted() {
      let form2 = {};
      _.each(this.fields, (field) => {
        form2[field.handle] = this.values[field.handle] || field.default;
        console.log("field", field);
        console.log("set " + field.handle, this.values[field.handle], field.default);
        console.log("value", form2[field.handle]);
      });
      this.form = new Form(form2, true);
      this.form.errors.record({ errors: this.errors });
      this.registerComponentsDependency(this.children, this.form);
    },
    computed: {
      componentData() {
        return this.form;
      }
    }
  };
  const _hoisted_1$i = { class: "print:hidden" };
  const _hoisted_2$8 = { key: 0 };
  const _hoisted_3$5 = ["name", "value"];
  function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_portal = require$$0$1.resolveComponent("portal");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      require$$0$1.createVNode(_component_portal, { to: "actions" }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createElementVNode("span", _hoisted_1$i, [
            (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($props.actions, (action, index) => {
              return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(action.component), require$$0$1.mergeProps(action, {
                onLoad: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("load")),
                onLoaded: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("loaded")),
                onSubmitted: $options.submitted,
                onRefreshed: $options.refreshed,
                loading: $props.loading,
                parent: $options.componentData,
                key: index
              }), {
                default: require$$0$1.withCtx(() => [
                  require$$0$1.createTextVNode(require$$0$1.toDisplayString(action.text), 1)
                ], void 0, true),
                _: 2
              }, 1040, ["onSubmitted", "onRefreshed", "loading", "parent"]);
            }), 128))
          ])
        ], void 0, true),
        _: 1
      }),
      $props.debug ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_2$8, require$$0$1.toDisplayString($data.form), 1)) : require$$0$1.createCommentVNode("", true),
      require$$0$1.createElementVNode("div", {
        class: require$$0$1.normalizeClass($props.classes)
      }, [
        (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($props.children, (field) => {
          return require$$0$1.openBlock(), require$$0$1.createElementBlock(require$$0$1.Fragment, null, [
            !field.is_panel ? require$$0$1.withDirectives((require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(field.component), require$$0$1.mergeProps({ key: 0 }, field, {
              key: field.id,
              onRefreshed: $options.refreshed,
              onLoad: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("load")),
              onLoaded: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("loaded")),
              loading: $props.loading,
              parent: $options.componentData,
              modelValue: $data.form[field.handle],
              "onUpdate:modelValue": ($event) => $data.form[field.handle] = $event
            }, {
              form: $data.form,
              "has-error": $data.form.errors.has(field.handle),
              "error-message": $data.form.errors.get(field.handle)
            }), {
              default: require$$0$1.withCtx(() => [
                require$$0$1.createTextVNode(require$$0$1.toDisplayString(field.text), 1)
              ], void 0, true),
              _: 2
            }, 1040, ["onRefreshed", "loading", "parent", "modelValue", "onUpdate:modelValue", "form", "has-error", "error-message"])), [
              [require$$0$1.vShow, !field.hide]
            ]) : require$$0$1.withDirectives((require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(field.component), require$$0$1.mergeProps({ key: 1 }, field, {
              key: field.id
            }, {
              onRefreshed: $options.refreshed,
              form: $data.form,
              "sync-dependant-field-url": $props.syncDependantFieldUrl
            }), {
              default: require$$0$1.withCtx(() => [
                require$$0$1.createTextVNode(require$$0$1.toDisplayString(field.text), 1)
              ], void 0, true),
              _: 2
            }, 1040, ["onRefreshed", "form", "sync-dependant-field-url"])), [
              [require$$0$1.vShow, !field.hide]
            ])
          ], 64);
        }), 256))
      ], 2),
      require$$0$1.createElementVNode("input", {
        type: "hidden",
        name: $props.name,
        value: JSON.stringify(this.form.data())
      }, null, 8, _hoisted_3$5)
    ]);
  }
  const AntFusionForm = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$t]]);
  const AntFusionForm$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: AntFusionForm
  }, Symbol.toStringTag, { value: "Module" }));
  var axios$4 = { exports: {} };
  var bind$2 = function bind2(fn, thisArg) {
    return function wrap() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      return fn.apply(thisArg, args);
    };
  };
  var bind$1 = bind$2;
  var toString = Object.prototype.toString;
  function isArray(val) {
    return toString.call(val) === "[object Array]";
  }
  function isUndefined(val) {
    return typeof val === "undefined";
  }
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
  }
  function isArrayBuffer(val) {
    return toString.call(val) === "[object ArrayBuffer]";
  }
  function isFormData(val) {
    return typeof FormData !== "undefined" && val instanceof FormData;
  }
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && val.buffer instanceof ArrayBuffer;
    }
    return result;
  }
  function isString(val) {
    return typeof val === "string";
  }
  function isNumber(val) {
    return typeof val === "number";
  }
  function isObject(val) {
    return val !== null && typeof val === "object";
  }
  function isPlainObject(val) {
    if (toString.call(val) !== "[object Object]") {
      return false;
    }
    var prototype = Object.getPrototypeOf(val);
    return prototype === null || prototype === Object.prototype;
  }
  function isDate(val) {
    return toString.call(val) === "[object Date]";
  }
  function isFile(val) {
    return toString.call(val) === "[object File]";
  }
  function isBlob(val) {
    return toString.call(val) === "[object Blob]";
  }
  function isFunction(val) {
    return toString.call(val) === "[object Function]";
  }
  function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  }
  function isURLSearchParams(val) {
    return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
  }
  function trim(str) {
    return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
  }
  function isStandardBrowserEnv() {
    if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  }
  function forEach(obj, fn) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (var i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn.call(null, obj[key], key, obj);
        }
      }
    }
  }
  function merge() {
    var result = {};
    function assignValue(val, key) {
      if (isPlainObject(result[key]) && isPlainObject(val)) {
        result[key] = merge(result[key], val);
      } else if (isPlainObject(val)) {
        result[key] = merge({}, val);
      } else if (isArray(val)) {
        result[key] = val.slice();
      } else {
        result[key] = val;
      }
    }
    for (var i = 0, l = arguments.length; i < l; i++) {
      forEach(arguments[i], assignValue);
    }
    return result;
  }
  function extend(a2, b, thisArg) {
    forEach(b, function assignValue(val, key) {
      if (thisArg && typeof val === "function") {
        a2[key] = bind$1(val, thisArg);
      } else {
        a2[key] = val;
      }
    });
    return a2;
  }
  function stripBOM(content) {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  }
  var utils$9 = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString,
    isNumber,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isFunction,
    isStream,
    isURLSearchParams,
    isStandardBrowserEnv,
    forEach,
    merge,
    extend,
    trim,
    stripBOM
  };
  var utils$8 = utils$9;
  function encode$1(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  var buildURL$1 = function buildURL2(url, params, paramsSerializer) {
    if (!params) {
      return url;
    }
    var serializedParams;
    if (paramsSerializer) {
      serializedParams = paramsSerializer(params);
    } else if (utils$8.isURLSearchParams(params)) {
      serializedParams = params.toString();
    } else {
      var parts = [];
      utils$8.forEach(params, function serialize(val, key) {
        if (val === null || typeof val === "undefined") {
          return;
        }
        if (utils$8.isArray(val)) {
          key = key + "[]";
        } else {
          val = [val];
        }
        utils$8.forEach(val, function parseValue2(v) {
          if (utils$8.isDate(v)) {
            v = v.toISOString();
          } else if (utils$8.isObject(v)) {
            v = JSON.stringify(v);
          }
          parts.push(encode$1(key) + "=" + encode$1(v));
        });
      });
      serializedParams = parts.join("&");
    }
    if (serializedParams) {
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  };
  var utils$7 = utils$9;
  function InterceptorManager$1() {
    this.handlers = [];
  }
  InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  };
  InterceptorManager$1.prototype.eject = function eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  };
  InterceptorManager$1.prototype.forEach = function forEach2(fn) {
    utils$7.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  };
  var InterceptorManager_1 = InterceptorManager$1;
  var utils$6 = utils$9;
  var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
    utils$6.forEach(headers, function processHeader(value, name2) {
      if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
        headers[normalizedName] = value;
        delete headers[name2];
      }
    });
  };
  var enhanceError$1 = function enhanceError2(error, config, code, request, response) {
    error.config = config;
    if (code) {
      error.code = code;
    }
    error.request = request;
    error.response = response;
    error.isAxiosError = true;
    error.toJSON = function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: this.config,
        code: this.code
      };
    };
    return error;
  };
  var createError;
  var hasRequiredCreateError;
  function requireCreateError() {
    if (hasRequiredCreateError)
      return createError;
    hasRequiredCreateError = 1;
    var enhanceError2 = enhanceError$1;
    createError = function createError2(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError2(error, config, code, request, response);
    };
    return createError;
  }
  var settle;
  var hasRequiredSettle;
  function requireSettle() {
    if (hasRequiredSettle)
      return settle;
    hasRequiredSettle = 1;
    var createError2 = requireCreateError();
    settle = function settle2(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError2(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
    return settle;
  }
  var cookies;
  var hasRequiredCookies;
  function requireCookies() {
    if (hasRequiredCookies)
      return cookies;
    hasRequiredCookies = 1;
    var utils2 = utils$9;
    cookies = utils2.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name2, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name2 + "=" + encodeURIComponent(value));
            if (utils2.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils2.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils2.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name2) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name2) {
            this.write(name2, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
    return cookies;
  }
  var isAbsoluteURL;
  var hasRequiredIsAbsoluteURL;
  function requireIsAbsoluteURL() {
    if (hasRequiredIsAbsoluteURL)
      return isAbsoluteURL;
    hasRequiredIsAbsoluteURL = 1;
    isAbsoluteURL = function isAbsoluteURL2(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
    return isAbsoluteURL;
  }
  var combineURLs;
  var hasRequiredCombineURLs;
  function requireCombineURLs() {
    if (hasRequiredCombineURLs)
      return combineURLs;
    hasRequiredCombineURLs = 1;
    combineURLs = function combineURLs2(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
    return combineURLs;
  }
  var buildFullPath;
  var hasRequiredBuildFullPath;
  function requireBuildFullPath() {
    if (hasRequiredBuildFullPath)
      return buildFullPath;
    hasRequiredBuildFullPath = 1;
    var isAbsoluteURL2 = requireIsAbsoluteURL();
    var combineURLs2 = requireCombineURLs();
    buildFullPath = function buildFullPath2(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL2(requestedURL)) {
        return combineURLs2(baseURL, requestedURL);
      }
      return requestedURL;
    };
    return buildFullPath;
  }
  var parseHeaders;
  var hasRequiredParseHeaders;
  function requireParseHeaders() {
    if (hasRequiredParseHeaders)
      return parseHeaders;
    hasRequiredParseHeaders = 1;
    var utils2 = utils$9;
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    parseHeaders = function parseHeaders2(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils2.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils2.trim(line.substr(0, i)).toLowerCase();
        val = utils2.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
    return parseHeaders;
  }
  var isURLSameOrigin;
  var hasRequiredIsURLSameOrigin;
  function requireIsURLSameOrigin() {
    if (hasRequiredIsURLSameOrigin)
      return isURLSameOrigin;
    hasRequiredIsURLSameOrigin = 1;
    var utils2 = utils$9;
    isURLSameOrigin = utils2.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }()
    );
    return isURLSameOrigin;
  }
  var xhr;
  var hasRequiredXhr;
  function requireXhr() {
    if (hasRequiredXhr)
      return xhr;
    hasRequiredXhr = 1;
    var utils2 = utils$9;
    var settle2 = requireSettle();
    var cookies2 = requireCookies();
    var buildURL2 = buildURL$1;
    var buildFullPath2 = requireBuildFullPath();
    var parseHeaders2 = requireParseHeaders();
    var isURLSameOrigin2 = requireIsURLSameOrigin();
    var createError2 = requireCreateError();
    xhr = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        if (utils2.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath2(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL2(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders2(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle2(resolve, reject, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError2("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError2("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError2(
            timeoutErrorMessage,
            config,
            config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils2.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin2(fullPath)) && config.xsrfCookieName ? cookies2.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils2.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
            request.abort();
            reject(cancel);
            request = null;
          });
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
    return xhr;
  }
  var utils$5 = utils$9;
  var normalizeHeaderName = normalizeHeaderName$1;
  var enhanceError = enhanceError$1;
  var DEFAULT_CONTENT_TYPE = {
    "Content-Type": "application/x-www-form-urlencoded"
  };
  function setContentTypeIfUnset(headers, value) {
    if (!utils$5.isUndefined(headers) && utils$5.isUndefined(headers["Content-Type"])) {
      headers["Content-Type"] = value;
    }
  }
  function getDefaultAdapter() {
    var adapter;
    if (typeof XMLHttpRequest !== "undefined") {
      adapter = requireXhr();
    } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
      adapter = requireXhr();
    }
    return adapter;
  }
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$5.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$5.trim(rawValue);
      } catch (e) {
        if (e.name !== "SyntaxError") {
          throw e;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  var defaults$4 = {
    transitional: {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    },
    adapter: getDefaultAdapter(),
    transformRequest: [function transformRequest(data, headers) {
      normalizeHeaderName(headers, "Accept");
      normalizeHeaderName(headers, "Content-Type");
      if (utils$5.isFormData(data) || utils$5.isArrayBuffer(data) || utils$5.isBuffer(data) || utils$5.isStream(data) || utils$5.isFile(data) || utils$5.isBlob(data)) {
        return data;
      }
      if (utils$5.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$5.isURLSearchParams(data)) {
        setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
        return data.toString();
      }
      if (utils$5.isObject(data) || headers && headers["Content-Type"] === "application/json") {
        setContentTypeIfUnset(headers, "application/json");
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      var transitional = this.transitional;
      var silentJSONParsing = transitional && transitional.silentJSONParsing;
      var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
      if (strictJSONParsing || forcedJSONParsing && utils$5.isString(data) && data.length) {
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === "SyntaxError") {
              throw enhanceError(e, this, "E_JSON_PARSE");
            }
            throw e;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    }
  };
  defaults$4.headers = {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  };
  utils$5.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
    defaults$4.headers[method] = {};
  });
  utils$5.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    defaults$4.headers[method] = utils$5.merge(DEFAULT_CONTENT_TYPE);
  });
  var defaults_1 = defaults$4;
  var utils$4 = utils$9;
  var defaults$3 = defaults_1;
  var transformData$1 = function transformData2(data, headers, fns) {
    var context = this || defaults$3;
    utils$4.forEach(fns, function transform(fn) {
      data = fn.call(context, data, headers);
    });
    return data;
  };
  var isCancel$1;
  var hasRequiredIsCancel;
  function requireIsCancel() {
    if (hasRequiredIsCancel)
      return isCancel$1;
    hasRequiredIsCancel = 1;
    isCancel$1 = function isCancel2(value) {
      return !!(value && value.__CANCEL__);
    };
    return isCancel$1;
  }
  var utils$3 = utils$9;
  var transformData = transformData$1;
  var isCancel = requireIsCancel();
  var defaults$2 = defaults_1;
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
  }
  var dispatchRequest$1 = function dispatchRequest2(config) {
    throwIfCancellationRequested(config);
    config.headers = config.headers || {};
    config.data = transformData.call(
      config,
      config.data,
      config.headers,
      config.transformRequest
    );
    config.headers = utils$3.merge(
      config.headers.common || {},
      config.headers[config.method] || {},
      config.headers
    );
    utils$3.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      function cleanHeaderConfig(method) {
        delete config.headers[method];
      }
    );
    var adapter = config.adapter || defaults$2.adapter;
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        response.data,
        response.headers,
        config.transformResponse
      );
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            reason.response.data,
            reason.response.headers,
            config.transformResponse
          );
        }
      }
      return Promise.reject(reason);
    });
  };
  var utils$2 = utils$9;
  var mergeConfig$2 = function mergeConfig2(config1, config2) {
    config2 = config2 || {};
    var config = {};
    var valueFromConfig2Keys = ["url", "method", "data"];
    var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
    var defaultToConfig2Keys = [
      "baseURL",
      "transformRequest",
      "transformResponse",
      "paramsSerializer",
      "timeout",
      "timeoutMessage",
      "withCredentials",
      "adapter",
      "responseType",
      "xsrfCookieName",
      "xsrfHeaderName",
      "onUploadProgress",
      "onDownloadProgress",
      "decompress",
      "maxContentLength",
      "maxBodyLength",
      "maxRedirects",
      "transport",
      "httpAgent",
      "httpsAgent",
      "cancelToken",
      "socketPath",
      "responseEncoding"
    ];
    var directMergeKeys = ["validateStatus"];
    function getMergedValue(target, source) {
      if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
        return utils$2.merge(target, source);
      } else if (utils$2.isPlainObject(source)) {
        return utils$2.merge({}, source);
      } else if (utils$2.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (!utils$2.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    }
    utils$2.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      }
    });
    utils$2.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
    utils$2.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
      if (!utils$2.isUndefined(config2[prop])) {
        config[prop] = getMergedValue(void 0, config2[prop]);
      } else if (!utils$2.isUndefined(config1[prop])) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    utils$2.forEach(directMergeKeys, function merge2(prop) {
      if (prop in config2) {
        config[prop] = getMergedValue(config1[prop], config2[prop]);
      } else if (prop in config1) {
        config[prop] = getMergedValue(void 0, config1[prop]);
      }
    });
    var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
    var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });
    utils$2.forEach(otherKeys, mergeDeepProperties);
    return config;
  };
  const name = "axios";
  const version = "0.21.4";
  const description = "Promise based HTTP client for the browser and node.js";
  const main = "index.js";
  const scripts = {
    test: "grunt test",
    start: "node ./sandbox/server.js",
    build: "NODE_ENV=production grunt build",
    preversion: "npm test",
    version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
    postversion: "git push && git push --tags",
    examples: "node ./examples/server.js",
    coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
    fix: "eslint --fix lib/**/*.js"
  };
  const repository = {
    type: "git",
    url: "https://github.com/axios/axios.git"
  };
  const keywords = [
    "xhr",
    "http",
    "ajax",
    "promise",
    "node"
  ];
  const author = "Matt Zabriskie";
  const license = "MIT";
  const bugs = {
    url: "https://github.com/axios/axios/issues"
  };
  const homepage = "https://axios-http.com";
  const devDependencies = {
    coveralls: "^3.0.0",
    "es6-promise": "^4.2.4",
    grunt: "^1.3.0",
    "grunt-banner": "^0.6.0",
    "grunt-cli": "^1.2.0",
    "grunt-contrib-clean": "^1.1.0",
    "grunt-contrib-watch": "^1.0.0",
    "grunt-eslint": "^23.0.0",
    "grunt-karma": "^4.0.0",
    "grunt-mocha-test": "^0.13.3",
    "grunt-ts": "^6.0.0-beta.19",
    "grunt-webpack": "^4.0.2",
    "istanbul-instrumenter-loader": "^1.0.0",
    "jasmine-core": "^2.4.1",
    karma: "^6.3.2",
    "karma-chrome-launcher": "^3.1.0",
    "karma-firefox-launcher": "^2.1.0",
    "karma-jasmine": "^1.1.1",
    "karma-jasmine-ajax": "^0.1.13",
    "karma-safari-launcher": "^1.0.0",
    "karma-sauce-launcher": "^4.3.6",
    "karma-sinon": "^1.0.5",
    "karma-sourcemap-loader": "^0.3.8",
    "karma-webpack": "^4.0.2",
    "load-grunt-tasks": "^3.5.2",
    minimist: "^1.2.0",
    mocha: "^8.2.1",
    sinon: "^4.5.0",
    "terser-webpack-plugin": "^4.2.3",
    typescript: "^4.0.5",
    "url-search-params": "^0.10.0",
    webpack: "^4.44.2",
    "webpack-dev-server": "^3.11.0"
  };
  const browser = {
    "./lib/adapters/http.js": "./lib/adapters/xhr.js"
  };
  const jsdelivr = "dist/axios.min.js";
  const unpkg = "dist/axios.min.js";
  const typings = "./index.d.ts";
  const dependencies = {
    "follow-redirects": "^1.14.0"
  };
  const bundlesize = [
    {
      path: "./dist/axios.min.js",
      threshold: "5kB"
    }
  ];
  const require$$0 = {
    name,
    version,
    description,
    main,
    scripts,
    repository,
    keywords,
    author,
    license,
    bugs,
    homepage,
    devDependencies,
    browser,
    jsdelivr,
    unpkg,
    typings,
    dependencies,
    bundlesize
  };
  var pkg = require$$0;
  var validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
    validators$1[type] = function validator2(thing) {
      return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
    };
  });
  var deprecatedWarnings = {};
  var currentVerArr = pkg.version.split(".");
  function isOlderVersion(version2, thanVersion) {
    var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
    var destVer = version2.split(".");
    for (var i = 0; i < 3; i++) {
      if (pkgVersionArr[i] > destVer[i]) {
        return true;
      } else if (pkgVersionArr[i] < destVer[i]) {
        return false;
      }
    }
    return false;
  }
  validators$1.transitional = function transitional(validator2, version2, message) {
    var isDeprecated = version2 && isOlderVersion(version2);
    function formatMessage(opt, desc) {
      return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return function(value, opt, opts) {
      if (validator2 === false) {
        throw new Error(formatMessage(opt, " has been removed in " + version2));
      }
      if (isDeprecated && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new TypeError("options must be an object");
    }
    var keys = Object.keys(options);
    var i = keys.length;
    while (i-- > 0) {
      var opt = keys[i];
      var validator2 = schema[opt];
      if (validator2) {
        var value = options[opt];
        var result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new TypeError("option " + opt + " must be " + result);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw Error("Unknown option " + opt);
      }
    }
  }
  var validator$1 = {
    isOlderVersion,
    assertOptions,
    validators: validators$1
  };
  var utils$1 = utils$9;
  var buildURL = buildURL$1;
  var InterceptorManager = InterceptorManager_1;
  var dispatchRequest = dispatchRequest$1;
  var mergeConfig$1 = mergeConfig$2;
  var validator = validator$1;
  var validators = validator.validators;
  function Axios$1(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  Axios$1.prototype.request = function request(config) {
    if (typeof config === "string") {
      config = arguments[1] || {};
      config.url = arguments[0];
    } else {
      config = config || {};
    }
    config = mergeConfig$1(this.defaults, config);
    if (config.method) {
      config.method = config.method.toLowerCase();
    } else if (this.defaults.method) {
      config.method = this.defaults.method.toLowerCase();
    } else {
      config.method = "get";
    }
    var transitional = config.transitional;
    if (transitional !== void 0) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
        forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
        clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
      }, false);
    }
    var requestInterceptorChain = [];
    var synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    var responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    var promise;
    if (!synchronousRequestInterceptors) {
      var chain = [dispatchRequest, void 0];
      Array.prototype.unshift.apply(chain, requestInterceptorChain);
      chain = chain.concat(responseInterceptorChain);
      promise = Promise.resolve(config);
      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }
      return promise;
    }
    var newConfig = config;
    while (requestInterceptorChain.length) {
      var onFulfilled = requestInterceptorChain.shift();
      var onRejected = requestInterceptorChain.shift();
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected(error);
        break;
      }
    }
    try {
      promise = dispatchRequest(newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    while (responseInterceptorChain.length) {
      promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
    }
    return promise;
  };
  Axios$1.prototype.getUri = function getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
  };
  utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios$1.prototype[method] = function(url, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data: (config || {}).data
      }));
    };
  });
  utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    Axios$1.prototype[method] = function(url, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        url,
        data
      }));
    };
  });
  var Axios_1 = Axios$1;
  var Cancel_1;
  var hasRequiredCancel;
  function requireCancel() {
    if (hasRequiredCancel)
      return Cancel_1;
    hasRequiredCancel = 1;
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString2() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    Cancel_1 = Cancel;
    return Cancel_1;
  }
  var CancelToken_1;
  var hasRequiredCancelToken;
  function requireCancelToken() {
    if (hasRequiredCancelToken)
      return CancelToken_1;
    hasRequiredCancelToken = 1;
    var Cancel = requireCancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token2 = this;
      executor(function cancel(message) {
        if (token2.reason) {
          return;
        }
        token2.reason = new Cancel(message);
        resolvePromise(token2.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token2 = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token2,
        cancel
      };
    };
    CancelToken_1 = CancelToken;
    return CancelToken_1;
  }
  var spread;
  var hasRequiredSpread;
  function requireSpread() {
    if (hasRequiredSpread)
      return spread;
    hasRequiredSpread = 1;
    spread = function spread2(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
    return spread;
  }
  var isAxiosError;
  var hasRequiredIsAxiosError;
  function requireIsAxiosError() {
    if (hasRequiredIsAxiosError)
      return isAxiosError;
    hasRequiredIsAxiosError = 1;
    isAxiosError = function isAxiosError2(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
    return isAxiosError;
  }
  var utils = utils$9;
  var bind = bind$2;
  var Axios = Axios_1;
  var mergeConfig = mergeConfig$2;
  var defaults$1 = defaults_1;
  function createInstance(defaultConfig) {
    var context = new Axios(defaultConfig);
    var instance = bind(Axios.prototype.request, context);
    utils.extend(instance, Axios.prototype, context);
    utils.extend(instance, context);
    return instance;
  }
  var axios$3 = createInstance(defaults$1);
  axios$3.Axios = Axios;
  axios$3.create = function create(instanceConfig) {
    return createInstance(mergeConfig(axios$3.defaults, instanceConfig));
  };
  axios$3.Cancel = requireCancel();
  axios$3.CancelToken = requireCancelToken();
  axios$3.isCancel = requireIsCancel();
  axios$3.all = function all(promises) {
    return Promise.all(promises);
  };
  axios$3.spread = requireSpread();
  axios$3.isAxiosError = requireIsAxiosError();
  axios$4.exports = axios$3;
  axios$4.exports.default = axios$3;
  var axiosExports = axios$4.exports;
  var axios$1 = axiosExports;
  const axios$2 = /* @__PURE__ */ getDefaultExportFromCjs(axios$1);
  var queryString$2 = {};
  var strictUriEncode$1 = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
  var token$1 = "%[a-f0-9]{2}";
  var singleMatcher$1 = new RegExp("(" + token$1 + ")|([^%]+?)", "gi");
  var multiMatcher$1 = new RegExp("(" + token$1 + ")+", "gi");
  function decodeComponents$1(components, split) {
    try {
      return [decodeURIComponent(components.join(""))];
    } catch (err) {
    }
    if (components.length === 1) {
      return components;
    }
    split = split || 1;
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents$1(left), decodeComponents$1(right));
  }
  function decode$2(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher$1) || [];
      for (var i = 1; i < tokens.length; i++) {
        input = decodeComponents$1(tokens, i).join("");
        tokens = input.match(singleMatcher$1) || [];
      }
      return input;
    }
  }
  function customDecodeURIComponent$1(input) {
    var replaceMap = {
      "%FE%FF": "��",
      "%FF%FE": "��"
    };
    var match = multiMatcher$1.exec(input);
    while (match) {
      try {
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch (err) {
        var result = decode$2(match[0]);
        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }
      match = multiMatcher$1.exec(input);
    }
    replaceMap["%C2"] = "�";
    var entries = Object.keys(replaceMap);
    for (var i = 0; i < entries.length; i++) {
      var key = entries[i];
      input = input.replace(new RegExp(key, "g"), replaceMap[key]);
    }
    return input;
  }
  var decodeUriComponent$1 = function(encodedURI) {
    if (typeof encodedURI !== "string") {
      throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
    }
    try {
      encodedURI = encodedURI.replace(/\+/g, " ");
      return decodeURIComponent(encodedURI);
    } catch (err) {
      return customDecodeURIComponent$1(encodedURI);
    }
  };
  var splitOnFirst$1 = (string, separator) => {
    if (!(typeof string === "string" && typeof separator === "string")) {
      throw new TypeError("Expected the arguments to be of type `string`");
    }
    if (separator === "") {
      return [string];
    }
    const separatorIndex = string.indexOf(separator);
    if (separatorIndex === -1) {
      return [string];
    }
    return [
      string.slice(0, separatorIndex),
      string.slice(separatorIndex + separator.length)
    ];
  };
  var filterObj = function(obj, predicate) {
    var ret = {};
    var keys = Object.keys(obj);
    var isArr = Array.isArray(predicate);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var val = obj[key];
      if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
        ret[key] = val;
      }
    }
    return ret;
  };
  (function(exports2) {
    const strictUriEncode2 = strictUriEncode$1;
    const decodeComponent = decodeUriComponent$1;
    const splitOnFirst2 = splitOnFirst$1;
    const filterObject = filterObj;
    const isNullOrUndefined2 = (value) => value === null || value === void 0;
    function encoderForArrayFormat2(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key, options), "[", encode2(index, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[]"].join("")];
            }
            return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode2(key, options), "=", encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key, options)];
            }
            return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat2(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray2 && decode2(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode2(value, options) : value;
            const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator2(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode2(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode2(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter2(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter2(Object.keys(input)).sort((a2, b) => Number(a2) - Number(b)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash2(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash2(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract2(input) {
      input = removeHash2(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue2(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse2(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator2(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat2(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst2(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode2(value, options);
        formatter(decode2(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k of Object.keys(value)) {
            value[k] = parseValue2(value[k], options);
          }
        } else {
          ret[key] = parseValue2(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter2(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports2.extract = extract2;
    exports2.parse = parse2;
    exports2.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator2(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined2(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat2(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options) + "=" + encode2(value, options);
      }).filter((x) => x.length > 0).join("&");
    };
    exports2.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash] = splitOnFirst2(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse2(extract2(url), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode2(hash, options) } : {}
      );
    };
    exports2.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash2(object.url).split("?")[0] || "";
      const queryFromUrl = exports2.extract(object.url);
      const parsedQueryFromUrl = exports2.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString2 = exports2.stringify(query, options);
      if (queryString2) {
        queryString2 = `?${queryString2}`;
      }
      let hash = getHash2(object.url);
      if (object.fragmentIdentifier) {
        hash = `#${encode2(object.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString2}${hash}`;
    };
    exports2.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true
      }, options);
      const { url, query, fragmentIdentifier } = exports2.parseUrl(input, options);
      return exports2.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports2.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports2.pick(input, exclusionFilter, options);
    };
  })(queryString$2);
  const queryString$1 = /* @__PURE__ */ getDefaultExportFromCjs(queryString$2);
  var index_umd = { exports: {} };
  (function(module2, exports2) {
    (function(g, o) {
      o(exports2, require$$0$1);
    })(commonjsGlobal, function(g, o) {
      var mt = Object.defineProperty, gt = Object.defineProperties;
      var yt = Object.getOwnPropertyDescriptors;
      var V = Object.getOwnPropertySymbols;
      var Pt = Object.prototype.hasOwnProperty, Et = Object.prototype.propertyIsEnumerable;
      var x = (g2, o2, P2) => o2 in g2 ? mt(g2, o2, { enumerable: true, configurable: true, writable: true, value: P2 }) : g2[o2] = P2, v = (g2, o2) => {
        for (var P2 in o2 || (o2 = {}))
          Pt.call(o2, P2) && x(g2, P2, o2[P2]);
        if (V)
          for (var P2 of V(o2))
            Et.call(o2, P2) && x(g2, P2, o2[P2]);
        return g2;
      }, G = (g2, o2) => gt(g2, yt(o2));
      const P = {};
      var S = { methods: { registerNestable(t) {
        const e = this._getByGroup(t.group);
        e.onDragStartListeners.push(t.onDragStart), e.onMouseEnterListeners.push(t.onMouseEnter), e.onMouseMoveListeners.push(t.onMouseMove);
      }, notifyDragStart(t, e, s) {
        const u = this._getByGroup(t);
        for (const i of u.onDragStartListeners)
          i(e, s);
      }, notifyMouseEnter(t, e, s, u) {
        const i = this._getByGroup(t);
        for (const l of i.onMouseEnterListeners)
          l(e, s, u);
      }, notifyMouseMove(t, e) {
        const s = this._getByGroup(t);
        for (const u of s.onMouseMoveListeners)
          u(e);
      }, _getByGroup(t) {
        return P[t] || (P[t] = { onDragStartListeners: [], onMouseEnterListeners: [], onMouseMoveListeners: [], onDragStart: [], dragItem: null }), P[t];
      } } }, C = (t, e) => {
        const s = t.__vccOpts || t;
        for (const [u, i] of e)
          s[u] = i;
        return s;
      };
      const Y = { name: "NestableItem", mixins: [S], props: { item: { type: Object, required: true, default: () => ({}) }, index: { type: Number, required: false, default: null }, isChild: { type: Boolean, required: false, default: false }, isCopy: { type: Boolean, required: false, default: false }, options: { type: Object, required: true, default: () => ({}) } }, inject: ["listId", "group", "keyProp"], data() {
        return { breakPoint: null, moveDown: false };
      }, computed: { isDragging() {
        const t = this.options.dragItem;
        return !this.isCopy && t && t[this.options.keyProp] === this.item[this.options.keyProp];
      }, hasChildren() {
        return this.item[this.options.childrenProp] && this.item[this.options.childrenProp].length > 0;
      }, hasHandle() {
        return !!this.$scopedSlots.handler;
      }, normalizedClassProp() {
        const t = this.item[this.options.classProp];
        return t ? Array.isArray(t) ? t : typeof a == "object" ? [t] : [t] : [];
      }, itemClasses() {
        const t = this.isDragging ? ["is-dragging"] : [];
        return [`nestable-item${this.isCopy ? "-copy" : ""}`, `nestable-item${this.isCopy ? "-copy" : ""}-${this.item[this.options.keyProp]}`, ...t, ...this.normalizedClassProp];
      } }, methods: { onMouseEnter(t) {
        if (!!this.options.dragItem) {
          if (!t.movementY)
            return this.sendNotification(t);
          this.moveDown = t.movementY > 0, this.breakPoint = t.target.getBoundingClientRect().height / 2;
        }
      }, onMouseLeave() {
        this.breakPoint = null;
      }, onMouseMove(t) {
        if (!this.breakPoint)
          return;
        const e = t.offsetY - this.breakPoint;
        this.moveDown && e < this.breakPoint / 4 || !this.moveDown && e > -this.breakPoint / 4 || this.sendNotification(t);
      }, sendNotification(t) {
        this.breakPoint = null;
        const e = this.item || this.$parent.item;
        this.notifyMouseEnter(this.group, t, this.listId, e);
      } } }, O = { key: 0, class: "nestable-list" };
      function z(t, e, s, u, i, l) {
        const h = o.resolveComponent("NestableItem", true);
        return o.openBlock(), o.createElementBlock("li", { class: o.normalizeClass(l.itemClasses) }, [o.createElementVNode("div", { class: "nestable-item-content", onMouseenter: e[0] || (e[0] = (...m) => l.onMouseEnter && l.onMouseEnter(...m)), onMouseleave: e[1] || (e[1] = (...m) => l.onMouseLeave && l.onMouseLeave(...m)), onMousemove: e[2] || (e[2] = (...m) => l.onMouseMove && l.onMouseMove(...m)) }, [o.renderSlot(t.$slots, "default", { index: s.index, item: s.item, isChild: s.isChild })], 32), l.hasChildren ? (o.openBlock(), o.createElementBlock("ol", O, [(o.openBlock(true), o.createElementBlock(o.Fragment, null, o.renderList(s.item[s.options.childrenProp], (m, f) => (o.openBlock(), o.createBlock(h, { key: m[l.keyProp], item: m, index: f, options: s.options, "is-copy": s.isCopy, "is-child": "" }, { default: o.withCtx((E) => [o.renderSlot(t.$slots, "default", o.normalizeProps(o.guardReactiveProps(E)))]), _: 2 }, 1032, ["item", "index", "options", "is-copy"]))), 128))])) : o.createCommentVNode("", true)], 2);
      }
      var H = C(Y, [["render", z]]);
      const X = { name: "Placeholder", mixins: [S], props: { index: { type: Number, required: false, default: null }, options: { type: Object, required: false, default: () => ({}) } }, inject: ["listId", "group"], computed: { isDragging() {
        return this.options.dragItem;
      } }, methods: { onMouseEnter(t) {
        !this.options.dragItem || this.notifyMouseEnter(this.group, t, this.listId, null);
      } } };
      function F(t, e, s, u, i, l) {
        return o.openBlock(), o.createElementBlock("li", null, [o.createElementVNode("div", { class: "nestable-list-empty", onMouseenter: e[0] || (e[0] = (...h) => l.onMouseEnter && l.onMouseEnter(...h)) }, [o.renderSlot(t.$slots, "default")], 32)]);
      }
      var W = C(X, [["render", F]]), K = { methods: { getPathById(t, e = this.value) {
        let s = [];
        return e.every((u, i) => {
          if (u[this.keyProp] === t)
            s.push(i);
          else if (u[this.childrenProp]) {
            const l = this.getPathById(t, u[this.childrenProp]);
            l.length && (s = s.concat(i).concat(l));
          }
          return s.length === 0;
        }), s;
      }, getItemByPath(t, e = this.value) {
        let s = null;
        return t.forEach((u) => {
          s = (s && s[this.childrenProp] ? s[this.childrenProp] : e)[u];
        }), s;
      }, getItemDepth(t) {
        let e = 1;
        if (t[this.childrenProp] && t[this.childrenProp].length > 0) {
          const s = t[this.childrenProp].map(this.getItemDepth);
          e += Math.max(...s);
        }
        return e;
      }, getSplicePath(t, e = {}) {
        const s = {}, u = e.numToRemove || 0, i = e.itemsToInsert || [], l = t.length - 1;
        let h = s;
        return t.forEach((m, f) => {
          if (f === l)
            h.$splice = [[m, u, ...i]];
          else {
            const E = {};
            h[m] = { [e.childrenProp]: E }, h = E;
          }
        }), s;
      }, getRealNextPath(t, e) {
        const s = t.length - 1, u = e.length - 1;
        if (t.length < e.length) {
          let i = false;
          return e.map((l, h) => i ? h === u ? l + 1 : l : typeof t[h] != "number" ? l : e[h] > t[h] && h === s ? (i = true, l - 1) : l);
        } else if (t.length === e.length && e[u] > t[u]) {
          const i = this.getItemByPath(e);
          if (i[this.childrenProp] && i[this.childrenProp].length && !this.isCollapsed(i))
            return e.slice(0, -1).concat(e[u] - 1).concat(0);
        }
        return e;
      } } }, U = { methods: { hook(t, e) {
        if (!this.hooks[t])
          return true;
        const s = this.hooks[t](e);
        return s || s === void 0;
      } } };
      function J(t) {
        return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
      }
      var w = { exports: {} };
      (function(t, e) {
        Object.defineProperty(e, "__esModule", { value: true });
        function s(r) {
          return typeof r == "object" && !("toString" in r) ? Object.prototype.toString.call(r).slice(8, -1) : r;
        }
        var u = typeof process == "object" && true;
        function i(r, n) {
          if (!r)
            throw u ? new Error("Invariant failed") : new Error(n());
        }
        e.invariant = i;
        var l = Object.prototype.hasOwnProperty, h = Array.prototype.splice, m = Object.prototype.toString;
        function f(r) {
          return m.call(r).slice(8, -1);
        }
        var E = Object.assign || function(r, n) {
          return k(n).forEach(function(c) {
            l.call(n, c) && (r[c] = n[c]);
          }), r;
        }, k = typeof Object.getOwnPropertySymbols == "function" ? function(r) {
          return Object.keys(r).concat(Object.getOwnPropertySymbols(r));
        } : function(r) {
          return Object.keys(r);
        };
        function D(r) {
          return Array.isArray(r) ? E(r.constructor(r.length), r) : f(r) === "Map" ? new Map(r) : f(r) === "Set" ? new Set(r) : r && typeof r == "object" ? E(Object.create(Object.getPrototypeOf(r)), r) : r;
        }
        var L = function() {
          function r() {
            this.commands = E({}, lt), this.update = this.update.bind(this), this.update.extend = this.extend = this.extend.bind(this), this.update.isEquals = function(n, c) {
              return n === c;
            }, this.update.newContext = function() {
              return new r().update;
            };
          }
          return Object.defineProperty(r.prototype, "isEquals", { get: function() {
            return this.update.isEquals;
          }, set: function(n) {
            this.update.isEquals = n;
          }, enumerable: true, configurable: true }), r.prototype.extend = function(n, c) {
            this.commands[n] = c;
          }, r.prototype.update = function(n, c) {
            var p = this, d = typeof c == "function" ? { $apply: c } : c;
            Array.isArray(n) && Array.isArray(d) || i(!Array.isArray(d), function() {
              return "update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value.";
            }), i(typeof d == "object" && d !== null, function() {
              return "update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the " + ("following commands: " + Object.keys(p.commands).join(", ") + ".");
            });
            var y = n;
            return k(d).forEach(function(M) {
              if (l.call(p.commands, M)) {
                var pt = n === y;
                y = p.commands[M](d[M], y, d, n), pt && p.isEquals(y, n) && (y = n);
              } else {
                var B = f(n) === "Map" ? p.update(n.get(M), d[M]) : p.update(n[M], d[M]), ft = f(y) === "Map" ? y.get(M) : y[M];
                (!p.isEquals(B, ft) || typeof B == "undefined" && !l.call(n, M)) && (y === n && (y = D(n)), f(y) === "Map" ? y.set(M, B) : y[M] = B);
              }
            }), y;
          }, r;
        }();
        e.Context = L;
        var lt = { $push: function(r, n, c) {
          return q(n, c, "$push"), r.length ? n.concat(r) : n;
        }, $unshift: function(r, n, c) {
          return q(n, c, "$unshift"), r.length ? r.concat(n) : n;
        }, $splice: function(r, n, c, p) {
          return ut(n, c), r.forEach(function(d) {
            A(d), n === p && d.length && (n = D(p)), h.apply(n, d);
          }), n;
        }, $set: function(r, n, c) {
          return ct(c), r;
        }, $toggle: function(r, n) {
          I(r, "$toggle");
          var c = r.length ? D(n) : n;
          return r.forEach(function(p) {
            c[p] = !n[p];
          }), c;
        }, $unset: function(r, n, c, p) {
          return I(r, "$unset"), r.forEach(function(d) {
            Object.hasOwnProperty.call(n, d) && (n === p && (n = D(p)), delete n[d]);
          }), n;
        }, $add: function(r, n, c, p) {
          return R(n, "$add"), I(r, "$add"), f(n) === "Map" ? r.forEach(function(d) {
            var y = d[0], M = d[1];
            n === p && n.get(y) !== M && (n = D(p)), n.set(y, M);
          }) : r.forEach(function(d) {
            n === p && !n.has(d) && (n = D(p)), n.add(d);
          }), n;
        }, $remove: function(r, n, c, p) {
          return R(n, "$remove"), I(r, "$remove"), r.forEach(function(d) {
            n === p && n.has(d) && (n = D(p)), n.delete(d);
          }), n;
        }, $merge: function(r, n, c, p) {
          return dt(n, r), k(r).forEach(function(d) {
            r[d] !== n[d] && (n === p && (n = D(p)), n[d] = r[d]);
          }), n;
        }, $apply: function(r, n) {
          return ht(r), r(n);
        } }, _2 = new L();
        e.isEquals = _2.update.isEquals, e.extend = _2.extend, e.default = _2.update, e.default.default = t.exports = E(e.default, e);
        function q(r, n, c) {
          i(Array.isArray(r), function() {
            return "update(): expected target of " + s(c) + " to be an array; got " + s(r) + ".";
          }), I(n[c], c);
        }
        function I(r, n) {
          i(Array.isArray(r), function() {
            return "update(): expected spec of " + s(n) + " to be an array; got " + s(r) + ". Did you forget to wrap your parameter in an array?";
          });
        }
        function ut(r, n) {
          i(Array.isArray(r), function() {
            return "Expected $splice target to be an array; got " + s(r);
          }), A(n.$splice);
        }
        function A(r) {
          i(Array.isArray(r), function() {
            return "update(): expected spec of $splice to be an array of arrays; got " + s(r) + ". Did you forget to wrap your parameters in an array?";
          });
        }
        function ht(r) {
          i(typeof r == "function", function() {
            return "update(): expected spec of $apply to be a function; got " + s(r) + ".";
          });
        }
        function ct(r) {
          i(Object.keys(r).length === 1, function() {
            return "Cannot have more than one key in an object with $set";
          });
        }
        function dt(r, n) {
          i(n && typeof n == "object", function() {
            return "update(): $merge expects a spec of type 'object'; got " + s(n);
          }), i(r && typeof r == "object", function() {
            return "update(): $merge expects a target of type 'object'; got " + s(r);
          });
        }
        function R(r, n) {
          var c = f(r);
          i(c === "Map" || c === "Set", function() {
            return "update(): " + s(n) + " expects a target of type Set or Map; got " + s(c);
          });
        }
      })(w, w.exports);
      var b = J(w.exports);
      const Q = (t, e) => {
        var s;
        try {
          let u = t.closest(e);
        } catch {
          s = t;
        }
        return s;
      }, Z = (t) => {
        var e = t.getBoundingClientRect();
        return { top: Math.round(e.top), left: Math.round(e.left) };
      }, j = (t, e) => ({ transform: "translate(" + t + "px, " + e + "px)" }), N = (t, e) => t.map((s) => G(v({}, s), { [e]: s[e] ? N(s[e], e) : [] })), tt = { name: "VueNestable", components: { NestableItem: H, Placeholder: W }, mixins: [K, S, U], props: { value: { type: Array, required: true, default: () => [] }, threshold: { type: Number, required: false, default: 30 }, maxDepth: { type: Number, required: false, default: 10 }, keyProp: { type: String, required: false, default: "id" }, classProp: { type: String, required: false, default: null }, group: { type: [String, Number], required: false, default: () => Math.random().toString(36).slice(2) }, childrenProp: { type: String, required: false, default: "children" }, collapsed: { type: Boolean, required: false, default: false }, hooks: { type: Object, required: false, default: () => ({}) }, rtl: { type: Boolean, required: false, default: false } }, provide() {
        return { listId: this.listId, group: this.group, keyProp: this.keyProp, onDragEnd: this.onDragEnd };
      }, data() {
        return { itemsOld: null, dragItem: null, mouse: { last: { x: 0 }, shift: { x: 0 } }, el: null, elCopyStyles: null, isDirty: false, collapsedGroups: [], listId: Math.random().toString(36).slice(2) };
      }, computed: { listIsEmpty() {
        return this.value.length === 0;
      }, itemOptions() {
        return { dragItem: this.dragItem, keyProp: this.keyProp, classProp: this.classProp, childrenProp: this.childrenProp };
      }, listStyles() {
        const t = document.querySelector(".nestable-" + this.group + " .nestable-item-" + this.dragItem[this.keyProp]);
        let e = {};
        return t && (e.width = `${t.clientWidth}px`), this.elCopyStyles && (e = v(v({}, e), this.elCopyStyles)), e;
      } }, created() {
        const t = N(this.value, this.childrenProp);
        this.$emit("input", t), this.isDirty = false, this.registerNestable(this);
      }, beforeDestroy() {
        this.stopTrackMouse();
      }, methods: { startTrackMouse() {
        document.addEventListener("mousemove", this.onMouseMove), document.addEventListener("mouseup", this.onDragEnd), document.addEventListener("touchend", this.onDragEnd), document.addEventListener("touchcancel", this.onDragEnd), document.addEventListener("keydown", this.onKeyDown);
      }, stopTrackMouse() {
        document.removeEventListener("mousemove", this.onMouseMove), document.removeEventListener("mouseup", this.onDragEnd), document.removeEventListener("touchend", this.onDragEnd), document.removeEventListener("touchcancel", this.onDragEnd), document.removeEventListener("keydown", this.onKeyDown), this.elCopyStyles = null;
      }, onDragStart(t, e) {
        t && (t.preventDefault(), t.stopPropagation()), this.el = Q(t.target, ".nestable-item"), this.startTrackMouse(), this.dragItem = e, this.itemsOld = this.value, this.$nextTick(() => {
          this.onMouseMove(t);
        });
      }, onDragEnd(t, e) {
        t && t.preventDefault(), this.stopTrackMouse(), this.el = null, e ? this.dragRevert() : this.dragApply();
      }, onKeyDown(t) {
        t.which === 27 && this.onDragEnd(null, true);
      }, getXandYFromEvent(t) {
        let { clientX: e, clientY: s } = t;
        const { targetTouches: u } = t;
        if (u) {
          const i = u[0];
          e = i.clientX, s = i.clientY;
          const l = new Event("mouseenter"), h = document.elementFromPoint(e, s), m = h && (h.closest(".nestable-item-content") || h.closest(".nestable-list-empty"));
          m && m.dispatchEvent(l);
        }
        return { clientX: e, clientY: s };
      }, onMouseMove(t) {
        t && t.preventDefault();
        const { clientX: e, clientY: s } = this.getXandYFromEvent(t);
        this.mouse.last.x === 0 && (this.mouse.last.x = e);
        const u = j(e, s), i = document.querySelector(".nestable-" + this.group + " .nestable-drag-layer");
        if (!i)
          return;
        const { top: l, left: h } = i.getBoundingClientRect(), m = document.querySelector(".nestable-" + this.group + " .nestable-drag-layer > .nestable-list");
        if (this.elCopyStyles) {
          if (this.elCopyStyles = v(v({}, this.elCopyStyles), u), m)
            for (const E in u)
              Object.prototype.hasOwnProperty.call(u, E) && (m.style[E] = u[E]);
          const f = this.rtl ? this.mouse.last.x - e : e - this.mouse.last.x;
          f >= 0 && this.mouse.shift.x >= 0 || f <= 0 && this.mouse.shift.x <= 0 ? this.mouse.shift.x += f : this.mouse.shift.x = 0, this.mouse.last.x = e, Math.abs(this.mouse.shift.x) > this.threshold && (this.mouse.shift.x > 0 ? this.tryIncreaseDepth(this.dragItem) : this.tryDecreaseDepth(this.dragItem), this.mouse.shift.x = 0);
        } else {
          const f = Z(this.el);
          this.elCopyStyles = v({ marginTop: `${f.top - s - l}px`, marginLeft: `${f.left - e - h}px` }, u);
        }
      }, moveItem({ dragItem: t, pathFrom: e, pathTo: s }) {
        const u = this.getRealNextPath(e, s), i = this.getSplicePath(e, { numToRemove: 1, childrenProp: this.childrenProp }), l = this.getSplicePath(u, { numToRemove: 0, itemsToInsert: [t], childrenProp: this.childrenProp });
        if (!this.hook("beforeMove", { dragItem: t, pathFrom: e, pathTo: u }))
          return;
        let h = this.value;
        h = b(h, i), h = b(h, l), this.isDirty = true, this.pathTo = u, this.$emit("input", h);
      }, tryIncreaseDepth(t) {
        const e = this.getPathById(t[this.keyProp]), s = e[e.length - 1], u = e.length + this.getItemDepth(t);
        if (s > 0 && u <= this.maxDepth) {
          const i = this.getItemByPath(e.slice(0, -1).concat(s - 1));
          if (i[this.childrenProp] && (!i[this.childrenProp].length || !this.isCollapsed(i))) {
            const l = e.slice(0, -1).concat(s - 1).concat(i[this.childrenProp].length);
            this.moveItem({ dragItem: t, pathFrom: e, pathTo: l });
          }
        }
      }, tryDecreaseDepth(t) {
        const e = this.getPathById(t[this.keyProp]), s = e[e.length - 1];
        if (e.length > 1) {
          const u = this.getItemByPath(e.slice(0, -1));
          if (s + 1 === u[this.childrenProp].length) {
            const i = e.slice(0, -1);
            i[i.length - 1] += 1, this.moveItem({ dragItem: t, pathFrom: e, pathTo: i });
          }
        }
      }, onMouseEnter(t, e, s) {
        t && (t.preventDefault(), t.stopPropagation());
        const u = this.dragItem;
        if (!u || s !== null && u[this.keyProp] === s[this.keyProp])
          return;
        const i = this.getPathById(u[this.keyProp]);
        if (e !== this.listId && i.length === 0)
          return;
        let l;
        if (s === null ? l = i.length > 0 ? [] : [0] : l = this.getPathById(s[this.keyProp]), this.getRealNextPath(i, l).length + (this.getItemDepth(u) - 1) > this.maxDepth)
          return;
        let m = {};
        if (this.collapsed && i.length > 1) {
          const f = this.getItemByPath(i.slice(0, -1));
          f[this.childrenProp].length === 1 && (m = this.onToggleCollapse(f, true));
        }
        this.moveItem({ dragItem: u, pathFrom: i, pathTo: l }, m);
      }, isCollapsed(t) {
        return !!(this.collapsedGroups.indexOf(t[this.keyProp]) > -1 ^ this.collapsed);
      }, dragApply() {
        this.$emit("change", this.dragItem, { items: this.value, pathTo: this.pathTo }), this.pathTo = null, this.itemsOld = null, this.dragItem = null, this.isDirty = false;
      }, dragRevert() {
        this.$emit("input", this.itemsOld), this.pathTo = null, this.itemsOld = null, this.dragItem = null, this.isDirty = false;
      } } }, et = { class: "nestable-list nestable-group" }, rt = o.createTextVNode(" No content "), nt = { key: 0, class: "nestable-drag-layer" };
      function st(t, e, s, u, i, l) {
        const h = o.resolveComponent("Placeholder"), m = o.resolveComponent("NestableItem");
        return o.openBlock(), o.createElementBlock("div", { class: o.normalizeClass(["nestable", `nestable-${s.group}`, s.rtl ? "nestable-rtl" : ""]) }, [o.createElementVNode("ol", et, [l.listIsEmpty ? (o.openBlock(), o.createBlock(h, { key: 0, options: l.itemOptions }, { default: o.withCtx(() => [o.renderSlot(t.$slots, "placeholder", {}, () => [rt])]), _: 3 }, 8, ["options"])) : o.createCommentVNode("", true), (o.openBlock(true), o.createElementBlock(o.Fragment, null, o.renderList(s.value, (f, E) => (o.openBlock(), o.createBlock(m, { key: f[s.keyProp], index: E, item: f, options: l.itemOptions }, { default: o.withCtx((k) => [o.renderSlot(t.$slots, "default", o.normalizeProps(o.guardReactiveProps(k)))]), _: 2 }, 1032, ["index", "item", "options"]))), 128))]), i.dragItem ? (o.openBlock(), o.createElementBlock("div", nt, [o.createElementVNode("ol", { style: o.normalizeStyle(l.listStyles), class: "nestable-list" }, [o.createVNode(m, { item: i.dragItem, options: l.itemOptions, "is-copy": true }, { default: o.withCtx((f) => [o.renderSlot(t.$slots, "default", o.normalizeProps(o.guardReactiveProps(f)))]), _: 3 }, 8, ["item", "options"])], 4)])) : o.createCommentVNode("", true)], 2);
      }
      var T = C(tt, [["render", st]]);
      const ot = { name: "VueNestableHandle", mixins: [S], props: { item: { type: Object, required: false, default: () => ({}) } }, inject: ["group", "onDragEnd"], methods: { isEmpty(t) {
        if (t == null)
          return true;
        if (t.length > 0)
          return false;
        if (t.length === 0)
          return true;
        for (var e in t)
          if (hasOwnProperty.call(t, e))
            return false;
        return true;
      }, dragstart(t) {
        const e = this.isEmpty(this.item) ? this.$parent.item : this.item;
        this.notifyDragStart(this.group, t, e);
      }, touchend(t) {
        console.log(t), this.onDragEnd(t);
      }, touchmove(t) {
        console.log(t), this.notifyMouseMove(this.group, t);
      } } };
      function it(t, e, s, u, i, l) {
        return o.openBlock(), o.createElementBlock("div", { draggable: "true", class: "nestable-handle", onDragstart: e[0] || (e[0] = (...h) => l.dragstart && l.dragstart(...h)), onTouchstart: e[1] || (e[1] = (...h) => l.dragstart && l.dragstart(...h)), onTouchend: e[2] || (e[2] = (...h) => l.touchend && l.touchend(...h)), onTouchmove: e[3] || (e[3] = (...h) => l.touchmove && l.touchmove(...h)) }, [o.renderSlot(t.$slots, "default")], 32);
      }
      var $ = C(ot, [["render", it]]), at = { install: function(t) {
        t.component("VueNestable", T), t.component("VueNestableHandle", $);
      } };
      g.VueNestable = T, g.VueNestableHandle = $, g.default = at, Object.defineProperties(g, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    });
  })(index_umd, index_umd.exports);
  var index_umdExports = index_umd.exports;
  const _sfc_main$t = {
    name: "ui-table",
    components: {
      VueNestable: index_umdExports.VueNestable,
      VueNestableHandle: index_umdExports.VueNestableHandle
    },
    props: {
      id: {
        required: true,
        type: String
      },
      bulk: {
        type: Boolean,
        default: true
      },
      refresh: {
        type: [Number, Boolean],
        default: false
      },
      noRecords: {
        type: String,
        default: "No records to display"
      },
      endpoint: {
        required: true,
        type: String
      },
      sortBy: {
        type: String,
        default: "id"
      },
      saveSortBy: {
        type: Boolean,
        default: true
      },
      perPage: {
        type: Number,
        default: 10
      },
      sortIn: {
        type: String,
        default: "asc"
      },
      noSearch: {
        type: Boolean,
        default: false
      },
      primaryKey: {
        required: false,
        type: String,
        default: "id"
      },
      showPageStatus: {
        type: Boolean,
        default: false
      },
      showPageNumbers: {
        type: Boolean,
        default: false
      },
      showPageNav: {
        type: Boolean,
        default: false
      },
      showPageEnds: {
        type: Boolean,
        default: false
      },
      hidePageSelect: {
        type: Boolean,
        default: false
      },
      pageSelectLabel: {
        type: String,
        default: "Page"
      },
      reorder_route: {
        type: String,
        default: ""
      },
      link_name: {
        type: String,
        default: ""
      },
      link_param: {
        type: String,
        default: ""
      },
      show_status: {
        type: Boolean,
        default: false
      },
      show_order: {
        type: Boolean,
        default: true
      }
    },
    data() {
      return {
        action: null,
        showBulkActionConfirmation: false,
        initialLoad: true,
        loading: true,
        working: false,
        displayable: [],
        column_names: [],
        column_types: [],
        bulk_actions: [],
        bulk_actions_exempt: [],
        sortable: [],
        records: [],
        search: "",
        pagination: {
          totalRecords: 0,
          currentPage: 1,
          totalPages: 0,
          perPage: this.perPage,
          perPageOptions: [
            10,
            50,
            100,
            250
          ]
        },
        sort: {
          key: this.sortBy,
          order: this.sortIn
        },
        selected: [],
        order: "Order"
      };
    },
    computed: {
      columns() {
        return _$2.map(this.displayable, (option) => {
          columns.push({
            "label": this.column_names[option],
            "value": option
          });
        });
      },
      hasActions() {
        return !!this.$slots.actions;
      },
      hasBulkActions() {
        console.log(this.bulk, this.selectable.length, this.allowedBulkActions.length);
        if (!this.bulk)
          return false;
        if (!this.selectable.length > 0)
          return false;
        if (!this.allowedBulkActions.length > 0)
          return false;
        return true;
      },
      hasSelections() {
        return this.selected.length > 0;
      },
      selectable() {
        let vm2 = this;
        return _$2.filter(this.records, (record) => {
          return !vm2.bulk_actions_exempt.includes(record[vm2.primaryKey]);
        });
      },
      allowedBulkActions() {
        let vm2 = this;
        return _$2.filter(this.bulk_actions, (action) => {
          if (!action.permission)
            return true;
          return vm2.$can(action.permission);
        });
      }
    },
    watch: {
      endpoint() {
        this.getRecords();
      },
      showBulkActionConfirmation(value) {
        if (value == false) {
          this.action = null;
        }
      },
      search: _$2.debounce(function(value) {
        this.pagination.currentPage = 1;
        this.getRecords();
      }, 300)
    },
    methods: {
      toggleOrder() {
        if (this.order === "Order") {
          this.order = "Save";
          this.changePerPage(this.pagination.totalRecords + 1);
        } else {
          this.endpoint.split("/").at(-1);
          this.loading = true;
          axios$2.post(this.reorder_route, { records: this.records }).then((response) => {
            toast("Entries successfully saved.", "success");
            this.loading = false;
            this.changePerPage(10);
          }).catch((response) => {
            toast(response.message, "failed");
            this.loading = false;
            this.changePerPage(10);
          });
          this.order = "Order";
        }
      },
      cancelBulkAction() {
        this.showBulkActionConfirmation = false;
        this.action = null;
      },
      confirmBulkAction() {
        let vm2 = this;
        this.working = true;
        axios$2.post(`${this.bulk_actions[this.action].route}`, {
          records: this.selected
        }).then((response) => {
          toast("Bulk action completed successfully.", "success");
          vm2.getRecords();
          vm2.showBulkActionConfirmation = false;
          vm2.selected = [];
          vm2.action = null;
          vm2.working = false;
        });
      },
      isSelectable(id) {
        return !this.bulk_actions_exempt.includes(id);
      },
      toggleSelectAll() {
        if (this.selected.length > 0) {
          this.selected = [];
          return;
        }
        this.selected = _$2.map(this.selectable, "id");
      },
      getRecords() {
        this.loading = true;
        return axios$2.get(`${this.endpoint}?${this.getQueryParameters()}`).then((response) => {
          this.records = response.data.records.data;
          this.displayable = response.data.displayable;
          this.sortable = response.data.sortable;
          this.column_names = response.data.column_names;
          this.column_types = response.data.column_types;
          this.bulk_actions = response.data.bulk_actions;
          this.bulk_actions_exempt = response.data.bulk_actions_exempt;
          this.pagination.totalRecords = response.data.records.total;
          this.pagination.totalPages = response.data.records.last_page;
          this.loading = false;
          this.initialLoad = false;
          if (this.refresh && !self._timer) {
            this._timer = setTimeout(() => this.getRecords(), this.refresh);
          }
          this.$emit("loaded", this.records);
        });
      },
      isSortable(column) {
        return _$2.includes(this.sortable, column);
      },
      getQueryParameters() {
        let params = {
          sort: (this.sort.order === "desc" ? "-" : "") + this.sort.key,
          page: this.pagination.currentPage,
          perPage: this.pagination.perPage
        };
        if (this.search !== "") {
          params["filter[search]"] = this.search;
        }
        return queryString$1.stringify(params);
      },
      sortRecordsBy(column, order = false) {
        this.sort.key = column;
        if (!order) {
          this.sort.order = this.sort.order === "asc" ? "desc" : "asc";
        } else {
          this.sort.order = order;
        }
        this.getRecords();
        this.saveSortProperty();
      },
      saveSortProperty() {
        if (this.saveSortBy) {
          window.localStorage.setItem("ui-table-sort-" + this.id + "-" + this.endpoint + "-" + window.location.pathname, JSON.stringify(this.sort));
        }
      },
      loadSortProperty() {
        try {
          let sort = window.localStorage.getItem("ui-table-sort-" + this.id + "-" + this.endpoint + "-" + window.location.pathname);
          if (sort) {
            sort = JSON.parse(sort);
            this.sort = sort;
          }
        } catch (error) {
        }
      },
      changePage(page) {
        this.pagination.currentPage = page;
        this.getRecords();
      },
      changePerPage(page) {
        this.pagination.currentPage = 1;
        this.pagination.perPage = page;
        this.getRecords();
      },
      destroy(id) {
        axios$2.delete(`${this.endpoint}/${id}`).then(() => {
          this.getRecords();
        });
      },
      listenForEvents() {
        bus().$on("refresh-datatable-" + this.id, (data) => {
          this.getRecords();
        });
      },
      isComponentExist(componentName) {
        return componentName in this.$options.components;
      }
    },
    created() {
      this.loadSortProperty();
      this.getRecords();
      this.listenForEvents();
    },
    destroyed() {
      clearTimeout(this._timer);
    }
  };
  const _hoisted_1$h = /* @__PURE__ */ require$$0$1.createElementVNode("span", { class: "sr-only-mobile" }, "View", -1);
  const _hoisted_2$7 = /* @__PURE__ */ require$$0$1.createElementVNode("p", null, "Results per page:", -1);
  const _hoisted_3$4 = { class: "flex justify-between w-full items-center" };
  const _hoisted_4$2 = /* @__PURE__ */ require$$0$1.createElementVNode("span", { class: "sr-only-mobile" }, "Sort", -1);
  const _hoisted_5$2 = /* @__PURE__ */ require$$0$1.createElementVNode("p", null, "Sort by:", -1);
  const _hoisted_6$2 = { class: "flex justify-between w-full items-center" };
  const _hoisted_7$2 = { class: "flex justify-between w-full items-center" };
  const _hoisted_8$1 = /* @__PURE__ */ require$$0$1.createElementVNode("span", null, "Ascending", -1);
  const _hoisted_9$1 = { class: "flex justify-between w-full items-center" };
  const _hoisted_10 = /* @__PURE__ */ require$$0$1.createElementVNode("span", null, "Descending", -1);
  const _hoisted_11 = { class: "pb-2" };
  const _hoisted_12 = ["id"];
  const _hoisted_13 = {
    key: 0,
    width: "50px"
  };
  const _hoisted_14 = { class: "table__select-all" };
  const _hoisted_15 = ["onClick", "aria-label"];
  const _hoisted_16 = {
    key: 0,
    class: "inline",
    "aria-hidden": "true"
  };
  const _hoisted_17 = {
    key: 1,
    class: "table__heading"
  };
  const _hoisted_18 = ["colspan"];
  const _hoisted_19 = { class: "table__heading flex" };
  const _hoisted_20 = { class: "ml-auto" };
  const _hoisted_21 = /* @__PURE__ */ require$$0$1.createElementVNode("option", {
    selected: "",
    disabled: "",
    value: null
  }, "Bulk Actions", -1);
  const _hoisted_22 = ["value"];
  const _hoisted_23 = { class: "w-20 col-actions" };
  const _hoisted_24 = { key: 0 };
  const _hoisted_25 = { class: "flex flex-1" };
  const _hoisted_26 = { class: "column-label" };
  const _hoisted_27 = { key: 1 };
  const _hoisted_28 = {
    key: 1,
    class: "'table__actions w-20 col-actions'"
  };
  const _hoisted_29 = { class: "mb-4 xl:mb-6" };
  const _hoisted_30 = { class: "flex" };
  const _hoisted_31 = { class: "flex flex-1 items-center justify-between" };
  const _hoisted_32 = {
    key: 2,
    class: "pagination-group"
  };
  const _hoisted_33 = {
    key: 0,
    class: "pagination-group__item"
  };
  const _hoisted_34 = {
    key: 1,
    class: "pagination-group__item"
  };
  const _hoisted_35 = {
    key: 2,
    class: "pagination-group__item"
  };
  const _hoisted_36 = {
    key: 3,
    class: "no-bottom text-heading--md mb-0"
  };
  const _hoisted_37 = /* @__PURE__ */ require$$0$1.createElementVNode("p", null, "No results found.", -1);
  function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ui_label = require$$0$1.resolveComponent("ui-label");
    const _component_ui_input = require$$0$1.resolveComponent("ui-input");
    const _component_ui_toolbar_group = require$$0$1.resolveComponent("ui-toolbar-group");
    const _component_fa_icon = require$$0$1.resolveComponent("fa-icon");
    const _component_ui_dropdown_item = require$$0$1.resolveComponent("ui-dropdown-item");
    const _component_ui_dropdown_divider = require$$0$1.resolveComponent("ui-dropdown-divider");
    const _component_ui_dropdown_link = require$$0$1.resolveComponent("ui-dropdown-link");
    const _component_ui_dropdown = require$$0$1.resolveComponent("ui-dropdown");
    const _component_ui_button = require$$0$1.resolveComponent("ui-button");
    const _component_ui_toolbar = require$$0$1.resolveComponent("ui-toolbar");
    const _component_ui_checkbox = require$$0$1.resolveComponent("ui-checkbox");
    const _component_ui_modal = require$$0$1.resolveComponent("ui-modal");
    const _component_portal = require$$0$1.resolveComponent("portal");
    const _component_VueNestableHandle = require$$0$1.resolveComponent("VueNestableHandle");
    const _component_ui_status = require$$0$1.resolveComponent("ui-status");
    const _component_router_link = require$$0$1.resolveComponent("router-link");
    const _component_VueNestable = require$$0$1.resolveComponent("VueNestable");
    const _component_ui_pagination_status = require$$0$1.resolveComponent("ui-pagination-status");
    const _component_ui_pagination = require$$0$1.resolveComponent("ui-pagination");
    const _component_ui_pagination_select = require$$0$1.resolveComponent("ui-pagination-select");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      !$props.noSearch ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_toolbar, { key: 0 }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.renderSlot(_ctx.$slots, "toolbarPrepend"),
          require$$0$1.createVNode(_component_ui_toolbar_group, { grow: "" }, {
            default: require$$0$1.withCtx(() => [
              require$$0$1.createVNode(_component_ui_label, {
                fieldId: $props.id + "-table-search",
                hideLabel: ""
              }, {
                default: require$$0$1.withCtx(() => [
                  require$$0$1.createTextVNode("Search")
                ], void 0, true),
                _: 1
              }, 8, ["fieldId"]),
              require$$0$1.createVNode(_component_ui_input, {
                id: $props.id + "-table-search",
                name: "search",
                type: "search",
                placeholder: "Search",
                autocomplete: "off",
                "aria-controls": $props.id,
                modelValue: $data.search,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.search = $event)
              }, null, 8, ["id", "aria-controls", "modelValue"])
            ], void 0, true),
            _: 1
          }),
          require$$0$1.createVNode(_component_ui_toolbar_group, null, {
            default: require$$0$1.withCtx(() => [
              require$$0$1.createVNode(_component_ui_dropdown, {
                disabled: $data.order === "Save",
                noArrow: "",
                id: "per-page-options",
                right: ""
              }, {
                menu: require$$0$1.withCtx(() => [
                  require$$0$1.createVNode(_component_ui_dropdown_item, null, {
                    default: require$$0$1.withCtx(() => [
                      _hoisted_2$7
                    ], void 0, true),
                    _: 1
                  }),
                  require$$0$1.createVNode(_component_ui_dropdown_divider),
                  (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($data.pagination.perPageOptions, (pages, index) => {
                    return require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_dropdown_link, {
                      onClick: require$$0$1.withModifiers(($event) => $options.changePerPage(pages), ["prevent"]),
                      key: index
                    }, {
                      default: require$$0$1.withCtx(() => [
                        require$$0$1.createElementVNode("div", _hoisted_3$4, [
                          require$$0$1.createElementVNode("span", null, require$$0$1.toDisplayString(pages), 1),
                          pages === $data.pagination.perPage ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_fa_icon, {
                            key: 0,
                            class: "icon",
                            icon: "check"
                          })) : require$$0$1.createCommentVNode("", true)
                        ])
                      ], void 0, true),
                      _: 2
                    }, 1032, ["onClick"]);
                  }), 128))
                ]),
                default: require$$0$1.withCtx(() => [
                  require$$0$1.createVNode(_component_fa_icon, { icon: "list" }),
                  _hoisted_1$h
                ], void 0, true),
                _: 1
              }, 8, ["disabled"])
            ], void 0, true),
            _: 1
          }),
          require$$0$1.createVNode(_component_ui_toolbar_group, null, {
            default: require$$0$1.withCtx(() => [
              require$$0$1.createVNode(_component_ui_dropdown, {
                noArrow: "",
                id: "sorting-options",
                right: ""
              }, {
                menu: require$$0$1.withCtx(() => [
                  require$$0$1.createVNode(_component_ui_dropdown_item, null, {
                    default: require$$0$1.withCtx(() => [
                      _hoisted_5$2
                    ], void 0, true),
                    _: 1
                  }),
                  require$$0$1.createVNode(_component_ui_dropdown_divider),
                  (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($data.sortable, (column, index) => {
                    return require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_dropdown_link, {
                      key: column + "-sort" || index + "-sort",
                      onClick: require$$0$1.withModifiers(($event) => $options.sortRecordsBy(column, $data.sort.order), ["prevent"])
                    }, {
                      default: require$$0$1.withCtx(() => [
                        require$$0$1.createElementVNode("div", _hoisted_6$2, [
                          require$$0$1.createElementVNode("span", null, require$$0$1.toDisplayString($data.column_names[column] || column), 1),
                          $data.sort.key === column ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_fa_icon, {
                            key: 0,
                            class: "icon",
                            icon: "check"
                          })) : require$$0$1.createCommentVNode("", true)
                        ])
                      ], void 0, true),
                      _: 2
                    }, 1032, ["onClick"]);
                  }), 128)),
                  require$$0$1.createVNode(_component_ui_dropdown_divider),
                  require$$0$1.createVNode(_component_ui_dropdown_link, {
                    onClick: _cache[1] || (_cache[1] = require$$0$1.withModifiers(($event) => $options.sortRecordsBy($data.sort.key, "asc"), ["prevent"]))
                  }, {
                    default: require$$0$1.withCtx(() => [
                      require$$0$1.createElementVNode("div", _hoisted_7$2, [
                        _hoisted_8$1,
                        $data.sort.order === "asc" ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_fa_icon, {
                          key: 0,
                          class: "icon",
                          icon: "check"
                        })) : require$$0$1.createCommentVNode("", true)
                      ])
                    ], void 0, true),
                    _: 1
                  }),
                  require$$0$1.createVNode(_component_ui_dropdown_link, {
                    onClick: _cache[2] || (_cache[2] = require$$0$1.withModifiers(($event) => $options.sortRecordsBy($data.sort.key, "desc"), ["prevent"]))
                  }, {
                    default: require$$0$1.withCtx(() => [
                      require$$0$1.createElementVNode("div", _hoisted_9$1, [
                        _hoisted_10,
                        $data.sort.order === "desc" ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_fa_icon, {
                          key: 0,
                          class: "icon",
                          icon: "check"
                        })) : require$$0$1.createCommentVNode("", true)
                      ])
                    ], void 0, true),
                    _: 1
                  })
                ]),
                default: require$$0$1.withCtx(() => [
                  require$$0$1.createVNode(_component_fa_icon, { icon: "sort-amount-down" }),
                  _hoisted_4$2
                ], void 0, true),
                _: 1
              })
            ], void 0, true),
            _: 1
          }),
          require$$0$1.withDirectives(require$$0$1.createElementVNode("div", null, [
            require$$0$1.withDirectives(require$$0$1.createVNode(_component_ui_button, {
              disabled: $data.loading,
              onClick: require$$0$1.withModifiers($options.toggleOrder, ["prevent"])
            }, {
              default: require$$0$1.withCtx(() => [
                require$$0$1.createVNode(_component_fa_icon, {
                  class: "mr-1",
                  icon: "ellipsis-v"
                }),
                require$$0$1.createTextVNode(require$$0$1.toDisplayString($data.order), 1)
              ], void 0, true),
              _: 1
            }, 8, ["disabled", "onClick"]), [
              [require$$0$1.vShow, $data.order === "Order"]
            ]),
            require$$0$1.withDirectives(require$$0$1.createVNode(_component_ui_button, {
              disabled: $data.loading,
              onClick: require$$0$1.withModifiers($options.toggleOrder, ["prevent"]),
              variant: "primary"
            }, {
              default: require$$0$1.withCtx(() => [
                require$$0$1.createVNode(_component_fa_icon, {
                  class: "mr-1",
                  icon: "ellipsis-v"
                }),
                require$$0$1.createTextVNode(require$$0$1.toDisplayString($data.order), 1)
              ], void 0, true),
              _: 1
            }, 8, ["disabled", "onClick"]), [
              [require$$0$1.vShow, $data.order === "Save"]
            ])
          ], 512), [
            [require$$0$1.vShow, $props.show_order]
          ]),
          require$$0$1.renderSlot(_ctx.$slots, "toolbarAppend")
        ], void 0, true),
        _: 3
      })) : require$$0$1.createCommentVNode("", true),
      require$$0$1.withDirectives(require$$0$1.createElementVNode("div", _hoisted_11, "Loading...", 512), [
        [require$$0$1.vShow, $data.loading]
      ]),
      $data.records.length ? require$$0$1.withDirectives((require$$0$1.openBlock(), require$$0$1.createElementBlock("div", {
        key: 1,
        class: require$$0$1.normalizeClass(["table-wrapper", { "loading": $data.loading }])
      }, [
        require$$0$1.createElementVNode("table", {
          id: $props.id,
          class: "table",
          "aria-live": "polite"
        }, [
          require$$0$1.createElementVNode("thead", null, [
            require$$0$1.createElementVNode("tr", null, [
              $options.hasBulkActions ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("th", _hoisted_13, [
                require$$0$1.createElementVNode("div", _hoisted_14, [
                  require$$0$1.createVNode(_component_ui_checkbox, {
                    name: "toggle-select-all",
                    id: "toggle-select-all",
                    checked: $options.selectable.length === $data.selected.length,
                    onInput: $options.toggleSelectAll,
                    indeterminate: $data.selected.length > 0 && $options.selectable.length !== $data.selected.length
                  }, null, 8, ["checked", "onInput", "indeterminate"])
                ])
              ])) : require$$0$1.createCommentVNode("", true),
              (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($data.displayable, (column, index) => {
                return require$$0$1.withDirectives((require$$0$1.openBlock(), require$$0$1.createElementBlock("th", {
                  class: require$$0$1.normalizeClass({ "sortable": $options.isSortable(column), "active": $data.sort.key === column, "w-96": column === "url", ["th-" + column]: true }),
                  key: column[$props.primaryKey] || index
                }, [
                  $options.isSortable(column) ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("a", {
                    key: 0,
                    href: "#",
                    class: "table__heading table__heading--link",
                    onClick: require$$0$1.withModifiers(($event) => $options.isSortable(column) && $options.sortRecordsBy(column), ["prevent"]),
                    "aria-label": "Sort by " + $data.column_names[column] || column
                  }, [
                    require$$0$1.createElementVNode("span", null, require$$0$1.toDisplayString($data.column_names[column] || column), 1),
                    $options.isSortable(column) ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_16, [
                      $data.sort.key !== column ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_fa_icon, {
                        key: 0,
                        icon: "sort",
                        class: "fa-fw"
                      })) : require$$0$1.createCommentVNode("", true),
                      $data.sort.order === "asc" && $data.sort.key === column ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_fa_icon, {
                        key: 1,
                        icon: "sort-up",
                        class: "fa-fw"
                      })) : require$$0$1.createCommentVNode("", true),
                      $data.sort.order === "desc" && $data.sort.key === column ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_fa_icon, {
                        key: 2,
                        icon: "sort-down",
                        class: "fa-fw"
                      })) : require$$0$1.createCommentVNode("", true)
                    ])) : require$$0$1.createCommentVNode("", true)
                  ], 8, _hoisted_15)) : (require$$0$1.openBlock(), require$$0$1.createElementBlock("span", _hoisted_17, require$$0$1.toDisplayString($data.column_names[column] || column), 1))
                ], 2)), [
                  [require$$0$1.vShow, !$options.hasSelections]
                ]);
              }), 128)),
              require$$0$1.withDirectives(require$$0$1.createElementVNode("th", {
                colspan: $options.hasActions ? $data.displayable.length + 1 : $data.displayable.length
              }, [
                require$$0$1.createElementVNode("span", _hoisted_19, [
                  require$$0$1.createTextVNode(require$$0$1.toDisplayString(this.selected.length) + " record" + require$$0$1.toDisplayString(this.selected.length > 1 ? "s" : "") + " selected ", 1),
                  require$$0$1.renderSlot(_ctx.$slots, "bulkActions", {
                    allowedBulkActions: $options.allowedBulkActions,
                    selected: $data.selected,
                    parent: this
                  }, () => [
                    require$$0$1.createElementVNode("div", _hoisted_20, [
                      require$$0$1.withDirectives(require$$0$1.createElementVNode("select", {
                        name: "bulk-actions",
                        id: "bulk-actions",
                        class: "field-select field-select--sm field-select--bordered",
                        "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => $data.action = $event),
                        onChange: _cache[4] || (_cache[4] = ($event) => $data.showBulkActionConfirmation = true)
                      }, [
                        _hoisted_21,
                        (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($options.allowedBulkActions, (action, index) => {
                          return require$$0$1.openBlock(), require$$0$1.createElementBlock("option", {
                            key: action.name,
                            value: index
                          }, require$$0$1.toDisplayString(action.name), 9, _hoisted_22);
                        }), 128))
                      ], 544), [
                        [require$$0$1.vModelSelect, $data.action]
                      ])
                    ]),
                    require$$0$1.createVNode(_component_portal, { to: "modals" }, {
                      default: require$$0$1.withCtx(() => [
                        $data.action !== null ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_modal, {
                          key: 0,
                          name: "confirm-bulk-action",
                          title: "Confirm Bulk " + $options.allowedBulkActions[$data.action].name,
                          modelValue: $data.showBulkActionConfirmation,
                          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => $data.showBulkActionConfirmation = $event)
                        }, {
                          footer: require$$0$1.withCtx(() => [
                            require$$0$1.createVNode(_component_ui_button, {
                              onClick: require$$0$1.withModifiers($options.confirmBulkAction, ["prevent"]),
                              loading: $data.working,
                              class: "ml-3",
                              variant: "primary"
                            }, {
                              default: require$$0$1.withCtx(() => [
                                require$$0$1.createTextVNode("Confirm")
                              ], void 0, true),
                              _: 1
                            }, 8, ["onClick", "loading"]),
                            !$data.working ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_button, {
                              key: 0,
                              onClick: require$$0$1.withModifiers($options.cancelBulkAction, ["prevent"]),
                              variant: "secondary"
                            }, {
                              default: require$$0$1.withCtx(() => [
                                require$$0$1.createTextVNode("Cancel")
                              ], void 0, true),
                              _: 1
                            }, 8, ["onClick"])) : require$$0$1.createCommentVNode("", true)
                          ]),
                          default: require$$0$1.withCtx(() => [
                            require$$0$1.createElementVNode("p", null, [
                              require$$0$1.createTextVNode("Are you sure you want to perform this action against "),
                              require$$0$1.createElementVNode("b", null, require$$0$1.toDisplayString($data.selected.length), 1),
                              require$$0$1.createTextVNode(" record" + require$$0$1.toDisplayString($data.selected.length > 1 ? "s" : "") + "?", 1)
                            ])
                          ], void 0, true),
                          _: 1
                        }, 8, ["title", "modelValue"])) : require$$0$1.createCommentVNode("", true)
                      ], void 0, true),
                      _: 1
                    })
                  ])
                ])
              ], 8, _hoisted_18), [
                [require$$0$1.vShow, $options.hasSelections]
              ]),
              require$$0$1.withDirectives(require$$0$1.createElementVNode("th", _hoisted_23, " ", 512), [
                [require$$0$1.vShow, $options.hasActions && !$options.hasSelections]
              ])
            ])
          ]),
          require$$0$1.createElementVNode("tbody", null, [
            (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($data.records, (record, index) => {
              return require$$0$1.openBlock(), require$$0$1.createElementBlock("tr", {
                key: record[$props.primaryKey] || index
              }, [
                $options.hasBulkActions ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("td", _hoisted_24, [
                  require$$0$1.createElementVNode("div", _hoisted_25, [
                    $options.isSelectable(record[$props.primaryKey]) ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_checkbox, {
                      key: 0,
                      name: "select-" + record[$props.primaryKey] || index,
                      id: "select-" + record[$props.primaryKey] || index,
                      "native-value": record[$props.primaryKey],
                      modelValue: $data.selected,
                      "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.selected = $event)
                    }, null, 8, ["name", "id", "native-value", "modelValue"])) : require$$0$1.createCommentVNode("", true)
                  ])
                ])) : require$$0$1.createCommentVNode("", true),
                (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($data.displayable, (column) => {
                  return require$$0$1.openBlock(), require$$0$1.createElementBlock("td", {
                    class: require$$0$1.normalizeClass("td-" + column),
                    key: column
                  }, [
                    require$$0$1.createElementVNode("span", _hoisted_26, require$$0$1.toDisplayString($data.column_names[column] || column), 1),
                    require$$0$1.renderSlot(_ctx.$slots, column, { record }, () => [
                      $data.column_types[column] && $options.isComponentExist($data.column_types[column]) ? (require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent($data.column_types[column]), {
                        key: 0,
                        value: record[column],
                        record
                      }, null, 8, ["value", "record"])) : (require$$0$1.openBlock(), require$$0$1.createElementBlock("span", _hoisted_27, require$$0$1.toDisplayString(record[column]), 1))
                    ])
                  ], 2);
                }), 128)),
                $options.hasActions ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("td", _hoisted_28, [
                  require$$0$1.renderSlot(_ctx.$slots, "actions", { record })
                ])) : require$$0$1.createCommentVNode("", true)
              ]);
            }), 128))
          ])
        ], 8, _hoisted_12)
      ], 2)), [
        [require$$0$1.vShow, $data.order === "Order"]
      ]) : require$$0$1.createCommentVNode("", true),
      require$$0$1.withDirectives(require$$0$1.createElementVNode("div", _hoisted_29, [
        require$$0$1.createVNode(_component_VueNestable, {
          modelValue: $data.records,
          "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => $data.records = $event),
          threshold: 32
        }, {
          default: require$$0$1.withCtx(() => [
            require$$0$1.createElementVNode("div", _hoisted_30, [
              require$$0$1.createVNode(_component_VueNestableHandle, {
                item: _ctx.item,
                class: "flex items-center justify-center border-r w-8 text-gray-500 bg-gray-50 rounded-l"
              }, {
                default: require$$0$1.withCtx(() => [
                  require$$0$1.createVNode(_component_fa_icon, { icon: ["fas", "grip-vertical"] })
                ], void 0, true),
                _: 1
              }, 8, ["item"]),
              require$$0$1.createElementVNode("div", _hoisted_31, [
                require$$0$1.createElementVNode("div", {
                  class: require$$0$1.normalizeClass(["p-3 flex items-center", { "font-bold": _ctx.item ? _ctx.item.url == "" || _ctx.item.url == "#" : false }])
                }, [
                  require$$0$1.withDirectives(require$$0$1.createVNode(_component_ui_status, {
                    value: _ctx.item.status,
                    class: "mr-2"
                  }, null, 8, ["value"]), [
                    [require$$0$1.vShow, $props.show_status]
                  ]),
                  require$$0$1.createVNode(_component_router_link, {
                    to: { name: $props.link_name, params: { [$props.link_param]: _ctx.item.id } }
                  }, {
                    default: require$$0$1.withCtx(() => [
                      require$$0$1.createTextVNode(require$$0$1.toDisplayString(_ctx.item.name), 1)
                    ], void 0, true),
                    _: 1
                  }, 8, ["to"])
                ], 2)
              ])
            ])
          ], void 0, true),
          _: 1
        }, 8, ["modelValue"])
      ], 512), [
        [require$$0$1.vShow, $data.order === "Save" && !$data.loading]
      ]),
      this.pagination.totalPages > 1 ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_32, [
        $props.showPageStatus ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_33, [
          require$$0$1.createVNode(_component_ui_pagination_status, {
            total: this.pagination.totalPages,
            value: this.pagination.currentPage
          }, null, 8, ["total", "value"])
        ])) : require$$0$1.createCommentVNode("", true),
        $props.showPageNumbers || $props.showPageNav || $props.showPageEnds ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_34, [
          require$$0$1.createVNode(_component_ui_pagination, {
            onInput: _cache[8] || (_cache[8] = ($event) => $options.changePage($event)),
            showNumbers: $props.showPageNumbers,
            showNav: $props.showPageNav,
            showEnds: $props.showPageEnds,
            total: this.pagination.totalPages,
            value: this.pagination.currentPage
          }, null, 8, ["showNumbers", "showNav", "showEnds", "total", "value"])
        ])) : require$$0$1.createCommentVNode("", true),
        !$props.hidePageSelect ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_35, [
          require$$0$1.createVNode(_component_ui_pagination_select, {
            onInput: _cache[9] || (_cache[9] = ($event) => $options.changePage($event)),
            label: $props.pageSelectLabel,
            total: this.pagination.totalPages,
            value: this.pagination.currentPage
          }, null, 8, ["label", "total", "value"])
        ])) : require$$0$1.createCommentVNode("", true)
      ])) : require$$0$1.createCommentVNode("", true),
      !$data.records.length && !$data.initialLoad ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_36, [
        require$$0$1.renderSlot(_ctx.$slots, "empty-state", {}, () => [
          _hoisted_37
        ])
      ])) : require$$0$1.createCommentVNode("", true)
    ]);
  }
  const DataTable$1 = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$s]]);
  const token = "%[a-f0-9]{2}";
  const singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
  const multiMatcher = new RegExp("(" + token + ")+", "gi");
  function decodeComponents(components, split) {
    try {
      return [decodeURIComponent(components.join(""))];
    } catch {
    }
    if (components.length === 1) {
      return components;
    }
    split = split || 1;
    const left = components.slice(0, split);
    const right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  }
  function decode$1(input) {
    try {
      return decodeURIComponent(input);
    } catch {
      let tokens = input.match(singleMatcher) || [];
      for (let i = 1; i < tokens.length; i++) {
        input = decodeComponents(tokens, i).join("");
        tokens = input.match(singleMatcher) || [];
      }
      return input;
    }
  }
  function customDecodeURIComponent(input) {
    const replaceMap = {
      "%FE%FF": "��",
      "%FF%FE": "��"
    };
    let match = multiMatcher.exec(input);
    while (match) {
      try {
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch {
        const result = decode$1(match[0]);
        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }
      match = multiMatcher.exec(input);
    }
    replaceMap["%C2"] = "�";
    const entries = Object.keys(replaceMap);
    for (const key of entries) {
      input = input.replace(new RegExp(key, "g"), replaceMap[key]);
    }
    return input;
  }
  function decodeUriComponent(encodedURI) {
    if (typeof encodedURI !== "string") {
      throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
    }
    try {
      return decodeURIComponent(encodedURI);
    } catch {
      return customDecodeURIComponent(encodedURI);
    }
  }
  function splitOnFirst(string, separator) {
    if (!(typeof string === "string" && typeof separator === "string")) {
      throw new TypeError("Expected the arguments to be of type `string`");
    }
    if (string === "" || separator === "") {
      return [];
    }
    const separatorIndex = string.indexOf(separator);
    if (separatorIndex === -1) {
      return [];
    }
    return [
      string.slice(0, separatorIndex),
      string.slice(separatorIndex + separator.length)
    ];
  }
  function includeKeys(object, predicate) {
    const result = {};
    if (Array.isArray(predicate)) {
      for (const key of predicate) {
        const descriptor = Object.getOwnPropertyDescriptor(object, key);
        if (descriptor == null ? void 0 : descriptor.enumerable) {
          Object.defineProperty(result, key, descriptor);
        }
      }
    } else {
      for (const key of Reflect.ownKeys(object)) {
        const descriptor = Object.getOwnPropertyDescriptor(object, key);
        if (descriptor.enumerable) {
          const value = object[key];
          if (predicate(key, value, object)) {
            Object.defineProperty(result, key, descriptor);
          }
        }
      }
    }
    return result;
  }
  const isNullOrUndefined = (value) => value === null || value === void 0;
  const strictUriEncode = (string) => encodeURIComponent(string).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
  const encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case "index": {
        return (key) => (result, value) => {
          const index = result.length;
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [
              ...result,
              [encode(key, options), "[", index, "]"].join("")
            ];
          }
          return [
            ...result,
            [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
          ];
        };
      }
      case "bracket": {
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [
              ...result,
              [encode(key, options), "[]"].join("")
            ];
          }
          return [
            ...result,
            [encode(key, options), "[]=", encode(value, options)].join("")
          ];
        };
      }
      case "colon-list-separator": {
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [
              ...result,
              [encode(key, options), ":list="].join("")
            ];
          }
          return [
            ...result,
            [encode(key, options), ":list=", encode(value, options)].join("")
          ];
        };
      }
      case "comma":
      case "separator":
      case "bracket-separator": {
        const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          value = value === null ? "" : value;
          if (result.length === 0) {
            return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
          }
          return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
        };
      }
      default: {
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [
              ...result,
              encode(key, options)
            ];
          }
          return [
            ...result,
            [encode(key, options), "=", encode(value, options)].join("")
          ];
        };
      }
    }
  }
  function parserForArrayFormat(options) {
    let result;
    switch (options.arrayFormat) {
      case "index": {
        return (key, value, accumulator) => {
          result = /\[(\d*)]$/.exec(key);
          key = key.replace(/\[\d*]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = {};
          }
          accumulator[key][result[1]] = value;
        };
      }
      case "bracket": {
        return (key, value, accumulator) => {
          result = /(\[])$/.exec(key);
          key = key.replace(/\[]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [...accumulator[key], value];
        };
      }
      case "colon-list-separator": {
        return (key, value, accumulator) => {
          result = /(:list)$/.exec(key);
          key = key.replace(/:list$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [...accumulator[key], value];
        };
      }
      case "comma":
      case "separator": {
        return (key, value, accumulator) => {
          const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
          const isEncodedArray = typeof value === "string" && !isArray2 && decode(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode(value, options) : value;
          const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
          accumulator[key] = newValue;
        };
      }
      case "bracket-separator": {
        return (key, value, accumulator) => {
          const isArray2 = /(\[])$/.test(key);
          key = key.replace(/\[]$/, "");
          if (!isArray2) {
            accumulator[key] = value ? decode(value, options) : value;
            return;
          }
          const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
          if (accumulator[key] === void 0) {
            accumulator[key] = arrayValue;
            return;
          }
          accumulator[key] = [...accumulator[key], ...arrayValue];
        };
      }
      default: {
        return (key, value, accumulator) => {
          if (accumulator[key] === void 0) {
            accumulator[key] = value;
            return;
          }
          accumulator[key] = [...[accumulator[key]].flat(), value];
        };
      }
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode(value, options) {
    if (options.decode) {
      return decodeUriComponent(value);
    }
    return value;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === "object") {
      return keysSorter(Object.keys(input)).sort((a2, b) => Number(a2) - Number(b)).map((key) => input[key]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash(url) {
    let hash = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
      hash = url.slice(hashStart);
    }
    return hash;
  }
  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      value = value.toLowerCase() === "true";
    }
    return value;
  }
  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input.slice(queryStart + 1);
  }
  function parse(query, options) {
    options = {
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false,
      ...options
    };
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options);
    const returnValue = /* @__PURE__ */ Object.create(null);
    if (typeof query !== "string") {
      return returnValue;
    }
    query = query.trim().replace(/^[?#&]/, "");
    if (!query) {
      return returnValue;
    }
    for (const parameter of query.split("&")) {
      if (parameter === "") {
        continue;
      }
      const parameter_ = options.decode ? parameter.replace(/\+/g, " ") : parameter;
      let [key, value] = splitOnFirst(parameter_, "=");
      if (key === void 0) {
        key = parameter_;
      }
      value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
      formatter(decode(key, options), value, returnValue);
    }
    for (const [key, value] of Object.entries(returnValue)) {
      if (typeof value === "object" && value !== null) {
        for (const [key2, value2] of Object.entries(value)) {
          value[key2] = parseValue(value2, options);
        }
      } else {
        returnValue[key] = parseValue(value, options);
      }
    }
    if (options.sort === false) {
      return returnValue;
    }
    return (options.sort === true ? Object.keys(returnValue).sort() : Object.keys(returnValue).sort(options.sort)).reduce((result, key) => {
      const value = returnValue[key];
      if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
        result[key] = keysSorter(value);
      } else {
        result[key] = value;
      }
      return result;
    }, /* @__PURE__ */ Object.create(null));
  }
  function stringify(object, options) {
    if (!object) {
      return "";
    }
    options = {
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      ...options
    };
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const [key, value] of Object.entries(object)) {
      if (!shouldFilter(key)) {
        objectCopy[key] = value;
      }
    }
    const keys = Object.keys(objectCopy);
    if (options.sort !== false) {
      keys.sort(options.sort);
    }
    return keys.map((key) => {
      const value = object[key];
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return encode(key, options);
      }
      if (Array.isArray(value)) {
        if (value.length === 0 && options.arrayFormat === "bracket-separator") {
          return encode(key, options) + "[]";
        }
        return value.reduce(formatter(key), []).join("&");
      }
      return encode(key, options) + "=" + encode(value, options);
    }).filter((x) => x.length > 0).join("&");
  }
  function parseUrl(url, options) {
    var _a;
    options = {
      decode: true,
      ...options
    };
    let [url_, hash] = splitOnFirst(url, "#");
    if (url_ === void 0) {
      url_ = url;
    }
    return {
      url: ((_a = url_ == null ? void 0 : url_.split("?")) == null ? void 0 : _a[0]) ?? "",
      query: parse(extract(url), options),
      ...options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode(hash, options) } : {}
    };
  }
  function stringifyUrl(object, options) {
    options = {
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true,
      ...options
    };
    const url = removeHash(object.url).split("?")[0] || "";
    const queryFromUrl = extract(object.url);
    const query = {
      ...parse(queryFromUrl, { sort: false }),
      ...object.query
    };
    let queryString2 = stringify(query, options);
    if (queryString2) {
      queryString2 = `?${queryString2}`;
    }
    let hash = getHash(object.url);
    if (object.fragmentIdentifier) {
      const urlObjectForFragmentEncode = new URL(url);
      urlObjectForFragmentEncode.hash = object.fragmentIdentifier;
      hash = options[encodeFragmentIdentifier] ? urlObjectForFragmentEncode.hash : `#${object.fragmentIdentifier}`;
    }
    return `${url}${queryString2}${hash}`;
  }
  function pick(input, filter, options) {
    options = {
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false,
      ...options
    };
    const { url, query, fragmentIdentifier } = parseUrl(input, options);
    return stringifyUrl({
      url,
      query: includeKeys(query, filter),
      fragmentIdentifier
    }, options);
  }
  function exclude(input, filter, options) {
    const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
    return pick(input, exclusionFilter, options);
  }
  const queryString = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    exclude,
    extract,
    parse,
    parseUrl,
    pick,
    stringify,
    stringifyUrl
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$s = {
    props: {
      filters: {
        type: Array
      }
    },
    extends: DataTable$1,
    watch: {
      filters: {
        handler(value) {
          this.getRecords();
        },
        deep: true
      }
    },
    methods: {
      getRecords() {
        this.loading = true;
        return axios.get(`${this.endpoint}?${this.getQueryParameters()}`).then((response) => {
          this.records = response.data.records.data;
          this.displayable = response.data.displayable;
          this.sortable = response.data.sortable;
          this.column_names = response.data.column_names;
          this.column_types = response.data.column_types;
          this.bulk_actions = response.data.bulk_actions;
          this.bulk_actions_exempt = response.data.bulk_actions_exempt;
          this.pagination.totalRecords = response.data.records.total;
          this.pagination.totalPages = response.data.records.last_page;
          this.$emit("update-metrics", response.data.metrics);
          this.loading = false;
          this.initialLoad = false;
          if (this.refresh && !self._timer) {
            this._timer = setTimeout(() => this.getRecords(), this.refresh);
          }
          this.$emit("loaded", this.records);
        });
      },
      getQueryParameters() {
        let params = {
          sort: (this.sort.order === "desc" ? "-" : "") + this.sort.key,
          page: this.pagination.currentPage,
          perPage: this.pagination.perPage
        };
        if (this.filters) {
          Object.keys(this.filters).forEach((key) => {
            if (typeof this.filters[key] == "object") {
              params["filter[" + key + "][]"] = this.filters[key];
            } else {
              params["filter[" + key + "]"] = this.filters[key];
            }
          });
        }
        if (this.search !== "") {
          params["filter[search]"] = this.search;
        }
        return queryString.stringify(params);
      }
    }
  };
  const DataTable = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: _sfc_main$s
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$r = {
    props: {
      label: {}
    },
    name: "panel-body"
  };
  const _hoisted_1$g = {
    key: 0,
    class: "section-card__header card-col__header"
  };
  function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", {
      class: require$$0$1.normalizeClass(["card__body", { "card-col": $props.label }])
    }, [
      $props.label ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_1$g, [
        require$$0$1.createElementVNode("h2", null, require$$0$1.toDisplayString($props.label), 1)
      ])) : require$$0$1.createCommentVNode("", true),
      require$$0$1.createElementVNode("div", {
        class: require$$0$1.normalizeClass({ "section-card__body card-col__body": $props.label })
      }, [
        require$$0$1.renderSlot(_ctx.$slots, "default")
      ], 2)
    ], 2);
  }
  const PanelBody = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$r]]);
  const PanelBody$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: PanelBody
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$q = {
    props: {
      value: {},
      record: {},
      resource: {}
    }
  };
  const _hoisted_1$f = { class: "items-center" };
  function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_router_link = require$$0$1.resolveComponent("router-link");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_1$f, [
      require$$0$1.createVNode(_component_router_link, {
        to: { name: "antfusion.resource.edit", params: { resource: $props.record.resource.slug, id: $props.record.id } }
      }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createTextVNode(require$$0$1.toDisplayString($props.value), 1)
        ], void 0, true),
        _: 1
      }, 8, ["to"])
    ]);
  }
  const EditResourceLink = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$q]]);
  const EditResourceLink$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: EditResourceLink
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$p = {
    props: {
      components: {}
    }
  };
  function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($props.components, (component, index) => {
        return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(component.component), require$$0$1.mergeProps(component, { key: index }), null, 16);
      }), 128))
    ]);
  }
  const PageAsComponent = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$p]]);
  const PageAsComponent$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: PageAsComponent
  }, Symbol.toStringTag, { value: "Module" }));
  const Spinner_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$o = {
    props: {
      variant: {
        default: "white"
      },
      text: {
        default: ""
      },
      containerClass: {}
    },
    computed: {
      containerClassName() {
        return "mx-1 align-middle inline-flex " + this.containerClass;
      },
      className() {
        return "text-" + this.variant;
      }
    }
  };
  const _hoisted_1$e = /* @__PURE__ */ require$$0$1.createElementVNode("circle", {
    class: "opacity-25",
    cx: "12",
    cy: "12",
    r: "10",
    stroke: "currentColor",
    "stroke-width": "4"
  }, null, -1);
  const _hoisted_2$6 = /* @__PURE__ */ require$$0$1.createElementVNode("path", {
    class: "opacity-75",
    fill: "currentColor",
    d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
  }, null, -1);
  const _hoisted_3$3 = [
    _hoisted_1$e,
    _hoisted_2$6
  ];
  function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", {
      class: require$$0$1.normalizeClass($options.containerClassName)
    }, [
      (require$$0$1.openBlock(), require$$0$1.createElementBlock("svg", {
        class: require$$0$1.normalizeClass("animate-spin -ml-1 mb-1 h-5 w-5 " + $options.className),
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 24 24"
      }, _hoisted_3$3, 2)),
      require$$0$1.createTextVNode(require$$0$1.toDisplayString($props.text), 1)
    ], 2);
  }
  const Spinner = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$o]]);
  const Spinner$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Spinner
  }, Symbol.toStringTag, { value: "Module" }));
  var lodash = { exports: {} };
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  lodash.exports;
  (function(module2, exports2) {
    (function() {
      var undefined$1;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined$1 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined$1 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined$1;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined$1 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined$1 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$1;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined$1 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined$1) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined$1) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer2(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined$1 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined$1, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined$1 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined$1;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined$1 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer2(object)) {
            if (!isBuffer2(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject2(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
          var isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined$1;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject2(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined$1;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString2(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined$1 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result2).set(new Uint8Array(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$1 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString2(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray2(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result2 = value;
            }
            if (other !== undefined$1) {
              if (result2 === undefined$1) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined$1;
            }
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString2(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$1;
          }
          ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined$1 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined$1;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject2(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray2(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined$1 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined$1;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined$1;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$1;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined$1, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined$1);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined$1;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined$1 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined$1;
            }
            return result2;
          };
        }
        var bind2 = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined$1;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now2());
          }
          function debounced() {
            var time = now2(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial2 = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial2));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread2(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial2(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer2 = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined2(value) {
          return value === undefined$1;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString2(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults2 = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith, undefined$1, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined$1 : baseGet(object, path);
          return result2 === undefined$1 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick2 = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined$1;
          }
          while (++index < length) {
            var value = object == null ? undefined$1 : object[toKey(path[index])];
            if (value === undefined$1) {
              index = length;
              value = defaultValue;
            }
            object = isFunction2(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update2(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined$1;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString2(string).toLowerCase());
        }
        function deburr(string) {
          string = toString2(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString2(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape2(string) {
          string = toString2(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString2(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad2(string, length, chars) {
          string = toString2(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString2(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString2(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString2(string), n);
        }
        function replace() {
          var args = arguments, string = toString2(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString2(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString2(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings2 = lodash2.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$1;
          }
          string = toString2(string);
          options = assignInWith({}, options, settings2, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings2.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString2(value).toLowerCase();
        }
        function toUpper(value) {
          return toString2(value).toUpperCase();
        }
        function trim2(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined$1)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined$1)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString2(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString2(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined$1) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString2(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString2(string);
          pattern = guard ? undefined$1 : pattern;
          if (pattern === undefined$1) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind2(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined$1 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString2(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at;
        lodash2.before = before;
        lodash2.bind = bind2;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk;
        lodash2.compact = compact;
        lodash2.concat = concat;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant;
        lodash2.countBy = countBy;
        lodash2.create = create;
        lodash2.curry = curry;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce2;
        lodash2.defaults = defaults2;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter;
        lodash2.flatMap = flatMap;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip;
        lodash2.flow = flow;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys;
        lodash2.keysIn = keysIn;
        lodash2.map = map;
        lodash2.mapKeys = mapKeys;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize;
        lodash2.merge = merge2;
        lodash2.mergeWith = mergeWith;
        lodash2.method = method;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit;
        lodash2.omitBy = omitBy;
        lodash2.once = once;
        lodash2.orderBy = orderBy;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial2;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition;
        lodash2.pick = pick2;
        lodash2.pickBy = pickBy;
        lodash2.property = property;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull;
        lodash2.pullAll = pullAll;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove;
        lodash2.rest = rest;
        lodash2.reverse = reverse;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle;
        lodash2.slice = slice;
        lodash2.sortBy = sortBy;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split;
        lodash2.spread = spread2;
        lodash2.tail = tail;
        lodash2.take = take;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile;
        lodash2.tap = tap;
        lodash2.throttle = throttle;
        lodash2.thru = thru;
        lodash2.toArray = toArray;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject;
        lodash2.transform = transform;
        lodash2.unary = unary;
        lodash2.union = union;
        lodash2.unionBy = unionBy;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update2;
        lodash2.updateWith = updateWith;
        lodash2.values = values;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words;
        lodash2.wrap = wrap;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin(lodash2, lodash2);
        lodash2.add = add;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase;
        lodash2.capitalize = capitalize;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp;
        lodash2.clone = clone;
        lodash2.cloneDeep = cloneDeep;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith;
        lodash2.eq = eq;
        lodash2.escape = escape2;
        lodash2.escapeRegExp = escapeRegExp;
        lodash2.every = every;
        lodash2.find = find;
        lodash2.findIndex = findIndex;
        lodash2.findKey = findKey;
        lodash2.findLast = findLast;
        lodash2.findLastIndex = findLastIndex;
        lodash2.findLastKey = findLastKey;
        lodash2.floor = floor;
        lodash2.forEach = forEach2;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get;
        lodash2.gt = gt;
        lodash2.gte = gte;
        lodash2.has = has;
        lodash2.hasIn = hasIn;
        lodash2.head = head;
        lodash2.identity = identity;
        lodash2.includes = includes;
        lodash2.indexOf = indexOf;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments;
        lodash2.isArray = isArray2;
        lodash2.isArrayBuffer = isArrayBuffer2;
        lodash2.isArrayLike = isArrayLike;
        lodash2.isArrayLikeObject = isArrayLikeObject;
        lodash2.isBoolean = isBoolean;
        lodash2.isBuffer = isBuffer2;
        lodash2.isDate = isDate2;
        lodash2.isElement = isElement;
        lodash2.isEmpty = isEmpty;
        lodash2.isEqual = isEqual;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite;
        lodash2.isFunction = isFunction2;
        lodash2.isInteger = isInteger;
        lodash2.isLength = isLength;
        lodash2.isMap = isMap;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN2;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber2;
        lodash2.isObject = isObject2;
        lodash2.isObjectLike = isObjectLike;
        lodash2.isPlainObject = isPlainObject2;
        lodash2.isRegExp = isRegExp;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet;
        lodash2.isString = isString2;
        lodash2.isSymbol = isSymbol;
        lodash2.isTypedArray = isTypedArray;
        lodash2.isUndefined = isUndefined2;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join;
        lodash2.kebabCase = kebabCase;
        lodash2.last = last;
        lodash2.lastIndexOf = lastIndexOf;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max;
        lodash2.maxBy = maxBy;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min;
        lodash2.minBy = minBy;
        lodash2.stubArray = stubArray;
        lodash2.stubFalse = stubFalse;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop;
        lodash2.now = now2;
        lodash2.pad = pad2;
        lodash2.padEnd = padEnd;
        lodash2.padStart = padStart;
        lodash2.parseInt = parseInt2;
        lodash2.random = random;
        lodash2.reduce = reduce;
        lodash2.reduceRight = reduceRight;
        lodash2.repeat = repeat;
        lodash2.replace = replace;
        lodash2.result = result;
        lodash2.round = round;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase;
        lodash2.startsWith = startsWith;
        lodash2.subtract = subtract;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite;
        lodash2.toInteger = toInteger;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString2;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim2;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape2;
        lodash2.uniqueId = uniqueId;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst;
        lodash2.each = forEach2;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin(lodash2, function() {
          var source = {};
          baseForOwn(lodash2, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash2.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined$1
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      };
      var _2 = runInContext();
      if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root._ = _2;
      }
    }).call(commonjsGlobal);
  })(lodash, lodash.exports);
  var lodashExports = lodash.exports;
  const _$1 = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports);
  const _sfc_main$n = {
    props: {
      name: {},
      parent: {},
      attribute: {},
      label: {}
    },
    computed: {
      value() {
        if (this.parent && this.attribute) {
          let value = _$1.get(this.parent, this.attribute);
          this.$emit("input", value);
          return value;
        }
      }
    }
  };
  const _hoisted_1$d = { class: "form-group" };
  function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ui_label = require$$0$1.resolveComponent("ui-label");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_1$d, [
      require$$0$1.createVNode(_component_ui_label, null, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createTextVNode(require$$0$1.toDisplayString($props.name), 1)
        ], void 0, true),
        _: 1
      }),
      require$$0$1.createElementVNode("div", null, require$$0$1.toDisplayString($options.value), 1)
    ]);
  }
  const ParentValue = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n]]);
  const ParentValue$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: ParentValue
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$m = {
    props: {
      loading: {
        default: false
      },
      text: {
        default: "Print"
      }
    },
    methods: {
      print() {
        window.print();
      }
    }
  };
  function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ui_button = require$$0$1.resolveComponent("ui-button");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("span", null, [
      !$props.loading ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_button, {
        key: 0,
        onClick: require$$0$1.withModifiers($options.print, ["prevent"])
      }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createTextVNode(require$$0$1.toDisplayString($props.text), 1)
        ], void 0, true),
        _: 1
      }, 8, ["onClick"])) : require$$0$1.createCommentVNode("", true)
    ]);
  }
  const PrintButton = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m]]);
  const PrintButton$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: PrintButton
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$l = {
    emits: [],
    props: {
      id: {},
      variant: {},
      route: {},
      parent: {},
      asDropdown: {
        default: false
      },
      confirmButtonText: {
        default: "OK"
      },
      resetWhenClose: {
        default: true
      },
      url: {
        default: null
      },
      formMethod: {
        default: "post"
      },
      text: {
        default: null
      },
      title: {
        default: null
      },
      fields: {},
      record: {
        default: {}
      },
      load_record: {
        default: {}
      }
    },
    data() {
      return {
        loading: false,
        form: null
      };
    },
    computed: {
      modalName() {
        return "action-" + this._uid;
      },
      modalTitle() {
        if (this.confirmTitle) {
          return this.confirmTitle;
        }
        return this.title;
      },
      componentData() {
        return {
          parent: this.parent
        };
      }
    },
    mounted() {
      this.initForm();
    },
    methods: {
      initForm() {
        let fields = {};
        this.fields.forEach((field) => {
          if (this.load_record[field.handle]) {
            fields[field.handle] = _$1.get(this.record, this.load_record[field.handle]);
          } else {
            fields[field.handle] = null;
          }
        });
        this.form = new Form(fields);
      },
      openModalForm() {
        this.openModal(this.modalName);
      },
      submit() {
        this.loading = true;
        let params = this.form.formdata();
        params.append("route", this.route);
        if (this.record.id) {
          params.append("resourceIds[]", this.record.id);
        }
        this.form.submit("post", this.url, params).then((response) => {
          this.loading = false;
          this.$emit("submitted");
          this.closeModal(this.modalName);
          if (response.message) {
            toast(response.message, "success");
          }
          if (response.redirect) {
            if (response.target) {
              window.open(response.redirect, response.target);
            } else {
              this.$router.push(response.redirect);
            }
          }
        }).catch((error) => {
          this.loading = false;
          if (error.errors) {
            this.errors = error.errors;
            var message = Object.keys(error.errors).map((key) => {
              return error.errors[key].join(" ");
            }).join(" ");
            toast(message, "failed");
          } else {
            toast(error.message, "failed");
          }
        });
      },
      closeModal(name2, value) {
        this.$bus.$emit("toggle-modal-" + name2, { value });
      },
      openModal(name2, value) {
        this.$bus.$emit("toggle-modal-" + name2, { value });
      },
      modalChanged(isActive) {
        if (isActive && this.resetWhenClose) {
          this.initForm();
        }
      },
      toggle() {
        if (this.$parent && this.$parent.toggle) {
          this.$parent.toggle();
        }
      }
    }
  };
  const _hoisted_1$c = { key: 0 };
  function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ui_dropdown_link = require$$0$1.resolveComponent("ui-dropdown-link");
    const _component_ui_button = require$$0$1.resolveComponent("ui-button");
    const _component_spinner = require$$0$1.resolveComponent("spinner");
    const _component_ui_modal = require$$0$1.resolveComponent("ui-modal");
    const _component_portal = require$$0$1.resolveComponent("portal");
    const _directive_modal = require$$0$1.resolveDirective("modal");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      $props.asDropdown ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_dropdown_link, require$$0$1.mergeProps({ key: 0 }, _ctx.$props, {
        onClick: _cache[0] || (_cache[0] = ($event) => $options.openModalForm())
      }), {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createTextVNode(require$$0$1.toDisplayString($props.text), 1)
        ], void 0, true),
        _: 1
      }, 16)) : (require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_button, {
        key: 1,
        variant: $props.variant,
        onClick: _cache[1] || (_cache[1] = require$$0$1.withModifiers(($event) => $options.openModalForm(), ["prevent"]))
      }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createTextVNode(require$$0$1.toDisplayString($props.text), 1)
        ], void 0, true),
        _: 1
      }, 8, ["variant"])),
      require$$0$1.createVNode(_component_portal, { to: "modals" }, {
        default: require$$0$1.withCtx(() => [
          (require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_modal, {
            name: $options.modalName,
            title: $options.modalTitle,
            key: $options.modalName,
            onInput: $options.modalChanged
          }, {
            footer: require$$0$1.withCtx((entry) => [
              require$$0$1.createVNode(_component_ui_button, {
                disabled: $data.loading,
                onClick: $options.submit,
                class: "ml-3 button--primary"
              }, {
                default: require$$0$1.withCtx(() => [
                  require$$0$1.withDirectives(require$$0$1.createVNode(_component_spinner, null, null, 512), [
                    [require$$0$1.vShow, $data.loading]
                  ]),
                  require$$0$1.createTextVNode(" " + require$$0$1.toDisplayString($props.confirmButtonText), 1)
                ], void 0, true),
                _: 1
              }, 8, ["disabled", "onClick"]),
              require$$0$1.withDirectives((require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_button, null, {
                default: require$$0$1.withCtx(() => [
                  require$$0$1.createTextVNode("Cancel")
                ], void 0, true),
                _: 1
              })), [
                [_directive_modal, void 0, $options.modalName]
              ])
            ]),
            default: require$$0$1.withCtx(() => [
              $data.form ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("span", _hoisted_1$c, [
                (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($props.fields, (field, index) => {
                  return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(field.component), require$$0$1.mergeProps(field, {
                    modelValue: $data.form[field.handle],
                    "onUpdate:modelValue": ($event) => $data.form[field.handle] = $event,
                    key: field.handle
                  }, {
                    parent: $options.componentData,
                    record: $props.record,
                    "has-error": $data.form.errors.has(field.handle),
                    "error-message": $data.form.errors.get(field.handle),
                    errors: $data.form.errors
                  }), null, 16, ["modelValue", "onUpdate:modelValue", "parent", "record", "has-error", "error-message", "errors"]);
                }), 128))
              ])) : require$$0$1.createCommentVNode("", true)
            ], void 0, true),
            _: 1
          }, 8, ["name", "title", "onInput"]))
        ], void 0, true),
        _: 1
      })
    ]);
  }
  const ActionButton = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l]]);
  const ActionButton$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: ActionButton
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$k = {
    emits: [],
    props: {
      cssClass: {},
      url: {},
      confirmButtonText: {
        default: "Confirm"
      },
      cancelButtonLabel: {
        default: "Cancel"
      },
      title: {},
      record: {},
      resourceId: {},
      resourceHandle: {},
      actionHandle: {},
      confirmTitle: {},
      confirmText: {},
      to: {},
      text: {}
    },
    data() {
      return {
        loading: false
      };
    },
    computed: {
      needConfirmation() {
        return this.confirmText;
      },
      modalTitle() {
        if (this.confirmTitle) {
          return this.confirmTitle;
        }
        return this.title;
      },
      modalName() {
        return "action-link-confirmation-" + this._uid;
      }
    },
    methods: {
      toggle() {
        if (this.$parent && this.$parent.toggle) {
          this.$parent.toggle();
        }
      },
      performAction() {
        console.log("need ", this.needConfirmation);
        if (this.needConfirmation) {
          this.askConfirmation();
        } else {
          this.confirm();
        }
      },
      askConfirmation() {
        this.openModal(this.modalName);
      },
      confirm() {
        console.log("confirm", this);
        this.loading = true;
        axios.post(this.url, { resourceIds: [this.record.id] }).then((response) => {
          console.log("action button", response);
          if (response.data.redirect) {
            if (response.data.target) {
              window.open(response.data.redirect, response.data.target);
            } else {
              this.$router.push(response.data.redirect);
            }
          } else {
            this.loading = false;
            toast(response.data.message, "success");
            this.closeModal(this.modalName);
            this.$emit("updated");
          }
        }).catch((error) => {
          this.loading = false;
          toast(error.response.data.message, "error");
        });
      },
      closeModal(name2, value) {
        this.$bus.$emit("toggle-modal-" + name2, { value });
      },
      openModal(name2, value) {
        this.$bus.$emit("toggle-modal-" + name2, { value });
      }
    }
  };
  function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ui_dropdown_link = require$$0$1.resolveComponent("ui-dropdown-link");
    const _component_ui_button = require$$0$1.resolveComponent("ui-button");
    const _component_ui_modal = require$$0$1.resolveComponent("ui-modal");
    const _component_portal = require$$0$1.resolveComponent("portal");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      require$$0$1.createVNode(_component_ui_dropdown_link, require$$0$1.mergeProps(_ctx.$props, {
        onClick: require$$0$1.withModifiers($options.performAction, ["prevent"])
      }, { class: $props.cssClass }), {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createTextVNode(require$$0$1.toDisplayString($props.text), 1)
        ], void 0, true),
        _: 1
      }, 16, ["onClick", "class"]),
      $options.needConfirmation ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_portal, {
        key: 0,
        to: "modals"
      }, {
        default: require$$0$1.withCtx(() => [
          (require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_modal, {
            name: $options.modalName,
            title: $options.modalTitle,
            key: $options.modalName
          }, {
            footer: require$$0$1.withCtx((entry) => [
              require$$0$1.createVNode(_component_ui_button, {
                disabled: $data.loading,
                onClick: _cache[0] || (_cache[0] = ($event) => $options.confirm()),
                variant: "danger",
                class: "ml-3"
              }, {
                default: require$$0$1.withCtx(() => [
                  require$$0$1.createTextVNode(require$$0$1.toDisplayString($props.confirmButtonText), 1)
                ], void 0, true),
                _: 1
              }, 8, ["disabled"]),
              require$$0$1.createVNode(_component_ui_button, {
                disabled: $data.loading,
                onClick: _cache[1] || (_cache[1] = ($event) => $options.closeModal($options.modalName)),
                variant: "secondary"
              }, {
                default: require$$0$1.withCtx(() => [
                  require$$0$1.createTextVNode(require$$0$1.toDisplayString($props.cancelButtonLabel), 1)
                ], void 0, true),
                _: 1
              }, 8, ["disabled"])
            ]),
            default: require$$0$1.withCtx(() => [
              require$$0$1.createElementVNode("p", null, require$$0$1.toDisplayString($props.confirmText), 1)
            ], void 0, true),
            _: 1
          }, 8, ["name", "title"]))
        ], void 0, true),
        _: 1
      })) : require$$0$1.createCommentVNode("", true)
    ]);
  }
  const ActionDropDownLink = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k]]);
  const ActionDropDownLink$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: ActionDropDownLink
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$j = {
    props: {
      text: {},
      parent: {},
      variant: {}
    }
  };
  function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ui_button = require$$0$1.resolveComponent("ui-button");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("span", null, [
      require$$0$1.createVNode(_component_ui_button, require$$0$1.mergeProps(_ctx.$props, {
        onClick: $props.parent.submit
      }), {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createTextVNode(require$$0$1.toDisplayString($props.text), 1)
        ], void 0, true),
        _: 1
      }, 16, ["onClick"])
    ]);
  }
  const SubmitButton = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j]]);
  const SubmitButton$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: SubmitButton
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$i = {
    props: {
      debug: {
        default: false
      },
      form: {
        default: {}
      },
      text: {},
      props: {},
      as: {},
      record: {},
      children: {}
    }
  };
  const _hoisted_1$b = { key: 0 };
  const _hoisted_2$5 = { key: 0 };
  const _hoisted_3$2 = { key: 0 };
  function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
    return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent($props.as), require$$0$1.mergeProps($props.props, {
      form: $props.form,
      errors: $props.form.errors
    }), {
      default: require$$0$1.withCtx(() => [
        $props.debug ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("span", _hoisted_1$b, require$$0$1.toDisplayString($props.as), 1)) : require$$0$1.createCommentVNode("", true),
        require$$0$1.createTextVNode(" " + require$$0$1.toDisplayString($props.text) + " ", 1),
        $props.children ? (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, { key: 1 }, require$$0$1.renderList($props.children, (childComponent, index) => {
          return require$$0$1.withDirectives((require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(childComponent.component), require$$0$1.mergeProps(childComponent, {
            modelValue: $props.form[childComponent.handle],
            "onUpdate:modelValue": ($event) => $props.form[childComponent.handle] = $event,
            form: $props.form,
            errors: $props.form.errors,
            record: $props.record
          }, require$$0$1.toHandlers(_ctx.$listeners), { key: index }), {
            default: require$$0$1.withCtx(() => [
              $props.debug ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("span", _hoisted_2$5, require$$0$1.toDisplayString(childComponent.component), 1)) : require$$0$1.createCommentVNode("", true),
              require$$0$1.createTextVNode(" " + require$$0$1.toDisplayString(childComponent.text) + " ", 1),
              childComponent.children ? (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, { key: 1 }, require$$0$1.renderList(childComponent.children, (grandchild, index2) => {
                return require$$0$1.withDirectives((require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(grandchild.component), require$$0$1.mergeProps(grandchild, {
                  modelValue: $props.form[grandchild.handle],
                  "onUpdate:modelValue": ($event) => $props.form[grandchild.handle] = $event,
                  form: $props.form,
                  errors: $props.form.errors,
                  record: $props.record
                }, require$$0$1.toHandlers(_ctx.$listeners), { key: index2 }), {
                  default: require$$0$1.withCtx(() => [
                    $props.debug ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("span", _hoisted_3$2, require$$0$1.toDisplayString(grandchild.component), 1)) : require$$0$1.createCommentVNode("", true),
                    require$$0$1.createTextVNode(" " + require$$0$1.toDisplayString(grandchild.text), 1)
                  ], void 0, true),
                  _: 2
                }, 1040, ["modelValue", "onUpdate:modelValue", "form", "errors", "record"])), [
                  [require$$0$1.vShow, !grandchild.hide]
                ]);
              }), 128)) : require$$0$1.createCommentVNode("", true)
            ], void 0, true),
            _: 2
          }, 1040, ["modelValue", "onUpdate:modelValue", "form", "errors", "record"])), [
            [require$$0$1.vShow, !childComponent.hide]
          ]);
        }), 128)) : require$$0$1.createCommentVNode("", true)
      ], void 0, true),
      _: 1
    }, 16, ["form", "errors"]);
  }
  const NestedComponent = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
  const NestedComponent$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: NestedComponent
  }, Symbol.toStringTag, { value: "Module" }));
  var dayjs_min = { exports: {} };
  (function(module2, exports2) {
    !function(t, e) {
      module2.exports = e();
    }(commonjsGlobal, function() {
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a2 = "day", o = "week", f = "month", h = "quarter", c = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: f, y: c, w: o, d: a2, D: d, h: u, m: s, s: i, ms: r, Q: h }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = function(t2) {
        return t2 instanceof _2;
      }, S = function t2(e2, n2, r2) {
        var i2;
        if (!e2)
          return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1)
            return t2(u2[0]);
        } else {
          var a3 = e2.name;
          D[a3] = e2, i2 = a3;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, w = function(t2, e2) {
        if (p(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _2(n2);
      }, O = v;
      O.l = S, O.i = p, O.w = function(t2, e2) {
        return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _2 = function() {
        function M2(t2) {
          this.$L = S(t2.locale, null, true), this.parse(t2);
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return /* @__PURE__ */ new Date(NaN);
            if (O.u(e2))
              return /* @__PURE__ */ new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.$x = t2.x || {}, this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return O;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = w(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return w(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < w(t2);
        }, m2.$g = function(t2, e2, n2) {
          return O.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!O.u(e2) || e2, h2 = O.p(t2), l2 = function(t3, e3) {
            var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a2);
          }, $2 = function(t3, e3) {
            return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (h2) {
            case c:
              return r2 ? l2(1, 0) : l2(31, 11);
            case f:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a2:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = O.p(t2), h2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a2] = h2 + "Date", n2[d] = h2 + "Date", n2[f] = h2 + "Month", n2[c] = h2 + "FullYear", n2[u] = h2 + "Hours", n2[s] = h2 + "Minutes", n2[i] = h2 + "Seconds", n2[r] = h2 + "Milliseconds", n2)[o2], $2 = o2 === a2 ? this.$D + (e2 - this.$W) : e2;
          if (o2 === f || o2 === c) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[O.p(t2)]();
        }, m2.add = function(r2, h2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = O.p(h2), y2 = function(t2) {
            var e2 = w(l2);
            return O.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === f)
            return this.set(f, this.$M + r2);
          if ($2 === c)
            return this.set(c, this.$y + r2);
          if ($2 === a2)
            return y2(1);
          if ($2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return O.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a3 = this.$M, o2 = n2.weekdays, f2 = n2.months, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, c2 = function(t3) {
            return O.s(s2 % 12 || 12, t3, "0");
          }, d2 = n2.meridiem || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          }, $2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O.s(a3 + 1, 2, "0"), MMM: h2(n2.monthsShort, a3, f2, 3), MMMM: h2(f2, a3), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h2(n2.weekdaysMin, this.$W, o2, 2), ddd: h2(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
          return r2.replace(y, function(t3, e3) {
            return e3 || $2[t3] || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, v2 = this - M3, g2 = O.m(this, M3);
          return g2 = ($2 = {}, $2[c] = g2 / 12, $2[f] = g2, $2[h] = g2 / 3, $2[o] = (v2 - m3) / 6048e5, $2[a2] = (v2 - m3) / 864e5, $2[u] = v2 / n, $2[s] = v2 / e, $2[i] = v2 / t, $2)[y2] || v2, l2 ? g2 : O.a(g2);
        }, m2.daysInMonth = function() {
          return this.endOf(f).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = S(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return O.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), T = _2.prototype;
      return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a2], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
        T[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), w.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _2, w), t2.$i = true), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
        return w(1e3 * t2);
      }, w.en = D[g], w.Ls = D, w.p = {}, w;
    });
  })(dayjs_min);
  var dayjs_minExports = dayjs_min.exports;
  const dayjs = /* @__PURE__ */ getDefaultExportFromCjs(dayjs_minExports);
  const _sfc_main$h = {
    props: {
      id: {
        required: true,
        type: String
      },
      bulk: {
        type: Boolean,
        default: true
      },
      refresh: {
        type: Number | Boolean,
        default: false
      },
      noRecords: {
        type: String,
        default: "No records to display"
      },
      endpoint: {
        required: true,
        type: String
      },
      sortBy: {
        type: String,
        default: "id"
      },
      saveSortBy: {
        type: Boolean,
        default: true
      },
      perPage: {
        type: Number,
        default: 10
      },
      sortIn: {
        type: String,
        default: "asc"
      },
      noSearch: {
        type: Boolean,
        default: false
      },
      primaryKey: {
        required: false,
        type: String,
        default: "id"
      },
      showPageStatus: {
        type: Boolean,
        default: false
      },
      showPageNumbers: {
        type: Boolean,
        default: false
      },
      showPageNav: {
        type: Boolean,
        default: false
      },
      showPageEnds: {
        type: Boolean,
        default: false
      },
      hidePageSelect: {
        type: Boolean,
        default: false
      },
      pageSelectLabel: {
        type: String,
        default: "Page"
      },
      reorder_route: {
        type: String,
        default: ""
      },
      link_name: {
        type: String,
        default: ""
      },
      link_param: {
        type: String,
        default: ""
      },
      show_status: {
        type: Boolean,
        default: false
      },
      show_order: {
        type: Boolean,
        default: true
      },
      actions: {}
    },
    data() {
      return {
        dateRange: {
          startDate: /* @__PURE__ */ new Date(),
          endDate: /* @__PURE__ */ new Date()
        }
      };
    },
    computed: {
      reportEndpoint() {
        if (this.dateRange.startDate && this.dateRange.endDate) {
          let from = dayjs(this.dateRange.startDate).format("YYYY-MM-DD");
          let to = dayjs(this.dateRange.endDate).format("YYYY-MM-DD");
          return this.endpoint + "/from/" + from + "/to/" + to;
        } else {
          return this.endpoint;
        }
      }
    },
    mounted() {
      bus().$on("refresh", () => {
        this.reload();
      });
    },
    methods: {
      reload() {
        bus().$emit("refresh-datatable-" + this.id);
      }
    }
  };
  const _hoisted_1$a = {
    key: 0,
    class: "flex"
  };
  function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_date_range_picker = require$$0$1.resolveComponent("date-range-picker");
    const _component_ui_table = require$$0$1.resolveComponent("ui-table");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      require$$0$1.createVNode(_component_date_range_picker, {
        opens: "right",
        showDropdowns: true,
        autoApply: true,
        modelValue: $data.dateRange,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.dateRange = $event)
      }, null, 8, ["modelValue"]),
      require$$0$1.createVNode(_component_ui_table, require$$0$1.mergeProps(_ctx.$props, { endpoint: $options.reportEndpoint }), {
        actions: require$$0$1.withCtx((table) => [
          table.record.actions ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_1$a, [
            (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList(table.record.actions, (action, index) => {
              return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(action.component), require$$0$1.mergeProps(action, {
                onUpdated: $options.reload,
                key: index
              }), {
                default: require$$0$1.withCtx(() => [
                  require$$0$1.createTextVNode(require$$0$1.toDisplayString(action.text), 1)
                ], void 0, true),
                _: 2
              }, 1040, ["onUpdated"]);
            }), 128))
          ])) : require$$0$1.createCommentVNode("", true)
        ]),
        _: 1
      }, 16, ["endpoint"])
    ]);
  }
  const ReportDataTable = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
  const ReportDataTable$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: ReportDataTable
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$g = {
    emits: [],
    props: {
      id: {
        required: true,
        type: String
      },
      bulk: {
        type: Boolean,
        default: true
      },
      metrics: {},
      filters: {},
      refresh: {
        type: [Number, Boolean],
        default: false
      },
      noRecords: {
        type: String,
        default: "No records to display"
      },
      endpoint: {
        required: true,
        type: String
      },
      sortBy: {
        type: String,
        default: "id"
      },
      saveSortBy: {
        type: Boolean,
        default: true
      },
      perPage: {
        type: Number,
        default: 10
      },
      sortIn: {
        type: String,
        default: "asc"
      },
      noSearch: {
        type: Boolean,
        default: false
      },
      primaryKey: {
        required: false,
        type: String,
        default: "id"
      },
      showPageStatus: {
        type: Boolean,
        default: false
      },
      showPageNumbers: {
        type: Boolean,
        default: false
      },
      showPageNav: {
        type: Boolean,
        default: false
      },
      showPageEnds: {
        type: Boolean,
        default: false
      },
      hidePageSelect: {
        type: Boolean,
        default: false
      },
      pageSelectLabel: {
        type: String,
        default: "Page"
      },
      reorder_route: {
        type: String,
        default: ""
      },
      link_name: {
        type: String,
        default: ""
      },
      link_param: {
        type: String,
        default: ""
      },
      show_status: {
        type: Boolean,
        default: false
      },
      show_order: {
        type: Boolean,
        default: true
      },
      actions: {}
    },
    watch: {
      showBulkActionConfirmation(value) {
        if (value == false) {
          this.action = null;
        }
      }
    },
    data() {
      return {
        filterValues: {},
        metricValues: {},
        form: null,
        action: null,
        fields: [],
        working: false,
        showBulkActionConfirmation: false
      };
    },
    computed: {},
    mounted() {
      bus().$on("refresh", () => {
        this.reload();
      });
    },
    methods: {
      updateMetrics(metricValues) {
        this.metricValues = metricValues;
      },
      cancelBulkAction(dataTable) {
        this.action = null;
        this.showBulkActionConfirmation = false;
      },
      confirmBulkAction(dataTable) {
        let action = dataTable.allowedBulkActions[this.action];
        let vm2 = this;
        let formData = this.form.formdata();
        dataTable.selected.forEach((selected) => {
          formData.append("records[]", selected);
        });
        this.working = true;
        this.form.submit("post", `${action.route}`, formData).then((response) => {
          toast("Bulk action completed successfully.", "success");
          dataTable.selected = [];
          vm2.reload();
          vm2.showBulkActionConfirmation = false;
          vm2.action = null;
          vm2.working = false;
        }).catch((error) => {
          vm2.working = false;
          if (error.errors) {
            var message = Object.keys(error.errors).map((key) => {
              return error.errors[key].join(" ");
            }).join(" ");
            toast(message, "failed");
          } else {
            toast(error.message, "failed");
          }
        });
      },
      initForm(dataTable) {
        let action = dataTable.allowedBulkActions[this.action];
        if (action.params) {
          let fields = {};
          action.params.fields.forEach((field) => {
            fields[field.handle] = null;
          });
          this.form = new Form(fields);
        }
      },
      reload() {
        bus().$emit("refresh-datatable-" + this.id);
      }
    }
  };
  const _hoisted_1$9 = { class: "flex" };
  const _hoisted_2$4 = { class: "ml-auto" };
  const _hoisted_3$1 = ["onChange"];
  const _hoisted_4$1 = /* @__PURE__ */ require$$0$1.createElementVNode("option", {
    selected: "",
    disabled: "",
    value: null
  }, "Bulk Actions", -1);
  const _hoisted_5$1 = ["value"];
  const _hoisted_6$1 = { key: 0 };
  const _hoisted_7$1 = { key: 0 };
  const _hoisted_8 = { key: 1 };
  const _hoisted_9 = {
    key: 0,
    class: "flex"
  };
  function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ui_button = require$$0$1.resolveComponent("ui-button");
    const _component_ui_modal = require$$0$1.resolveComponent("ui-modal");
    const _component_portal = require$$0$1.resolveComponent("portal");
    const _component_antfusion_datatable = require$$0$1.resolveComponent("antfusion-datatable");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      require$$0$1.createElementVNode("div", _hoisted_1$9, [
        (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($props.metrics, (card) => {
          return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(card.component), require$$0$1.mergeProps(card, {
            key: card.handle
          }, {
            modelValue: $data.metricValues[card.handle],
            "onUpdate:modelValue": ($event) => $data.metricValues[card.handle] = $event
          }), null, 16, ["modelValue", "onUpdate:modelValue"]);
        }), 128))
      ]),
      (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($props.filters, (filter) => {
        return require$$0$1.openBlock(), require$$0$1.createElementBlock("span", {
          key: filter.handle
        }, [
          !filter.builtin ? (require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(filter.component), require$$0$1.mergeProps({ key: 0 }, filter, {
            modelValue: $data.filterValues[filter.handle],
            "onUpdate:modelValue": ($event) => $data.filterValues[filter.handle] = $event
          }), null, 16, ["modelValue", "onUpdate:modelValue"])) : require$$0$1.createCommentVNode("", true)
        ]);
      }), 128)),
      require$$0$1.createVNode(_component_antfusion_datatable, require$$0$1.mergeProps(_ctx.$props, {
        filters: $data.filterValues,
        onUpdateMetrics: $options.updateMetrics
      }), {
        bulkActions: require$$0$1.withCtx(({ parent }) => [
          require$$0$1.createElementVNode("div", _hoisted_2$4, [
            require$$0$1.withDirectives(require$$0$1.createElementVNode("select", {
              name: "bulk-actions",
              id: "bulk-actions",
              class: "field-select field-select--sm field-select--bordered",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.action = $event),
              onChange: ($event) => {
                $options.initForm(parent);
                $data.showBulkActionConfirmation = true;
              }
            }, [
              _hoisted_4$1,
              (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList(parent.allowedBulkActions, (action, index) => {
                return require$$0$1.openBlock(), require$$0$1.createElementBlock("option", {
                  key: action.name,
                  value: index
                }, require$$0$1.toDisplayString(action.name), 9, _hoisted_5$1);
              }), 128))
            ], 40, _hoisted_3$1), [
              [require$$0$1.vModelSelect, $data.action]
            ])
          ]),
          require$$0$1.createVNode(_component_portal, { to: "modals" }, {
            default: require$$0$1.withCtx(() => [
              $data.action !== null ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_modal, {
                key: 0,
                name: "confirm-bulk-action",
                title: "Confirm Bulk " + parent.allowedBulkActions[$data.action].name,
                modelValue: $data.showBulkActionConfirmation,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => $data.showBulkActionConfirmation = $event)
              }, {
                footer: require$$0$1.withCtx(() => [
                  require$$0$1.createVNode(_component_ui_button, {
                    onClick: require$$0$1.withModifiers(($event) => $options.confirmBulkAction(parent), ["prevent"]),
                    loading: $data.working,
                    class: "ml-3",
                    variant: "primary"
                  }, {
                    default: require$$0$1.withCtx(() => [
                      require$$0$1.createTextVNode("Confirm")
                    ], void 0, true),
                    _: 2
                  }, 1032, ["onClick", "loading"]),
                  !$data.working ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_button, {
                    key: 0,
                    onClick: require$$0$1.withModifiers(($event) => $options.cancelBulkAction(parent), ["prevent"]),
                    variant: "secondary"
                  }, {
                    default: require$$0$1.withCtx(() => [
                      require$$0$1.createTextVNode("Cancel")
                    ], void 0, true),
                    _: 2
                  }, 1032, ["onClick"])) : require$$0$1.createCommentVNode("", true)
                ]),
                default: require$$0$1.withCtx(() => [
                  parent.allowedBulkActions[$data.action].params && parent.allowedBulkActions[$data.action].params.fields.length ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_6$1, [
                    $data.form ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("span", _hoisted_7$1, [
                      (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList(parent.allowedBulkActions[$data.action].params.fields, (field, index) => {
                        return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(field.component), require$$0$1.mergeProps(field, {
                          modelValue: $data.form[field.handle],
                          "onUpdate:modelValue": ($event) => $data.form[field.handle] = $event,
                          key: field.handle
                        }, {
                          parent: _ctx.componentData,
                          record: _ctx.record,
                          "has-error": $data.form.errors.has(field.handle),
                          "error-message": $data.form.errors.get(field.handle),
                          errors: $data.form.errors
                        }), null, 16, ["modelValue", "onUpdate:modelValue", "parent", "record", "has-error", "error-message", "errors"]);
                      }), 128))
                    ])) : require$$0$1.createCommentVNode("", true)
                  ])) : (require$$0$1.openBlock(), require$$0$1.createElementBlock("p", _hoisted_8, [
                    require$$0$1.createTextVNode("Are you sure you want to perform this action against "),
                    require$$0$1.createElementVNode("b", null, require$$0$1.toDisplayString(parent.selected.length), 1),
                    require$$0$1.createTextVNode(" record" + require$$0$1.toDisplayString(parent.selected.length > 1 ? "s" : "") + "?", 1)
                  ]))
                ], void 0, true),
                _: 2
              }, 1032, ["title", "modelValue"])) : require$$0$1.createCommentVNode("", true)
            ], void 0, true),
            _: 2
          }, 1024)
        ]),
        actions: require$$0$1.withCtx((table) => [
          table.record.actions && table.record.actions.length ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_9, [
            (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList(table.record.actions, (action, index) => {
              return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(action.component), require$$0$1.mergeProps(action, {
                record: table.record,
                onSubmitted: $options.reload,
                onUpdated: $options.reload,
                key: index
              }), {
                default: require$$0$1.withCtx(() => [
                  require$$0$1.createTextVNode(require$$0$1.toDisplayString(action.text), 1)
                ], void 0, true),
                _: 2
              }, 1040, ["record", "onSubmitted", "onUpdated"]);
            }), 128))
          ])) : require$$0$1.createCommentVNode("", true)
        ]),
        _: 1
      }, 16, ["filters", "onUpdateMetrics"])
    ]);
  }
  const ResourceDataTable = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
  const ResourceDataTable$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: ResourceDataTable
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$f = {
    props: {
      value: {}
    }
  };
  function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ui_datetime = require$$0$1.resolveComponent("ui-datetime");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      require$$0$1.createVNode(_component_ui_datetime, { timestamp: $props.value }, null, 8, ["timestamp"])
    ]);
  }
  const ResourceDateTime = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
  const ResourceDateTime$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: ResourceDateTime
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$e = {
    props: {
      value: {}
    }
  };
  function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ui_date = require$$0$1.resolveComponent("ui-date");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      require$$0$1.createVNode(_component_ui_date, { timestamp: $props.value }, null, 8, ["timestamp"])
    ]);
  }
  const ResourceDate = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
  const ResourceDate$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: ResourceDate
  }, Symbol.toStringTag, { value: "Module" }));
  function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var pluralize = { exports: {} };
  (function(module2, exports2) {
    (function(root, pluralize2) {
      if (typeof commonjsRequire === "function" && true && true) {
        module2.exports = pluralize2();
      } else {
        root.pluralize = pluralize2();
      }
    })(commonjsGlobal, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      function restoreCase(word, token2) {
        if (word === token2)
          return token2;
        if (word === word.toLowerCase())
          return token2.toLowerCase();
        if (word === word.toUpperCase())
          return token2.toUpperCase();
        if (word[0] === word[0].toUpperCase()) {
          return token2.charAt(0).toUpperCase() + token2.substr(1).toLowerCase();
        }
        return token2.toLowerCase();
      }
      function interpolate(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match, index) {
          return args[index] || "";
        });
      }
      function replace(word, rule) {
        return word.replace(rule[0], function(match, index) {
          var result = interpolate(rule[1], arguments);
          if (match === "") {
            return restoreCase(word[index - 1], result);
          }
          return restoreCase(match, result);
        });
      }
      function sanitizeWord(token2, word, rules) {
        if (!token2.length || uncountables.hasOwnProperty(token2)) {
          return word;
        }
        var len = rules.length;
        while (len--) {
          var rule = rules[len];
          if (rule[0].test(word))
            return replace(word, rule);
        }
        return word;
      }
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) {
            return restoreCase(word, token2);
          }
          if (replaceMap.hasOwnProperty(token2)) {
            return restoreCase(word, replaceMap[token2]);
          }
          return sanitizeWord(token2, word, rules);
        };
      }
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2))
            return true;
          if (replaceMap.hasOwnProperty(token2))
            return false;
          return sanitizeWord(token2, token2, rules) === token2;
        };
      }
      function pluralize2(word, count, inclusive) {
        var pluralized = count === 1 ? pluralize2.singular(word) : pluralize2.plural(word);
        return (inclusive ? count + " " : "") + pluralized;
      }
      pluralize2.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.isPlural = checkWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize2.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.isSingular = checkWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize2.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize2.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize2.addPluralRule(word, "$0");
        pluralize2.addSingularRule(word, "$0");
      };
      pluralize2.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["passerby", "passersby"]
      ].forEach(function(rule) {
        return pluralize2.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/\b((?:tit)?m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize2.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/\b((?:tit)?m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i, "$1"],
        [/(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i, "$1sis"],
        [/(movie|twelve|abuse|e[mn]u)s$/i, "$1"],
        [/(test)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize2.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "aircraft",
        "alcohol",
        "ammo",
        "analytics",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "firmware",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "hardware",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "mud",
        "manga",
        "news",
        "only",
        "personnel",
        "pike",
        "plankton",
        "pliers",
        "police",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "software",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transportation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        /pok[eé]mon$/i,
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(pluralize2.addUncountableRule);
      return pluralize2;
    });
  })(pluralize);
  const FieldMixin = {
    props: {
      field: {
        type: Object,
        required: true
      },
      value: {
        required: false,
        default: null
      },
      errors: {
        type: Object,
        required: false,
        default: () => {
        }
      }
    },
    computed: {
      model: {
        get() {
          return this.value;
        },
        set(value) {
          this.$emit("input", value);
        }
      }
    },
    methods: {
      hasError(handle) {
        return this.errors && this.errors.has(handle);
      },
      errorMessage(handle) {
        return this.hasError(handle) ? this.errors.get(handle) : "";
      }
    }
  };
  var vue3Treeselect_common = { exports: {} };
  (function(module2) {
    (function() {
      var __webpack_modules__ = {
        /***/
        390: (
          /***/
          function(module3) {
            function fuzzysearch(needle, haystack) {
              var tlen = haystack.length;
              var qlen = needle.length;
              if (qlen > tlen) {
                return false;
              }
              if (qlen === tlen) {
                return needle === haystack;
              }
              outer:
                for (var i = 0, j = 0; i < qlen; i++) {
                  var nch = needle.charCodeAt(i);
                  while (j < tlen) {
                    if (haystack.charCodeAt(j++) === nch) {
                      continue outer;
                    }
                  }
                  return false;
                }
              return true;
            }
            module3.exports = fuzzysearch;
          }
        ),
        /***/
        705: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var root = __webpack_require__2(639);
            var Symbol2 = root.Symbol;
            module3.exports = Symbol2;
          }
        ),
        /***/
        239: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var Symbol2 = __webpack_require__2(705), getRawTag = __webpack_require__2(607), objectToString = __webpack_require__2(333);
            var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
            var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
            function baseGetTag(value) {
              if (value == null) {
                return value === void 0 ? undefinedTag : nullTag;
              }
              return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
            }
            module3.exports = baseGetTag;
          }
        ),
        /***/
        561: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var trimmedEndIndex = __webpack_require__2(990);
            var reTrimStart = /^\s+/;
            function baseTrim(string) {
              return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
            }
            module3.exports = baseTrim;
          }
        ),
        /***/
        957: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var freeGlobal = typeof __webpack_require__2.g == "object" && __webpack_require__2.g && __webpack_require__2.g.Object === Object && __webpack_require__2.g;
            module3.exports = freeGlobal;
          }
        ),
        /***/
        607: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var Symbol2 = __webpack_require__2(705);
            var objectProto = Object.prototype;
            var hasOwnProperty2 = objectProto.hasOwnProperty;
            var nativeObjectToString = objectProto.toString;
            var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
            function getRawTag(value) {
              var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
              try {
                value[symToStringTag] = void 0;
                var unmasked = true;
              } catch (e) {
              }
              var result = nativeObjectToString.call(value);
              if (unmasked) {
                if (isOwn) {
                  value[symToStringTag] = tag;
                } else {
                  delete value[symToStringTag];
                }
              }
              return result;
            }
            module3.exports = getRawTag;
          }
        ),
        /***/
        333: (
          /***/
          function(module3) {
            var objectProto = Object.prototype;
            var nativeObjectToString = objectProto.toString;
            function objectToString(value) {
              return nativeObjectToString.call(value);
            }
            module3.exports = objectToString;
          }
        ),
        /***/
        639: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var freeGlobal = __webpack_require__2(957);
            var freeSelf = typeof self == "object" && self && self.Object === Object && self;
            var root = freeGlobal || freeSelf || Function("return this")();
            module3.exports = root;
          }
        ),
        /***/
        990: (
          /***/
          function(module3) {
            var reWhitespace = /\s/;
            function trimmedEndIndex(string) {
              var index = string.length;
              while (index-- && reWhitespace.test(string.charAt(index))) {
              }
              return index;
            }
            module3.exports = trimmedEndIndex;
          }
        ),
        /***/
        567: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var toInteger = __webpack_require__2(554);
            var FUNC_ERROR_TEXT = "Expected a function";
            function before(n, func) {
              var result;
              if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              n = toInteger(n);
              return function() {
                if (--n > 0) {
                  result = func.apply(this, arguments);
                }
                if (n <= 1) {
                  func = void 0;
                }
                return result;
              };
            }
            module3.exports = before;
          }
        ),
        /***/
        703: (
          /***/
          function(module3) {
            function constant(value) {
              return function() {
                return value;
              };
            }
            module3.exports = constant;
          }
        ),
        /***/
        279: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var isObject2 = __webpack_require__2(218), now2 = __webpack_require__2(771), toNumber = __webpack_require__2(841);
            var FUNC_ERROR_TEXT = "Expected a function";
            var nativeMax = Math.max, nativeMin = Math.min;
            function debounce2(func, wait, options) {
              var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
              if (typeof func != "function") {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              wait = toNumber(wait) || 0;
              if (isObject2(options)) {
                leading = !!options.leading;
                maxing = "maxWait" in options;
                maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                trailing = "trailing" in options ? !!options.trailing : trailing;
              }
              function invokeFunc(time) {
                var args = lastArgs, thisArg = lastThis;
                lastArgs = lastThis = void 0;
                lastInvokeTime = time;
                result = func.apply(thisArg, args);
                return result;
              }
              function leadingEdge(time) {
                lastInvokeTime = time;
                timerId = setTimeout(timerExpired, wait);
                return leading ? invokeFunc(time) : result;
              }
              function remainingWait(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
              }
              function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
              }
              function timerExpired() {
                var time = now2();
                if (shouldInvoke(time)) {
                  return trailingEdge(time);
                }
                timerId = setTimeout(timerExpired, remainingWait(time));
              }
              function trailingEdge(time) {
                timerId = void 0;
                if (trailing && lastArgs) {
                  return invokeFunc(time);
                }
                lastArgs = lastThis = void 0;
                return result;
              }
              function cancel() {
                if (timerId !== void 0) {
                  clearTimeout(timerId);
                }
                lastInvokeTime = 0;
                lastArgs = lastCallTime = lastThis = timerId = void 0;
              }
              function flush() {
                return timerId === void 0 ? result : trailingEdge(now2());
              }
              function debounced() {
                var time = now2(), isInvoking = shouldInvoke(time);
                lastArgs = arguments;
                lastThis = this;
                lastCallTime = time;
                if (isInvoking) {
                  if (timerId === void 0) {
                    return leadingEdge(lastCallTime);
                  }
                  if (maxing) {
                    clearTimeout(timerId);
                    timerId = setTimeout(timerExpired, wait);
                    return invokeFunc(lastCallTime);
                  }
                }
                if (timerId === void 0) {
                  timerId = setTimeout(timerExpired, wait);
                }
                return result;
              }
              debounced.cancel = cancel;
              debounced.flush = flush;
              return debounced;
            }
            module3.exports = debounce2;
          }
        ),
        /***/
        557: (
          /***/
          function(module3) {
            function identity(value) {
              return value;
            }
            module3.exports = identity;
          }
        ),
        /***/
        218: (
          /***/
          function(module3) {
            function isObject2(value) {
              var type = typeof value;
              return value != null && (type == "object" || type == "function");
            }
            module3.exports = isObject2;
          }
        ),
        /***/
        5: (
          /***/
          function(module3) {
            function isObjectLike(value) {
              return value != null && typeof value == "object";
            }
            module3.exports = isObjectLike;
          }
        ),
        /***/
        448: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var baseGetTag = __webpack_require__2(239), isObjectLike = __webpack_require__2(5);
            var symbolTag = "[object Symbol]";
            function isSymbol(value) {
              return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
            }
            module3.exports = isSymbol;
          }
        ),
        /***/
        928: (
          /***/
          function(module3) {
            function last(array) {
              var length = array == null ? 0 : array.length;
              return length ? array[length - 1] : void 0;
            }
            module3.exports = last;
          }
        ),
        /***/
        308: (
          /***/
          function(module3) {
            function noop() {
            }
            module3.exports = noop;
          }
        ),
        /***/
        771: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var root = __webpack_require__2(639);
            var now2 = function() {
              return root.Date.now();
            };
            module3.exports = now2;
          }
        ),
        /***/
        463: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var before = __webpack_require__2(567);
            function once(func) {
              return before(2, func);
            }
            module3.exports = once;
          }
        ),
        /***/
        601: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var toNumber = __webpack_require__2(841);
            var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
            function toFinite(value) {
              if (!value) {
                return value === 0 ? value : 0;
              }
              value = toNumber(value);
              if (value === INFINITY || value === -INFINITY) {
                var sign = value < 0 ? -1 : 1;
                return sign * MAX_INTEGER;
              }
              return value === value ? value : 0;
            }
            module3.exports = toFinite;
          }
        ),
        /***/
        554: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var toFinite = __webpack_require__2(601);
            function toInteger(value) {
              var result = toFinite(value), remainder = result % 1;
              return result === result ? remainder ? result - remainder : result : 0;
            }
            module3.exports = toInteger;
          }
        ),
        /***/
        841: (
          /***/
          function(module3, __unused_webpack_exports, __webpack_require__2) {
            var baseTrim = __webpack_require__2(561), isObject2 = __webpack_require__2(218), isSymbol = __webpack_require__2(448);
            var NAN = 0 / 0;
            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
            var reIsBinary = /^0b[01]+$/i;
            var reIsOctal = /^0o[0-7]+$/i;
            var freeParseInt = parseInt;
            function toNumber(value) {
              if (typeof value == "number") {
                return value;
              }
              if (isSymbol(value)) {
                return NAN;
              }
              if (isObject2(value)) {
                var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                value = isObject2(other) ? other + "" : other;
              }
              if (typeof value != "string") {
                return value === 0 ? value : +value;
              }
              value = baseTrim(value);
              var isBinary = reIsBinary.test(value);
              return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
            }
            module3.exports = toNumber;
          }
        ),
        /***/
        744: (
          /***/
          function(__unused_webpack_module, exports2) {
            exports2.Z = (sfc, props) => {
              const target = sfc.__vccOpts || sfc;
              for (const [key, val] of props) {
                target[key] = val;
              }
              return target;
            };
          }
        )
        /******/
      };
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module3 = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        __webpack_modules__[moduleId](module3, module3.exports, __webpack_require__);
        return module3.exports;
      }
      !function() {
        __webpack_require__.n = function(module3) {
          var getter = module3 && module3.__esModule ? (
            /******/
            function() {
              return module3["default"];
            }
          ) : (
            /******/
            function() {
              return module3;
            }
          );
          __webpack_require__.d(getter, { a: getter });
          return getter;
        };
      }();
      !function() {
        __webpack_require__.d = function(exports2, definition) {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      }();
      !function() {
        __webpack_require__.g = function() {
          if (typeof globalThis === "object")
            return globalThis;
          try {
            return this || new Function("return this")();
          } catch (e) {
            if (typeof window === "object")
              return window;
          }
        }();
      }();
      !function() {
        __webpack_require__.o = function(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        };
      }();
      !function() {
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
      }();
      !function() {
        __webpack_require__.p = "";
      }();
      var __webpack_exports__ = {};
      !function() {
        __webpack_require__.r(__webpack_exports__);
        __webpack_require__.d(__webpack_exports__, {
          "ASYNC_SEARCH": function() {
            return (
              /* reexport */
              ASYNC_SEARCH
            );
          },
          "LOAD_CHILDREN_OPTIONS": function() {
            return (
              /* reexport */
              LOAD_CHILDREN_OPTIONS
            );
          },
          "LOAD_ROOT_OPTIONS": function() {
            return (
              /* reexport */
              LOAD_ROOT_OPTIONS
            );
          },
          "Treeselect": function() {
            return (
              /* reexport */
              Treeselect2
            );
          },
          "default": function() {
            return (
              /* binding */
              entry_lib
            );
          },
          "treeselectMixin": function() {
            return (
              /* reexport */
              treeselectMixin
            );
          }
        });
        if (typeof window !== "undefined") {
          var currentScript = window.document.currentScript;
          var src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/);
          if (src) {
            __webpack_require__.p = src[1];
          }
        }
        var external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject = require$$0$1;
        function render(_ctx, _cache, $props, $setup, $data, $options) {
          var _component_HiddenFields = (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.resolveComponent)("HiddenFields");
          var _component_Control = (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.resolveComponent)("Control");
          var _component_MenuPortal = (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.resolveComponent)("MenuPortal");
          var _component_Menu = (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.resolveComponent)("Menu");
          return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createElementBlock)("div", {
            ref: "wrapper",
            class: (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.normalizeClass)(_ctx.wrapperClass)
          }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(_component_HiddenFields), (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(_component_Control, {
            ref: "control"
          }, null, 512), _ctx.appendToBody ? ((0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createBlock)(_component_MenuPortal, {
            key: 0,
            ref: "portal"
          }, null, 512)) : ((0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createBlock)(_component_Menu, {
            key: 1,
            ref: "menu"
          }, null, 512))], 2);
        }
        var fuzzysearch = __webpack_require__(390);
        var fuzzysearch_default = /* @__PURE__ */ __webpack_require__.n(fuzzysearch);
        function isNaN_isNaN(x) {
          return x !== x;
        }
        function includes(arrOrStr, elem) {
          return arrOrStr.indexOf(elem) !== -1;
        }
        var constant = __webpack_require__(703);
        var constant_default = /* @__PURE__ */ __webpack_require__.n(constant);
        var identity = __webpack_require__(557);
        var identity_default = /* @__PURE__ */ __webpack_require__.n(identity);
        var createMap = function createMap2() {
          return /* @__PURE__ */ Object.create(null);
        };
        function quickDiff(arrA, arrB) {
          if (arrA.length !== arrB.length)
            return true;
          for (var i = 0; i < arrA.length; i++) {
            if (arrA[i] !== arrB[i])
              return true;
          }
          return false;
        }
        var noop = __webpack_require__(308);
        var noop_default = /* @__PURE__ */ __webpack_require__.n(noop);
        var warning = (
          /* istanbul ignore next */
          noop_default()
        );
        function find(arr, predicate, ctx) {
          for (var i = 0, len = arr.length; i < len; i++) {
            if (predicate.call(ctx, arr[i], i, arr))
              return arr[i];
          }
          return void 0;
        }
        function onLeftClick(mouseDownHandler) {
          return function onMouseDown(evt) {
            if (evt.type === "mousedown" && evt.button === 0) {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              mouseDownHandler.call.apply(mouseDownHandler, [this, evt].concat(args));
            }
          };
        }
        function scrollIntoView($scrollingEl, $focusedEl) {
          var scrollingReact = $scrollingEl.getBoundingClientRect();
          var focusedRect = $focusedEl.getBoundingClientRect();
          var overScroll = $focusedEl.offsetHeight / 3;
          if (focusedRect.bottom + overScroll > scrollingReact.bottom) {
            $scrollingEl.scrollTop = Math.min($focusedEl.offsetTop + $focusedEl.clientHeight - $scrollingEl.offsetHeight + overScroll, $scrollingEl.scrollHeight);
          } else if (focusedRect.top - overScroll < scrollingReact.top) {
            $scrollingEl.scrollTop = Math.max($focusedEl.offsetTop - overScroll, 0);
          }
        }
        var lodash_last = __webpack_require__(928);
        var last_default = /* @__PURE__ */ __webpack_require__.n(lodash_last);
        var once = __webpack_require__(463);
        var once_default = /* @__PURE__ */ __webpack_require__.n(once);
        function isPromise2(obj) {
          return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
        }
        function removeFromArray(arr, elem) {
          var idx = arr.indexOf(elem);
          if (idx !== -1)
            arr.splice(idx, 1);
        }
        var NO_PARENT_NODE = null;
        var UNCHECKED = 0;
        var INDETERMINATE = 1;
        var CHECKED = 2;
        var ALL_CHILDREN = "ALL_CHILDREN";
        var ALL_DESCENDANTS = "ALL_DESCENDANTS";
        var LEAF_CHILDREN = "LEAF_CHILDREN";
        var LEAF_DESCENDANTS = "LEAF_DESCENDANTS";
        var LOAD_ROOT_OPTIONS = "LOAD_ROOT_OPTIONS";
        var LOAD_CHILDREN_OPTIONS = "LOAD_CHILDREN_OPTIONS";
        var ASYNC_SEARCH = "ASYNC_SEARCH";
        var ALL = "ALL";
        var BRANCH_PRIORITY = "BRANCH_PRIORITY";
        var LEAF_PRIORITY = "LEAF_PRIORITY";
        var ALL_WITH_INDETERMINATE = "ALL_WITH_INDETERMINATE";
        var ORDER_SELECTED = "ORDER_SELECTED";
        var LEVEL = "LEVEL";
        var INDEX = "INDEX";
        var KEY_CODES = {
          BACKSPACE: 8,
          ENTER: 13,
          ESCAPE: 27,
          END: 35,
          HOME: 36,
          ARROW_LEFT: 37,
          ARROW_UP: 38,
          ARROW_RIGHT: 39,
          ARROW_DOWN: 40,
          DELETE: 46
        };
        var INPUT_DEBOUNCE_DELAY = (
          /* istanbul ignore next */
          200
        );
        var MIN_INPUT_WIDTH = 5;
        var MENU_BUFFER = 40;
        function _slicedToArray(arr, i) {
          return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || treeselectMixin_unsupportedIterableToArray(arr, i) || _nonIterableRest();
        }
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _iterableToArrayLimit(arr, i) {
          var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
          if (_i == null)
            return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _s, _e;
          try {
            for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null)
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        function _arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        function treeselectMixin_toConsumableArray(arr) {
          return treeselectMixin_arrayWithoutHoles(arr) || treeselectMixin_iterableToArray(arr) || treeselectMixin_unsupportedIterableToArray(arr) || treeselectMixin_nonIterableSpread();
        }
        function treeselectMixin_nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function treeselectMixin_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return treeselectMixin_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return treeselectMixin_arrayLikeToArray(o, minLen);
        }
        function treeselectMixin_iterableToArray(iter) {
          if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
            return Array.from(iter);
        }
        function treeselectMixin_arrayWithoutHoles(arr) {
          if (Array.isArray(arr))
            return treeselectMixin_arrayLikeToArray(arr);
        }
        function treeselectMixin_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function _objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function _defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function sortValueByIndex(a2, b) {
          var i = 0;
          do {
            if (a2.level < i)
              return -1;
            if (b.level < i)
              return 1;
            if (a2.index[i] !== b.index[i])
              return a2.index[i] - b.index[i];
            i++;
          } while (true);
        }
        function sortValueByLevel(a2, b) {
          return a2.level === b.level ? sortValueByIndex(a2, b) : a2.level - b.level;
        }
        function createAsyncOptionsStates() {
          return {
            isLoaded: false,
            isLoading: false,
            loadingError: ""
          };
        }
        function stringifyOptionPropValue(value) {
          if (typeof value === "string")
            return value;
          if (typeof value === "number" && !isNaN_isNaN(value))
            return value + "";
          return "";
        }
        function toLowerCaseNonAccentVietnamese(str) {
          str = str.toLowerCase();
          str = str.replace(/à|á|ạ|ả|ã|â|ầ|ấ|ậ|ẩ|ẫ|ă|ằ|ắ|ặ|ẳ|ẵ/g, "a");
          str = str.replace(/è|é|ẹ|ẻ|ẽ|ê|ề|ế|ệ|ể|ễ/g, "e");
          str = str.replace(/ì|í|ị|ỉ|ĩ/g, "i");
          str = str.replace(/ò|ó|ọ|ỏ|õ|ô|ồ|ố|ộ|ổ|ỗ|ơ|ờ|ớ|ợ|ở|ỡ/g, "o");
          str = str.replace(/ù|ú|ụ|ủ|ũ|ư|ừ|ứ|ự|ử|ữ/g, "u");
          str = str.replace(/ỳ|ý|ỵ|ỷ|ỹ/g, "y");
          str = str.replace(/đ/g, "d");
          str = str.replace(/\u0300|\u0301|\u0303|\u0309|\u0323/g, "");
          str = str.replace(/\u02C6|\u0306|\u031B/g, "");
          return str;
        }
        function match(enableFuzzyMatch, needle, haystack) {
          var _needle = toLowerCaseNonAccentVietnamese(needle);
          var _haystack = toLowerCaseNonAccentVietnamese(haystack);
          return enableFuzzyMatch ? fuzzysearch_default()(_needle, _haystack) : includes(_haystack, _needle);
        }
        function getErrorMessage(err) {
          return err.message || /* istanbul ignore next */
          String(err);
        }
        var instanceId = 0;
        var treeselectMixin = {
          provide: function provide() {
            return {
              // Enable access to the instance of root component of vue-treeselect
              // across hierarchy.
              instance: this
            };
          },
          props: {
            /**
             * Whether to allow resetting value even if there are disabled selected nodes.
             */
            allowClearingDisabled: {
              type: Boolean,
              default: false
            },
            /**
             * When an ancestor node is selected/deselected, whether its disabled descendants should be selected/deselected.
             * You may want to use this in conjunction with `allowClearingDisabled` prop.
             */
            allowSelectingDisabledDescendants: {
              type: Boolean,
              default: false
            },
            /**
             * Whether the menu should be always open.
             */
            alwaysOpen: {
              type: Boolean,
              default: false
            },
            /**
             * Append the menu to <body />?
             */
            appendToBody: {
              type: Boolean,
              default: false
            },
            /**
             * Width of menu container
             */
            menuContainerStyle: {
              type: String,
              default: void 0
            },
            /**
             * Whether to enable async search mode.
             */
            async: {
              type: Boolean,
              default: false
            },
            /**
             * Automatically focus the component on mount?
             */
            autoFocus: {
              type: Boolean,
              default: false
            },
            /**
             * Automatically load root options on mount. When set to `false`, root options will be loaded when the menu is opened.
             */
            autoLoadRootOptions: {
              type: Boolean,
              default: true
            },
            /**
             * When user deselects a node, automatically deselect its ancestors. Applies to flat mode only.
             */
            autoDeselectAncestors: {
              type: Boolean,
              default: false
            },
            /**
             * When user deselects a node, automatically deselect its descendants. Applies to flat mode only.
             */
            autoDeselectDescendants: {
              type: Boolean,
              default: false
            },
            /**
             * When user selects a node, automatically select its ancestors. Applies to flat mode only.
             */
            autoSelectAncestors: {
              type: Boolean,
              default: false
            },
            /**
             * When user selects a node, automatically select its descendants. Applies to flat mode only.
             */
            autoSelectDescendants: {
              type: Boolean,
              default: false
            },
            /**
             * Whether pressing backspace key removes the last item if there is no text input.
             */
            backspaceRemoves: {
              type: Boolean,
              default: true
            },
            /**
             * Function that processes before clearing all input fields.
             * Return `false` to prevent value from being cleared.
             * @type {function(): (boolean|Promise<boolean>)}
             */
            beforeClearAll: {
              type: Function,
              default: constant_default()(true)
            },
            /**
             * Show branch nodes before leaf nodes?
             */
            branchNodesFirst: {
              type: Boolean,
              default: false
            },
            /**
             * Should cache results of every search request?
             */
            cacheOptions: {
              type: Boolean,
              default: true
            },
            /**
             * Show an "×" button that resets value?
             */
            clearable: {
              type: Boolean,
              default: true
            },
            /**
             * Title for the "×" button when `multiple: true`.
             */
            clearAllText: {
              type: String,
              default: "Clear all"
            },
            /**
             * Whether to clear the search input after selecting.
             * Use only when `multiple` is `true`.
             * For single-select mode, it **always** clears the input after selecting an option regardless of the prop value.
             */
            clearOnSelect: {
              type: Boolean,
              default: false
            },
            /**
             * Title for the "×" button.
             */
            clearValueText: {
              type: String,
              default: "Clear value"
            },
            /**
             * Whether to close the menu after selecting an option?
             * Use only when `multiple` is `true`.
             */
            closeOnSelect: {
              type: Boolean,
              default: true
            },
            /**
             * How many levels of branch nodes should be automatically expanded when loaded.
             * Set `Infinity` to make all branch nodes expanded by default.
             */
            defaultExpandLevel: {
              type: Number,
              default: 0
            },
            /**
             * The default set of options to show before the user starts searching. Used for async search mode.
             * When set to `true`, the results for search query as a empty string will be autoloaded.
             * @type {boolean|node[]}
             */
            defaultOptions: {
              default: false
            },
            /**
             * Whether pressing delete key removes the last item if there is no text input.
             */
            deleteRemoves: {
              type: Boolean,
              default: true
            },
            /**
             * Delimiter to use to join multiple values for the hidden field value.
             */
            delimiter: {
              type: String,
              default: ","
            },
            /**
             * Only show the nodes that match the search value directly, excluding its ancestors.
             *
             * @type {Object}
             */
            flattenSearchResults: {
              type: Boolean,
              default: false
            },
            /**
             * Prevent branch nodes from being selected?
             */
            disableBranchNodes: {
              type: Boolean,
              default: false
            },
            /**
             * Disable the control?
             */
            disabled: {
              type: Boolean,
              default: false
            },
            /**
             * Disable the fuzzy matching functionality?
             */
            disableFuzzyMatching: {
              type: Boolean,
              default: false
            },
            /**
             * Whether to enable flat mode or not. Non-flat mode (default) means:
             *   - Whenever a branch node gets checked, all its children will be checked too
             *   - Whenever a branch node has all children checked, the branch node itself will be checked too
             * Set `true` to disable this mechanism
             */
            flat: {
              type: Boolean,
              default: false
            },
            /**
             * Will be passed with all events as the last param.
             * Useful for identifying events origin.
             */
            instanceId: {
              // Add two trailing "$" to distinguish from explictly specified ids.
              default: function _default() {
                return "".concat(instanceId++, "$$");
              },
              type: [String, Number]
            },
            /**
             * Joins multiple values into a single form field with the `delimiter` (legacy mode).
             */
            joinValues: {
              type: Boolean,
              default: false
            },
            /**
             * Limit the display of selected options.
             * The rest will be hidden within the limitText string.
             */
            limit: {
              type: Number,
              default: Infinity
            },
            /**
             * Function that processes the message shown when selected elements pass the defined limit.
             * @type {function(number): string}
             */
            limitText: {
              type: Function,
              default: function limitTextDefault(count) {
                return "and ".concat(count, " more");
              }
            },
            /**
             * Text displayed when loading options.
             */
            loadingText: {
              type: String,
              default: "Loading..."
            },
            /**
             * Used for dynamically loading options.
             * @type {function({action: string, callback: (function((Error|string)=): void), parentNode: node=, instanceId}): void}
             */
            loadOptions: {
              type: Function
            },
            /**
             * Which node properties to filter on.
             */
            matchKeys: {
              type: Array,
              default: constant_default()(["label"])
            },
            /**
             * Sets `maxHeight` style value of the menu.
             */
            maxHeight: {
              type: Number,
              default: 300
            },
            /**
             * Set `true` to allow selecting multiple options (a.k.a., multi-select mode).
             */
            multiple: {
              type: Boolean,
              default: false
            },
            /**
             * Generates a hidden <input /> tag with this field name for html forms.
             */
            name: {
              type: String
            },
            /**
             * Text displayed when a branch node has no children.
             */
            noChildrenText: {
              type: String,
              default: "No sub-options."
            },
            /**
             * Text displayed when there are no available options.
             */
            noOptionsText: {
              type: String,
              default: "No options available."
            },
            /**
             * Text displayed when there are no matching search results.
             */
            noResultsText: {
              type: String,
              default: "No results found..."
            },
            /**
             * Used for normalizing source data.
             * @type {function(node, instanceId): node}
             */
            normalizer: {
              type: Function,
              default: identity_default()
            },
            /**
             * By default (`auto`), the menu will open below the control. If there is not
             * enough space, vue-treeselect will automatically flip the menu.
             * You can use one of other four options to force the menu to be always opened
             * to specified direction.
             * Acceptable values:
             *   - `"auto"`
             *   - `"below"`
             *   - `"bottom"`
             *   - `"above"`
             *   - `"top"`
             */
            openDirection: {
              type: String,
              default: "auto",
              validator: function validator2(value) {
                var acceptableValues = ["auto", "top", "bottom", "above", "below"];
                return includes(acceptableValues, value);
              }
            },
            /**
             * Whether to automatically open the menu when the control is clicked.
             */
            openOnClick: {
              type: Boolean,
              default: true
            },
            /**
             * Whether to automatically open the menu when the control is focused.
             */
            openOnFocus: {
              type: Boolean,
              default: false
            },
            /**
             * Array of available options.
             * @type {node[]}
             */
            options: {
              type: Array
            },
            /**
             * Field placeholder, displayed when there's no value.
             */
            placeholder: {
              type: String,
              default: "Select..."
            },
            /**
             * Applies HTML5 required attribute when needed.
             */
            required: {
              type: Boolean,
              default: false
            },
            /**
             * Text displayed asking user whether to retry loading children options.
             */
            retryText: {
              type: String,
              default: "Retry?"
            },
            /**
             * Title for the retry button.
             */
            retryTitle: {
              type: String,
              default: "Click to retry"
            },
            /**
             * Enable searching feature?
             */
            searchable: {
              type: Boolean,
              default: true
            },
            /**
             * Search in ancestor nodes too.
             */
            searchNested: {
              type: Boolean,
              default: false
            },
            /**
             * Text tip to prompt for async search.
             */
            searchPromptText: {
              type: String,
              default: "Type to search..."
            },
            /**
             * Whether to show a children count next to the label of each branch node.
             */
            showCount: {
              type: Boolean,
              default: false
            },
            /**
             * Used in conjunction with `showCount` to specify which type of count number should be displayed.
             * Acceptable values:
             *   - "ALL_CHILDREN"
             *   - "ALL_DESCENDANTS"
             *   - "LEAF_CHILDREN"
             *   - "LEAF_DESCENDANTS"
             */
            showCountOf: {
              type: String,
              default: ALL_CHILDREN,
              validator: function validator2(value) {
                var acceptableValues = [ALL_CHILDREN, ALL_DESCENDANTS, LEAF_CHILDREN, LEAF_DESCENDANTS];
                return includes(acceptableValues, value);
              }
            },
            /**
             * Whether to show children count when searching.
             * Fallbacks to the value of `showCount` when not specified.
             * @type {boolean}
             */
            showCountOnSearch: null,
            /**
             * In which order the selected options should be displayed in trigger & sorted in `value` array.
             * Used for multi-select mode only.
             * Acceptable values:
             *   - "ORDER_SELECTED"
             *   - "LEVEL"
             *   - "INDEX"
             */
            sortValueBy: {
              type: String,
              default: ORDER_SELECTED,
              validator: function validator2(value) {
                var acceptableValues = [ORDER_SELECTED, LEVEL, INDEX];
                return includes(acceptableValues, value);
              }
            },
            /**
             * Tab index of the control.
             */
            tabIndex: {
              type: Number,
              default: 0
            },
            /**
             * The value of the control.
             * Should be `id` or `node` object for single-select mode, or an array of `id` or `node` object for multi-select mode.
             * Its format depends on the `valueFormat` prop.
             * For most cases, just use `v-model` instead.
             * @type {?Array}
             */
            modelValue: null,
            /**
             * Which kind of nodes should be included in the `value` array in multi-select mode.
             * Acceptable values:
             *   - "ALL" - Any node that is checked will be included in the `value` array
             *   - "BRANCH_PRIORITY" (default) - If a branch node is checked, all its descendants will be excluded in the `value` array
             *   - "LEAF_PRIORITY" - If a branch node is checked, this node itself and its branch descendants will be excluded from the `value` array but its leaf descendants will be included
             *   - "ALL_WITH_INDETERMINATE" - Any node that is checked will be included in the `value` array, plus indeterminate nodes
             */
            valueConsistsOf: {
              type: String,
              default: BRANCH_PRIORITY,
              validator: function validator2(value) {
                var acceptableValues = [ALL, BRANCH_PRIORITY, LEAF_PRIORITY, ALL_WITH_INDETERMINATE];
                return includes(acceptableValues, value);
              }
            },
            /**
             * Format of `value` prop.
             * Note that, when set to `"object"`, only `id` & `label` properties are required in each `node` object in `value` prop.
             * Acceptable values:
             *   - "id"
             *   - "object"
             */
            valueFormat: {
              type: String,
              default: "id"
            },
            /**
             * z-index of the menu.
             */
            zIndex: {
              type: [Number, String],
              default: 999
            }
          },
          data: function data() {
            return {
              trigger: {
                // Is the control focused?
                isFocused: false,
                // User entered search query - value of the input.
                searchQuery: ""
              },
              menu: {
                // Is the menu opened?
                isOpen: false,
                // Id of current highlighted option.
                current: null,
                // The scroll position before last menu closing.
                lastScrollPosition: 0,
                // Which direction to open the menu.
                placement: "bottom"
              },
              forest: {
                // Normalized options.
                normalizedOptions: [],
                // <id, node> map for quick look-up.
                nodeMap: createMap(),
                // <id, checkedState> map, used for multi-select mode.
                checkedStateMap: createMap(),
                // Id list of all selected options.
                selectedNodeIds: this.extractCheckedNodeIdsFromValue(),
                // <id, true> map for fast checking:
                //   if (forest.selectedNodeIds.indexOf(id) !== -1) forest.selectedNodeMap[id] === true
                selectedNodeMap: createMap()
              },
              // States of root options.
              rootOptionsStates: createAsyncOptionsStates(),
              localSearch: {
                // Has user entered any query to search local options?
                active: false,
                // Has any options matched the search query?
                noResults: true,
                // <id, countObject> map for counting matched children/descendants.
                countMap: createMap()
              },
              // <searchQuery, remoteSearchEntry> map.
              remoteSearch: createMap()
            };
          },
          computed: {
            /* eslint-disable valid-jsdoc */
            /**
             * Normalized nodes that have been selected.
             * @type {node[]}
             */
            selectedNodes: function selectedNodes() {
              return this.forest.selectedNodeIds.map(this.getNode);
            },
            /**
             * Id list of selected nodes with `sortValueBy` prop applied.
             * @type {nodeId[]}
             */
            internalValue: function internalValue() {
              var _this = this;
              var internalValue2;
              if (this.single || this.flat || this.disableBranchNodes || this.valueConsistsOf === ALL) {
                internalValue2 = this.forest.selectedNodeIds.slice();
              } else if (this.valueConsistsOf === BRANCH_PRIORITY) {
                internalValue2 = this.forest.selectedNodeIds.filter(function(id) {
                  var node = _this.getNode(id);
                  if (node.isRootNode)
                    return true;
                  return !_this.isSelected(node.parentNode);
                });
              } else if (this.valueConsistsOf === LEAF_PRIORITY) {
                internalValue2 = this.forest.selectedNodeIds.filter(function(id) {
                  var node = _this.getNode(id);
                  if (node.isLeaf)
                    return true;
                  return node.children.length === 0;
                });
              } else if (this.valueConsistsOf === ALL_WITH_INDETERMINATE) {
                var _internalValue;
                var indeterminateNodeIds = [];
                internalValue2 = this.forest.selectedNodeIds.slice();
                this.selectedNodes.forEach(function(selectedNode) {
                  selectedNode.ancestors.forEach(function(ancestor) {
                    if (includes(indeterminateNodeIds, ancestor.id))
                      return;
                    if (includes(internalValue2, ancestor.id))
                      return;
                    indeterminateNodeIds.push(ancestor.id);
                  });
                });
                (_internalValue = internalValue2).push.apply(_internalValue, indeterminateNodeIds);
              }
              if (this.sortValueBy === LEVEL) {
                internalValue2.sort(function(a2, b) {
                  return sortValueByLevel(_this.getNode(a2), _this.getNode(b));
                });
              } else if (this.sortValueBy === INDEX) {
                internalValue2.sort(function(a2, b) {
                  return sortValueByIndex(_this.getNode(a2), _this.getNode(b));
                });
              }
              return internalValue2;
            },
            /**
             * Has any option been selected?
             * @type {boolean}
             */
            hasValue: function hasValue() {
              return this.internalValue.length > 0;
            },
            /**
             * Single-select mode?
             * @type {boolean}
             */
            single: function single() {
              return !this.multiple;
            },
            /**
             * Id list of nodes displayed in the menu. Nodes that are considered NOT visible:
             *   - descendants of a collapsed branch node
             *   - in local search mode, nodes that are not matched, unless
             *       - it's a branch node and has matched descendants
             *       - it's a leaf node and its parent node is explicitly set to show all children
             * @type {id[]}
             */
            visibleOptionIds: function visibleOptionIds() {
              var _this2 = this;
              var visibleOptionIds2 = [];
              this.traverseAllNodesByIndex(function(node) {
                if (!_this2.localSearch.active || _this2.shouldOptionBeIncludedInSearchResult(node)) {
                  visibleOptionIds2.push(node.id);
                }
                if (node.isBranch && !_this2.shouldExpand(node)) {
                  return false;
                }
              });
              return visibleOptionIds2;
            },
            /**
             * Has any option should be displayed in the menu?
             * @type {boolean}
             */
            hasVisibleOptions: function hasVisibleOptions() {
              return this.visibleOptionIds.length !== 0;
            },
            /**
             * Should show children count when searching?
             * @type {boolean}
             */
            showCountOnSearchComputed: function showCountOnSearchComputed() {
              return typeof this.showCountOnSearch === "boolean" ? this.showCountOnSearch : this.showCount;
            },
            /**
             * Is there any branch node?
             * @type {boolean}
             */
            hasBranchNodes: function hasBranchNodes() {
              return this.forest.normalizedOptions.some(function(rootNode) {
                return rootNode.isBranch;
              });
            },
            shouldFlattenOptions: function shouldFlattenOptions() {
              return this.localSearch.active && this.flattenSearchResults;
            }
            /* eslint-enable valid-jsdoc */
          },
          watch: {
            alwaysOpen: function alwaysOpen(newValue) {
              if (newValue)
                this.openMenu();
              else
                this.closeMenu();
            },
            branchNodesFirst: function branchNodesFirst() {
              this.initialize();
            },
            disabled: function disabled(newValue) {
              if (newValue && this.menu.isOpen)
                this.closeMenu();
              else if (!newValue && !this.menu.isOpen && this.alwaysOpen)
                this.openMenu();
            },
            flat: function flat() {
              this.initialize();
            },
            internalValue: function internalValue(newValue, oldValue) {
              var hasChanged = quickDiff(newValue, oldValue);
              if (hasChanged)
                this.$emit("update:modelValue", this.getValue(), this.getInstanceId());
            },
            matchKeys: function matchKeys() {
              this.initialize();
            },
            multiple: function multiple(newValue) {
              if (newValue)
                this.buildForestState();
            },
            options: {
              handler: function handler() {
                if (this.async)
                  return;
                this.initialize();
                this.rootOptionsStates.isLoaded = Array.isArray(this.options);
              },
              deep: true,
              immediate: true
            },
            "trigger.searchQuery": function triggerSearchQuery() {
              if (this.async) {
                this.handleRemoteSearch();
                this.$emit("search-change", this.trigger.searchQuery, this.getInstanceId());
              } else {
                this.delayLocalSearch();
              }
            },
            value: function value() {
              var nodeIdsFromValue = this.extractCheckedNodeIdsFromValue();
              var hasChanged = quickDiff(nodeIdsFromValue, this.internalValue);
              if (hasChanged)
                this.fixSelectedNodeIds(nodeIdsFromValue);
            }
          },
          methods: {
            _localSearch: function _localSearch() {
              this.handleLocalSearch();
              this.$emit("search-change", this.trigger.searchQuery, this.getInstanceId());
            },
            delayLocalSearch: function delayLocalSearch() {
              if (this.localSearchTimeout > 0) {
                clearTimeout(this.localSearchTimeout);
                this.localSearchTimeout = -1;
              }
              this.localSearchTimeout = setTimeout(this._localSearch, 500);
            },
            verifyProps: function verifyProps() {
              var _this3 = this;
              warning(function() {
                return _this3.async ? _this3.searchable : true;
              }, function() {
                return 'For async search mode, the value of "searchable" prop must be true.';
              });
              if (this.options == null && !this.loadOptions) {
                warning(function() {
                  return false;
                }, function() {
                  return 'Are you meant to dynamically load options? You need to use "loadOptions" prop.';
                });
              }
              if (this.flat) {
                warning(function() {
                  return _this3.multiple;
                }, function() {
                  return 'You are using flat mode. But you forgot to add "multiple=true"?';
                });
              }
              if (!this.flat) {
                var propNames = ["autoSelectAncestors", "autoSelectDescendants", "autoDeselectAncestors", "autoDeselectDescendants"];
                propNames.forEach(function(propName) {
                  warning(function() {
                    return !_this3[propName];
                  }, function() {
                    return '"'.concat(propName, '" only applies to flat mode.');
                  });
                });
              }
            },
            resetFlags: function resetFlags() {
              this._blurOnSelect = false;
            },
            initialize: function initialize() {
              var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
              if (options.length === 0) {
                options = this.async ? this.getRemoteSearchEntry().options : this.options;
              }
              if (Array.isArray(options)) {
                var prevNodeMap = this.forest.nodeMap;
                this.forest.nodeMap = createMap();
                this.keepDataOfSelectedNodes(prevNodeMap);
                this.forest.normalizedOptions = this.normalize(NO_PARENT_NODE, options, prevNodeMap);
                this.fixSelectedNodeIds(this.internalValue);
              } else {
                this.forest.normalizedOptions = [];
              }
            },
            getInstanceId: function getInstanceId() {
              return this.instanceId == null ? this.id : this.instanceId;
            },
            getValue: function getValue() {
              var _this4 = this;
              if (this.valueFormat === "id") {
                return this.multiple ? this.internalValue.slice() : this.internalValue[0];
              }
              var rawNodes = this.internalValue.map(function(id) {
                return _this4.getNode(id).raw;
              });
              return this.multiple ? rawNodes : rawNodes[0];
            },
            getNode: function getNode(nodeId) {
              warning(function() {
                return nodeId != null;
              }, function() {
                return "Invalid node id: ".concat(nodeId);
              });
              if (nodeId == null)
                return null;
              return nodeId in this.forest.nodeMap ? this.forest.nodeMap[nodeId] : this.createFallbackNode(nodeId);
            },
            createFallbackNode: function createFallbackNode(id) {
              var raw = this.extractNodeFromValue(id);
              var label = this.enhancedNormalizer(raw).label || "".concat(id, " (unknown)");
              var fallbackNode = {
                id,
                label,
                ancestors: [],
                parentNode: NO_PARENT_NODE,
                isFallbackNode: true,
                isRootNode: true,
                isLeaf: true,
                isBranch: false,
                isDisabled: false,
                isNew: false,
                index: [-1],
                level: 0,
                raw
              };
              return this.forest.nodeMap[id] = fallbackNode;
            },
            extractCheckedNodeIdsFromValue: function extractCheckedNodeIdsFromValue() {
              var _this5 = this;
              if (this.modelValue == null)
                return [];
              if (this.valueFormat === "id") {
                return this.multiple ? this.modelValue.slice() : [this.modelValue];
              }
              return (this.multiple ? this.modelValue : [this.modelValue]).map(function(node) {
                return _this5.enhancedNormalizer(node);
              }).map(function(node) {
                return node.id;
              });
            },
            extractNodeFromValue: function extractNodeFromValue(id) {
              var _this6 = this;
              var defaultNode = {
                id
              };
              if (this.valueFormat === "id") {
                return defaultNode;
              }
              var valueArray = this.multiple ? Array.isArray(this.modelValue) ? this.modelValue : [] : this.modelValue ? [this.modelValue] : [];
              var matched = find(valueArray, function(node) {
                return node && _this6.enhancedNormalizer(node).id === id;
              });
              return matched || defaultNode;
            },
            fixSelectedNodeIds: function fixSelectedNodeIds(nodeIdListOfPrevValue) {
              var _this7 = this;
              var nextSelectedNodeIds = [];
              if (this.single || this.flat || this.disableBranchNodes || this.valueConsistsOf === ALL) {
                nextSelectedNodeIds = nodeIdListOfPrevValue;
              } else if (this.valueConsistsOf === BRANCH_PRIORITY) {
                nodeIdListOfPrevValue.forEach(function(nodeId2) {
                  nextSelectedNodeIds.push(nodeId2);
                  var node2 = _this7.getNode(nodeId2);
                  if (node2.isBranch)
                    _this7.traverseDescendantsBFS(node2, function(descendant) {
                      nextSelectedNodeIds.push(descendant.id);
                    });
                });
              } else if (this.valueConsistsOf === LEAF_PRIORITY) {
                var map = createMap();
                var queue = nodeIdListOfPrevValue.slice();
                while (queue.length) {
                  var nodeId = queue.shift();
                  var node = this.getNode(nodeId);
                  nextSelectedNodeIds.push(nodeId);
                  if (node.isRootNode)
                    continue;
                  if (!(node.parentNode.id in map))
                    map[node.parentNode.id] = node.parentNode.children.length;
                  if (--map[node.parentNode.id] === 0)
                    queue.push(node.parentNode.id);
                }
              } else if (this.valueConsistsOf === ALL_WITH_INDETERMINATE) {
                var _map = createMap();
                var _queue = nodeIdListOfPrevValue.filter(function(nodeId2) {
                  var node2 = _this7.getNode(nodeId2);
                  return node2.isLeaf || node2.children.length === 0;
                });
                while (_queue.length) {
                  var _nodeId = _queue.shift();
                  var _node = this.getNode(_nodeId);
                  nextSelectedNodeIds.push(_nodeId);
                  if (_node.isRootNode)
                    continue;
                  if (!(_node.parentNode.id in _map))
                    _map[_node.parentNode.id] = _node.parentNode.children.length;
                  if (--_map[_node.parentNode.id] === 0)
                    _queue.push(_node.parentNode.id);
                }
              }
              var hasChanged = quickDiff(this.forest.selectedNodeIds, nextSelectedNodeIds);
              if (hasChanged)
                this.forest.selectedNodeIds = nextSelectedNodeIds;
              this.buildForestState();
            },
            keepDataOfSelectedNodes: function keepDataOfSelectedNodes(prevNodeMap) {
              var _this8 = this;
              this.forest.selectedNodeIds.forEach(function(id) {
                if (!prevNodeMap[id])
                  return;
                var node = _objectSpread(_objectSpread({}, prevNodeMap[id]), {}, {
                  isFallbackNode: true
                });
                _this8.forest.nodeMap[id] = node;
              });
            },
            isSelected: function isSelected(node) {
              return this.forest.selectedNodeMap[node.id] === true;
            },
            traverseDescendantsBFS: function traverseDescendantsBFS(parentNode, callback) {
              if (!parentNode.isBranch)
                return;
              var queue = parentNode.children.slice();
              while (queue.length) {
                var currNode = queue[0];
                if (currNode.isBranch)
                  queue.push.apply(queue, treeselectMixin_toConsumableArray(currNode.children));
                callback(currNode);
                queue.shift();
              }
            },
            traverseDescendantsDFS: function traverseDescendantsDFS(parentNode, callback) {
              var _this9 = this;
              if (!parentNode.isBranch)
                return;
              parentNode.children.forEach(function(child) {
                _this9.traverseDescendantsDFS(child, callback);
                callback(child);
              });
            },
            traverseAllNodesDFS: function traverseAllNodesDFS(callback) {
              var _this10 = this;
              this.forest.normalizedOptions.forEach(function(rootNode) {
                _this10.traverseDescendantsDFS(rootNode, callback);
                callback(rootNode);
              });
            },
            traverseAllNodesByIndex: function traverseAllNodesByIndex(callback) {
              var walk = function walk2(parentNode) {
                parentNode.children.forEach(function(child) {
                  if (callback(child) !== false && child.isBranch) {
                    walk2(child);
                  }
                });
              };
              walk({
                children: this.forest.normalizedOptions
              });
            },
            toggleClickOutsideEvent: function toggleClickOutsideEvent(enabled) {
              if (enabled) {
                document.addEventListener("mousedown", this.handleClickOutside, false);
              } else {
                document.removeEventListener("mousedown", this.handleClickOutside, false);
              }
            },
            getValueContainer: function getValueContainer() {
              return this.$refs.control.$refs["value-container"];
            },
            getInput: function getInput() {
              return this.getValueContainer().$refs.input;
            },
            focusInput: function focusInput() {
              this.getInput().focus();
            },
            blurInput: function blurInput() {
              this.getInput().blur();
            },
            handleMouseDown: onLeftClick(function handleMouseDown(evt) {
              evt.preventDefault();
              evt.stopPropagation();
              if (this.disabled)
                return;
              var isClickedOnValueContainer = this.getValueContainer().$el.contains(evt.target);
              if (isClickedOnValueContainer && !this.menu.isOpen && (this.openOnClick || this.trigger.isFocused)) {
                this.openMenu();
              }
              if (this._blurOnSelect) {
                this.blurInput();
              } else {
                this.focusInput();
              }
              this.resetFlags();
            }),
            handleClickOutside: function handleClickOutside(evt) {
              if (this.$refs.wrapper && !this.$refs.wrapper.contains(evt.target)) {
                this.blurInput();
                this.closeMenu();
              }
            },
            handleLocalSearch: function handleLocalSearch() {
              var _this11 = this;
              var searchQuery = this.trigger.searchQuery;
              var done = function done2() {
                return _this11.resetHighlightedOptionWhenNecessary(true);
              };
              if (!searchQuery) {
                this.localSearch.active = false;
                return done();
              }
              this.localSearch.active = true;
              this.localSearch.noResults = true;
              this.traverseAllNodesDFS(function(node) {
                if (node.isBranch) {
                  var _this11$localSearch$c;
                  node.isExpandedOnSearch = false;
                  node.showAllChildrenOnSearch = false;
                  node.isMatched = false;
                  node.hasMatchedDescendants = false;
                  _this11.localSearch.countMap[node.id] = (_this11$localSearch$c = {}, _defineProperty(_this11$localSearch$c, ALL_CHILDREN, 0), _defineProperty(_this11$localSearch$c, ALL_DESCENDANTS, 0), _defineProperty(_this11$localSearch$c, LEAF_CHILDREN, 0), _defineProperty(_this11$localSearch$c, LEAF_DESCENDANTS, 0), _this11$localSearch$c);
                }
              });
              var lowerCasedSearchQuery = searchQuery.trim().toLocaleLowerCase();
              var splitSearchQuery = lowerCasedSearchQuery.replace(/\s+/g, " ").split(" ");
              this.traverseAllNodesDFS(function(node) {
                if (_this11.searchNested && splitSearchQuery.length > 1) {
                  node.isMatched = splitSearchQuery.every(function(filterValue) {
                    return match(false, filterValue, node.nestedSearchLabel);
                  });
                } else {
                  node.isMatched = _this11.matchKeys.some(function(matchKey) {
                    return match(!_this11.disableFuzzyMatching, lowerCasedSearchQuery, node.lowerCased[matchKey]);
                  });
                }
                if (node.isMatched) {
                  _this11.localSearch.noResults = false;
                  node.ancestors.forEach(function(ancestor) {
                    return _this11.localSearch.countMap[ancestor.id][ALL_DESCENDANTS]++;
                  });
                  if (node.isLeaf)
                    node.ancestors.forEach(function(ancestor) {
                      return _this11.localSearch.countMap[ancestor.id][LEAF_DESCENDANTS]++;
                    });
                  if (node.parentNode !== NO_PARENT_NODE) {
                    _this11.localSearch.countMap[node.parentNode.id][ALL_CHILDREN] += 1;
                    if (node.isLeaf)
                      _this11.localSearch.countMap[node.parentNode.id][LEAF_CHILDREN] += 1;
                  }
                }
                if ((node.isMatched || node.isBranch && node.isExpandedOnSearch) && node.parentNode !== NO_PARENT_NODE) {
                  node.parentNode.isExpandedOnSearch = true;
                  node.parentNode.hasMatchedDescendants = true;
                }
              });
              done();
            },
            handleRemoteSearch: function handleRemoteSearch() {
              var _this12 = this;
              var forced = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
              var searchQuery = this.trigger.searchQuery;
              var entry = this.getRemoteSearchEntry();
              var done = function done2() {
                _this12.initialize();
                _this12.resetHighlightedOptionWhenNecessary(true);
              };
              if ((searchQuery === "" || this.cacheOptions) && entry.isLoaded && !forced) {
                return done();
              }
              this.callLoadOptionsProp({
                action: ASYNC_SEARCH,
                args: {
                  searchQuery
                },
                isPending: function isPending() {
                  return entry.isLoading;
                },
                start: function start() {
                  entry.isLoading = true;
                  entry.isLoaded = false;
                  entry.loadingError = "";
                },
                succeed: function succeed(options) {
                  entry.isLoaded = true;
                  entry.options = options;
                  if (_this12.trigger.searchQuery === searchQuery)
                    done();
                },
                fail: function fail(err) {
                  entry.loadingError = getErrorMessage(err);
                },
                end: function end() {
                  entry.isLoading = false;
                }
              });
            },
            getRemoteSearchEntry: function getRemoteSearchEntry() {
              var _this13 = this;
              var searchQuery = this.trigger.searchQuery;
              var entry = this.remoteSearch[searchQuery] || _objectSpread(_objectSpread({}, createAsyncOptionsStates()), {}, {
                options: []
              });
              this.$watch(function() {
                return entry.options;
              }, function() {
                if (_this13.trigger.searchQuery === searchQuery)
                  _this13.initialize();
              }, {
                deep: true
              });
              if (searchQuery === "") {
                if (Array.isArray(this.defaultOptions)) {
                  entry.options = this.defaultOptions;
                  entry.isLoaded = true;
                  return entry;
                } else if (this.defaultOptions !== true) {
                  entry.isLoaded = true;
                  return entry;
                }
              }
              if (!this.remoteSearch[searchQuery]) {
                this.remoteSearch[searchQuery] = entry;
              }
              return entry;
            },
            shouldExpand: function shouldExpand(node) {
              return this.localSearch.active ? node.isExpandedOnSearch : node.isExpanded;
            },
            shouldOptionBeIncludedInSearchResult: function shouldOptionBeIncludedInSearchResult(node) {
              if (node.isMatched)
                return true;
              if (node.isBranch && node.hasMatchedDescendants && !this.flattenSearchResults)
                return true;
              if (!node.isRootNode && node.parentNode.showAllChildrenOnSearch)
                return true;
              return false;
            },
            shouldShowOptionInMenu: function shouldShowOptionInMenu(node) {
              if (this.localSearch.active && !this.shouldOptionBeIncludedInSearchResult(node)) {
                return false;
              }
              return true;
            },
            getControl: function getControl() {
              return this.$refs.control.$el;
            },
            getMenu: function getMenu() {
              var ref = this.appendToBody ? this.$refs.portal.portalTarget : this;
              var $menu = ref.$refs.menu.$refs.menu;
              return $menu && $menu.nodeName !== "#comment" ? $menu : null;
            },
            setCurrentHighlightedOption: function setCurrentHighlightedOption(node) {
              var _this14 = this;
              var scroll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              var prev = this.menu.current;
              if (prev != null && prev in this.forest.nodeMap) {
                this.forest.nodeMap[prev].isHighlighted = false;
              }
              this.menu.current = node.id;
              node.isHighlighted = true;
              if (this.menu.isOpen && scroll) {
                var scrollToOption = function scrollToOption2() {
                  var $menu = _this14.getMenu();
                  var $option = $menu.querySelector('.vue-treeselect__option[data-id="'.concat(node.id, '"]'));
                  if ($option)
                    scrollIntoView($menu, $option);
                };
                if (this.getMenu()) {
                  scrollToOption();
                } else {
                  this.$nextTick(scrollToOption);
                }
              }
            },
            resetHighlightedOptionWhenNecessary: function resetHighlightedOptionWhenNecessary() {
              var forceReset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
              var current = this.menu.current;
              if (forceReset || current == null || !(current in this.forest.nodeMap) || !this.shouldShowOptionInMenu(this.getNode(current))) {
                this.highlightFirstOption();
              }
            },
            highlightFirstOption: function highlightFirstOption() {
              if (!this.hasVisibleOptions)
                return;
              var first = this.visibleOptionIds[0];
              this.setCurrentHighlightedOption(this.getNode(first));
            },
            highlightPrevOption: function highlightPrevOption() {
              if (!this.hasVisibleOptions)
                return;
              var prev = this.visibleOptionIds.indexOf(this.menu.current) - 1;
              if (prev === -1)
                return this.highlightLastOption();
              this.setCurrentHighlightedOption(this.getNode(this.visibleOptionIds[prev]));
            },
            highlightNextOption: function highlightNextOption() {
              if (!this.hasVisibleOptions)
                return;
              var next = this.visibleOptionIds.indexOf(this.menu.current) + 1;
              if (next === this.visibleOptionIds.length)
                return this.highlightFirstOption();
              this.setCurrentHighlightedOption(this.getNode(this.visibleOptionIds[next]));
            },
            highlightLastOption: function highlightLastOption() {
              if (!this.hasVisibleOptions)
                return;
              var last = last_default()(this.visibleOptionIds);
              this.setCurrentHighlightedOption(this.getNode(last));
            },
            resetSearchQuery: function resetSearchQuery() {
              this.trigger.searchQuery = "";
            },
            closeMenu: function closeMenu() {
              if (!this.menu.isOpen || !this.disabled && this.alwaysOpen)
                return;
              this.saveMenuScrollPosition();
              this.menu.isOpen = false;
              this.toggleClickOutsideEvent(false);
              this.resetSearchQuery();
              this.$emit("close", this.getValue(), this.getInstanceId());
            },
            openMenu: function openMenu() {
              if (this.disabled || this.menu.isOpen)
                return;
              this.menu.isOpen = true;
              this.$nextTick(this.resetHighlightedOptionWhenNecessary);
              this.$nextTick(this.restoreMenuScrollPosition);
              if (!this.options && !this.async)
                this.loadRootOptions();
              this.toggleClickOutsideEvent(true);
              this.$emit("open", this.getInstanceId());
            },
            toggleMenu: function toggleMenu() {
              if (this.menu.isOpen) {
                this.closeMenu();
              } else {
                this.openMenu();
              }
            },
            toggleExpanded: function toggleExpanded(node) {
              var nextState;
              if (this.localSearch.active) {
                nextState = node.isExpandedOnSearch = !node.isExpandedOnSearch;
                if (nextState)
                  node.showAllChildrenOnSearch = true;
              } else {
                nextState = node.isExpanded = !node.isExpanded;
              }
              if (nextState && !node.childrenStates.isLoaded) {
                this.loadChildrenOptions(node);
              }
            },
            buildForestState: function buildForestState() {
              var _this15 = this;
              var selectedNodeMap = createMap();
              this.forest.selectedNodeIds.forEach(function(selectedNodeId) {
                selectedNodeMap[selectedNodeId] = true;
              });
              this.forest.selectedNodeMap = selectedNodeMap;
              var checkedStateMap = createMap();
              if (this.multiple) {
                this.traverseAllNodesByIndex(function(node) {
                  checkedStateMap[node.id] = UNCHECKED;
                });
                this.selectedNodes.forEach(function(selectedNode) {
                  checkedStateMap[selectedNode.id] = CHECKED;
                  if (!_this15.flat && !_this15.disableBranchNodes) {
                    selectedNode.ancestors.forEach(function(ancestorNode) {
                      if (!_this15.isSelected(ancestorNode)) {
                        checkedStateMap[ancestorNode.id] = INDETERMINATE;
                      }
                    });
                  }
                });
              }
              this.forest.checkedStateMap = checkedStateMap;
            },
            enhancedNormalizer: function enhancedNormalizer(raw) {
              return _objectSpread(_objectSpread({}, raw), this.normalizer(raw, this.getInstanceId()));
            },
            normalize: function normalize(parentNode, nodes, prevNodeMap) {
              var _this16 = this;
              var normalizedOptions = nodes.map(function(node) {
                return [_this16.enhancedNormalizer(node), node];
              }).map(function(_ref, index2) {
                var _ref2 = _slicedToArray(_ref, 2), node = _ref2[0], raw = _ref2[1];
                _this16.checkDuplication(node);
                _this16.verifyNodeShape(node);
                var id = node.id, label = node.label, children = node.children, isDefaultExpanded = node.isDefaultExpanded;
                var isRootNode = parentNode === NO_PARENT_NODE;
                var level = isRootNode ? 0 : parentNode.level + 1;
                var isBranch = Array.isArray(children) || children === null;
                var isLeaf = !isBranch;
                var isDisabled = !!node.isDisabled || !_this16.flat && !isRootNode && parentNode.isDisabled;
                var isNew = !!node.isNew;
                var lowerCased = _this16.matchKeys.reduce(function(prev2, key) {
                  return _objectSpread(_objectSpread({}, prev2), {}, _defineProperty({}, key, stringifyOptionPropValue(node[key]).toLocaleLowerCase()));
                }, {});
                var nestedSearchLabel = isRootNode ? lowerCased.label : parentNode.nestedSearchLabel + " " + lowerCased.label;
                _this16.forest.nodeMap[id] = createMap();
                var normalized = _this16.forest.nodeMap[id];
                normalized.id = id;
                normalized.label = label;
                normalized.level = level;
                normalized.ancestors = isRootNode ? [] : [parentNode].concat(parentNode.ancestors);
                normalized.index = (isRootNode ? [] : parentNode.index).concat(index2);
                normalized.parentNode = parentNode;
                normalized.lowerCased = lowerCased;
                normalized.nestedSearchLabel = nestedSearchLabel;
                normalized.isDisabled = isDisabled;
                normalized.isNew = isNew;
                normalized.isMatched = false;
                normalized.isHighlighted = false;
                normalized.isBranch = isBranch;
                normalized.isLeaf = isLeaf;
                normalized.isRootNode = isRootNode;
                normalized.raw = raw;
                if (isBranch) {
                  var _normalized$count;
                  var isLoaded = Array.isArray(children);
                  normalized.childrenStates = _objectSpread(_objectSpread({}, createAsyncOptionsStates()), {}, {
                    isLoaded
                  });
                  normalized.isExpanded = typeof isDefaultExpanded === "boolean" ? isDefaultExpanded : level < _this16.defaultExpandLevel;
                  normalized.hasMatchedDescendants = false;
                  normalized.hasDisabledDescendants = false;
                  normalized.isExpandedOnSearch = false;
                  normalized.showAllChildrenOnSearch = false;
                  normalized.count = (_normalized$count = {}, _defineProperty(_normalized$count, ALL_CHILDREN, 0), _defineProperty(_normalized$count, ALL_DESCENDANTS, 0), _defineProperty(_normalized$count, LEAF_CHILDREN, 0), _defineProperty(_normalized$count, LEAF_DESCENDANTS, 0), _normalized$count);
                  normalized.children = isLoaded ? _this16.normalize(normalized, children, prevNodeMap) : [];
                  if (isDefaultExpanded === true)
                    normalized.ancestors.forEach(function(ancestor) {
                      ancestor.isExpanded = true;
                    });
                  if (!isLoaded && typeof _this16.loadOptions !== "function") {
                    warning(function() {
                      return false;
                    }, function() {
                      return 'Unloaded branch node detected. "loadOptions" prop is required to load its children.';
                    });
                  } else if (!isLoaded && normalized.isExpanded) {
                    _this16.loadChildrenOptions(normalized);
                  }
                }
                normalized.ancestors.forEach(function(ancestor) {
                  return ancestor.count[ALL_DESCENDANTS]++;
                });
                if (isLeaf)
                  normalized.ancestors.forEach(function(ancestor) {
                    return ancestor.count[LEAF_DESCENDANTS]++;
                  });
                if (!isRootNode) {
                  parentNode.count[ALL_CHILDREN] += 1;
                  if (isLeaf)
                    parentNode.count[LEAF_CHILDREN] += 1;
                  if (isDisabled)
                    parentNode.hasDisabledDescendants = true;
                }
                if (prevNodeMap && prevNodeMap[id]) {
                  var prev = prevNodeMap[id];
                  normalized.isMatched = prev.isMatched;
                  normalized.showAllChildrenOnSearch = prev.showAllChildrenOnSearch;
                  normalized.isHighlighted = prev.isHighlighted;
                  if (prev.isBranch && normalized.isBranch) {
                    normalized.isExpanded = prev.isExpanded;
                    normalized.isExpandedOnSearch = prev.isExpandedOnSearch;
                    if (prev.childrenStates.isLoaded && !normalized.childrenStates.isLoaded) {
                      normalized.isExpanded = false;
                    } else {
                      normalized.childrenStates = _objectSpread({}, prev.childrenStates);
                    }
                  }
                }
                return normalized;
              });
              if (this.branchNodesFirst) {
                var branchNodes = normalizedOptions.filter(function(option) {
                  return option.isBranch;
                });
                var leafNodes = normalizedOptions.filter(function(option) {
                  return option.isLeaf;
                });
                normalizedOptions = branchNodes.concat(leafNodes);
              }
              return normalizedOptions;
            },
            loadRootOptions: function loadRootOptions() {
              var _this17 = this;
              this.callLoadOptionsProp({
                action: LOAD_ROOT_OPTIONS,
                isPending: function isPending() {
                  return _this17.rootOptionsStates.isLoading;
                },
                start: function start() {
                  _this17.rootOptionsStates.isLoading = true;
                  _this17.rootOptionsStates.loadingError = "";
                },
                succeed: function succeed() {
                  _this17.rootOptionsStates.isLoaded = true;
                  _this17.$nextTick(function() {
                    _this17.resetHighlightedOptionWhenNecessary(true);
                  });
                },
                fail: function fail(err) {
                  _this17.rootOptionsStates.loadingError = getErrorMessage(err);
                },
                end: function end() {
                  _this17.rootOptionsStates.isLoading = false;
                }
              });
            },
            loadChildrenOptions: function loadChildrenOptions(parentNode) {
              var _this18 = this;
              var id = parentNode.id, raw = parentNode.raw;
              this.callLoadOptionsProp({
                action: LOAD_CHILDREN_OPTIONS,
                args: {
                  // We always pass the raw node instead of the normalized node to any
                  // callback provided by the user of this component.
                  // Because the shape of the raw node is more likely to be closing to
                  // what the back-end API service of the application needs.
                  parentNode: raw
                },
                isPending: function isPending() {
                  return _this18.getNode(id).childrenStates.isLoading;
                },
                start: function start() {
                  _this18.getNode(id).childrenStates.isLoading = true;
                  _this18.getNode(id).childrenStates.loadingError = "";
                },
                succeed: function succeed() {
                  _this18.getNode(id).childrenStates.isLoaded = true;
                },
                fail: function fail(err) {
                  _this18.getNode(id).childrenStates.loadingError = getErrorMessage(err);
                },
                end: function end() {
                  _this18.getNode(id).childrenStates.isLoading = false;
                }
              });
            },
            callLoadOptionsProp: function callLoadOptionsProp(_ref3) {
              var action = _ref3.action, args = _ref3.args, isPending = _ref3.isPending, start = _ref3.start, succeed = _ref3.succeed, fail = _ref3.fail, end = _ref3.end;
              if (!this.loadOptions || isPending()) {
                return;
              }
              start();
              var callback = once_default()(function(err, result2) {
                if (err) {
                  fail(err);
                } else {
                  succeed(result2);
                }
                end();
              });
              var result = this.loadOptions(_objectSpread(_objectSpread({
                id: this.getInstanceId(),
                instanceId: this.getInstanceId(),
                action
              }, args), {}, {
                callback
              }));
              if (isPromise2(result)) {
                result.then(function() {
                  callback();
                }, function(err) {
                  callback(err);
                }).catch(function(err) {
                  console.error(err);
                });
              }
            },
            checkDuplication: function checkDuplication(node) {
              var _this19 = this;
              warning(function() {
                return !(node.id in _this19.forest.nodeMap && !_this19.forest.nodeMap[node.id].isFallbackNode);
              }, function() {
                return "Detected duplicate presence of node id ".concat(JSON.stringify(node.id), ". ") + 'Their labels are "'.concat(_this19.forest.nodeMap[node.id].label, '" and "').concat(node.label, '" respectively.');
              });
            },
            verifyNodeShape: function verifyNodeShape(node) {
              warning(function() {
                return !(node.children === void 0 && node.isBranch === true);
              }, function() {
                return "Are you meant to declare an unloaded branch node? `isBranch: true` is no longer supported, please use `children: null` instead.";
              });
            },
            select: function select(node) {
              if (this.disabled || node.isDisabled) {
                return;
              }
              if (this.single) {
                this.clear();
              }
              var nextState = this.multiple && !this.flat ? this.forest.checkedStateMap[node.id] === UNCHECKED : !this.isSelected(node);
              if (nextState) {
                this._selectNode(node);
              } else {
                this._deselectNode(node);
              }
              this.buildForestState();
              if (nextState) {
                this.$emit("select", node.raw, this.getInstanceId());
              } else {
                this.$emit("deselect", node.raw, this.getInstanceId());
              }
              if (this.localSearch.active && nextState && (this.single || this.clearOnSelect)) {
                this.resetSearchQuery();
              }
              if (this.single && this.closeOnSelect) {
                this.closeMenu();
                if (this.searchable) {
                  this._blurOnSelect = true;
                }
              }
            },
            clear: function clear() {
              var _this20 = this;
              if (this.hasValue) {
                if (this.single || this.allowClearingDisabled) {
                  this.forest.selectedNodeIds = [];
                } else {
                  this.forest.selectedNodeIds = this.forest.selectedNodeIds.filter(function(nodeId) {
                    return _this20.getNode(nodeId).isDisabled;
                  });
                }
                this.buildForestState();
              }
            },
            // This is meant to be called only by `select()`.
            _selectNode: function _selectNode(node) {
              var _this21 = this;
              if (this.single || this.disableBranchNodes) {
                return this.addValue(node);
              }
              if (this.flat) {
                this.addValue(node);
                if (this.autoSelectAncestors) {
                  node.ancestors.forEach(function(ancestor) {
                    if (!_this21.isSelected(ancestor) && !ancestor.isDisabled)
                      _this21.addValue(ancestor);
                  });
                } else if (this.autoSelectDescendants) {
                  this.traverseDescendantsBFS(node, function(descendant) {
                    if (!_this21.isSelected(descendant) && !descendant.isDisabled)
                      _this21.addValue(descendant);
                  });
                }
                return;
              }
              var isFullyChecked = node.isLeaf || /* node.isBranch && */
              !node.hasDisabledDescendants || /* node.isBranch && */
              this.allowSelectingDisabledDescendants;
              if (isFullyChecked) {
                this.addValue(node);
              }
              if (node.isBranch) {
                this.traverseDescendantsBFS(node, function(descendant) {
                  if (!descendant.isDisabled || _this21.allowSelectingDisabledDescendants) {
                    _this21.addValue(descendant);
                  }
                });
              }
              if (isFullyChecked) {
                var curr = node;
                while ((curr = curr.parentNode) !== NO_PARENT_NODE) {
                  if (curr.children.every(this.isSelected))
                    this.addValue(curr);
                  else
                    break;
                }
              }
            },
            // This is meant to be called only by `select()`.
            _deselectNode: function _deselectNode(node) {
              var _this22 = this;
              if (this.disableBranchNodes) {
                return this.removeValue(node);
              }
              if (this.flat) {
                this.removeValue(node);
                if (this.autoDeselectAncestors) {
                  node.ancestors.forEach(function(ancestor) {
                    if (_this22.isSelected(ancestor) && !ancestor.isDisabled)
                      _this22.removeValue(ancestor);
                  });
                } else if (this.autoDeselectDescendants) {
                  this.traverseDescendantsBFS(node, function(descendant) {
                    if (_this22.isSelected(descendant) && !descendant.isDisabled)
                      _this22.removeValue(descendant);
                  });
                }
                return;
              }
              var hasUncheckedSomeDescendants = false;
              if (node.isBranch) {
                this.traverseDescendantsDFS(node, function(descendant) {
                  if (!descendant.isDisabled || _this22.allowSelectingDisabledDescendants) {
                    _this22.removeValue(descendant);
                    hasUncheckedSomeDescendants = true;
                  }
                });
              }
              if (node.isLeaf || /* node.isBranch && */
              hasUncheckedSomeDescendants || /* node.isBranch && */
              node.children.length === 0) {
                this.removeValue(node);
                var curr = node;
                while ((curr = curr.parentNode) !== NO_PARENT_NODE) {
                  if (this.isSelected(curr))
                    this.removeValue(curr);
                  else
                    break;
                }
              }
            },
            addValue: function addValue(node) {
              this.forest.selectedNodeIds.push(node.id);
              this.forest.selectedNodeMap[node.id] = true;
            },
            removeValue: function removeValue(node) {
              removeFromArray(this.forest.selectedNodeIds, node.id);
              delete this.forest.selectedNodeMap[node.id];
            },
            removeLastValue: function removeLastValue() {
              if (!this.hasValue)
                return;
              if (this.single)
                return this.clear();
              var lastValue = last_default()(this.internalValue);
              var lastSelectedNode = this.getNode(lastValue);
              this.select(lastSelectedNode);
            },
            saveMenuScrollPosition: function saveMenuScrollPosition() {
              var $menu = this.getMenu();
              if ($menu)
                this.menu.lastScrollPosition = $menu.scrollTop;
            },
            restoreMenuScrollPosition: function restoreMenuScrollPosition() {
              var $menu = this.getMenu();
              if ($menu)
                $menu.scrollTop = this.menu.lastScrollPosition;
            }
          },
          created: function created() {
            this.verifyProps();
            this.resetFlags();
          },
          mounted: function mounted() {
            if (this.autoFocus)
              this.focusInput();
            if (!this.options && !this.async && this.autoLoadRootOptions)
              this.loadRootOptions();
            if (this.alwaysOpen)
              this.openMenu();
            if (this.async && this.defaultOptions)
              this.handleRemoteSearch();
          },
          unmounted: function unmounted() {
            this.toggleClickOutsideEvent(false);
          }
        };
        function stringifyValue(value) {
          if (typeof value === "string")
            return value;
          if (value != null && !isNaN_isNaN(value))
            return JSON.stringify(value);
          return "";
        }
        var HiddenFieldsvue_type_script_lang_js = (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.defineComponent)({
          name: "vue-treeselect--hidden-fields",
          inject: ["instance"],
          functional: true,
          render: function render2(context) {
            var instance = context.instance;
            if (!instance)
              return null;
            if (!("name" in instance))
              return null;
            if (!instance.name || instance.disabled || !instance.hasValue)
              return null;
            var stringifiedValues = instance.internalValue.map(stringifyValue);
            if (instance.multiple && instance.joinValues)
              stringifiedValues = [stringifiedValues.join(instance.delimiter)];
            return stringifiedValues.map(function(stringifiedValue, i) {
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("input", {
                "type": "hidden",
                "name": instance.name,
                "value": stringifiedValue,
                "key": "hidden-field-" + i
              }, null);
            });
          }
        });
        const __exports__ = HiddenFieldsvue_type_script_lang_js;
        var HiddenFields = __exports__;
        var debounce2 = __webpack_require__(279);
        var debounce_default = /* @__PURE__ */ __webpack_require__.n(debounce2);
        function _typeof(obj) {
          "@babel/helpers - typeof";
          return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
            return typeof obj2;
          } : function(obj2) {
            return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          }, _typeof(obj);
        }
        function isPlainObject2(value) {
          if (value == null || _typeof(value) !== "object")
            return false;
          return Object.getPrototypeOf(value) === Object.prototype;
        }
        function copy(obj, key, value) {
          if (isPlainObject2(value)) {
            obj[key] || (obj[key] = {});
            deepExtend(obj[key], value);
          } else {
            obj[key] = value;
          }
        }
        function deepExtend(target, source) {
          if (isPlainObject2(source)) {
            var keys = Object.keys(source);
            for (var i = 0, len = keys.length; i < len; i++) {
              copy(target, keys[i], source[keys[i]]);
            }
          }
          return target;
        }
        var keysThatRequireMenuBeingOpen = [KEY_CODES.ENTER, KEY_CODES.END, KEY_CODES.HOME, KEY_CODES.ARROW_LEFT, KEY_CODES.ARROW_UP, KEY_CODES.ARROW_RIGHT, KEY_CODES.ARROW_DOWN];
        var Inputvue_type_script_lang_js = {
          name: "vue-treeselect--input",
          inject: ["instance"],
          data: function data() {
            return {
              inputWidth: MIN_INPUT_WIDTH,
              value: ""
            };
          },
          computed: {
            needAutoSize: function needAutoSize() {
              var instance = this.instance;
              return instance.searchable && !instance.disabled && instance.multiple;
            },
            inputStyle: function inputStyle() {
              return {
                width: this.needAutoSize ? "".concat(this.inputWidth, "px") : null
              };
            }
          },
          watch: {
            "instance.trigger.searchQuery": function instanceTriggerSearchQuery(newValue) {
              this.value = newValue;
            },
            value: function value() {
              if (this.needAutoSize)
                this.$nextTick(this.updateInputWidth);
            }
          },
          created: function created() {
            this.debouncedCallback = debounce_default()(this.updateSearchQuery, INPUT_DEBOUNCE_DELAY, {
              leading: true,
              trailing: true
            });
          },
          methods: {
            clear: function clear() {
              this.onInput({
                target: {
                  value: ""
                }
              });
            },
            focus: function focus() {
              var instance = this.instance;
              if (!instance.disabled) {
                this.$refs.input && this.$refs.input.focus();
              }
            },
            blur: function blur() {
              this.$refs.input && this.$refs.input.blur();
            },
            onFocus: function onFocus() {
              var instance = this.instance;
              instance.trigger.isFocused = true;
              if (instance.openOnFocus)
                instance.openMenu();
            },
            onBlur: function onBlur() {
              var instance = this.instance;
              var menu = instance.getMenu();
              if (menu && document.activeElement === menu) {
                return this.focus();
              }
              instance.trigger.isFocused = false;
              instance.closeMenu();
            },
            onInput: function onInput(evt) {
              var value = evt.target.value;
              this.value = value;
              if (value) {
                this.debouncedCallback();
              } else {
                this.debouncedCallback.cancel();
                this.updateSearchQuery();
              }
            },
            // 用 keyUp 事件存在一个问题，删除输入框最后一个字符也会导致取消选中最后一项
            onKeyDown: function onKeyDown(evt) {
              var instance = this.instance;
              var key = "which" in evt ? evt.which : (
                /* istanbul ignore next */
                evt.keyCode
              );
              if (evt.ctrlKey || evt.shiftKey || evt.altKey || evt.metaKey)
                return;
              if (!instance.menu.isOpen && includes(keysThatRequireMenuBeingOpen, key)) {
                evt.preventDefault();
                return instance.openMenu();
              }
              switch (key) {
                case KEY_CODES.BACKSPACE: {
                  if (instance.backspaceRemoves && !this.value.length) {
                    instance.removeLastValue();
                  }
                  break;
                }
                case KEY_CODES.ENTER: {
                  evt.preventDefault();
                  if (instance.menu.current === null)
                    return;
                  var current = instance.getNode(instance.menu.current);
                  if (current.isBranch && instance.disableBranchNodes)
                    return;
                  instance.select(current);
                  break;
                }
                case KEY_CODES.ESCAPE: {
                  if (this.value.length) {
                    this.clear();
                  } else if (instance.menu.isOpen) {
                    instance.closeMenu();
                  }
                  break;
                }
                case KEY_CODES.END: {
                  evt.preventDefault();
                  instance.highlightLastOption();
                  break;
                }
                case KEY_CODES.HOME: {
                  evt.preventDefault();
                  instance.highlightFirstOption();
                  break;
                }
                case KEY_CODES.ARROW_LEFT: {
                  var _current = instance.getNode(instance.menu.current);
                  if (_current.isBranch && instance.shouldExpand(_current)) {
                    evt.preventDefault();
                    instance.toggleExpanded(_current);
                  } else if (!_current.isRootNode && (_current.isLeaf || _current.isBranch && !instance.shouldExpand(_current))) {
                    evt.preventDefault();
                    instance.setCurrentHighlightedOption(_current.parentNode);
                  }
                  break;
                }
                case KEY_CODES.ARROW_UP: {
                  evt.preventDefault();
                  instance.highlightPrevOption();
                  break;
                }
                case KEY_CODES.ARROW_RIGHT: {
                  var _current2 = instance.getNode(instance.menu.current);
                  if (_current2.isBranch && !instance.shouldExpand(_current2)) {
                    evt.preventDefault();
                    instance.toggleExpanded(_current2);
                  }
                  break;
                }
                case KEY_CODES.ARROW_DOWN: {
                  evt.preventDefault();
                  instance.highlightNextOption();
                  break;
                }
                case KEY_CODES.DELETE: {
                  if (instance.deleteRemoves && !this.value.length) {
                    instance.removeLastValue();
                  }
                  break;
                }
                default: {
                  instance.openMenu();
                }
              }
            },
            onMouseDown: function onMouseDown(evt) {
              if (this.value.length) {
                evt.stopPropagation();
              }
            },
            renderInputContainer: function renderInputContainer() {
              var instance = this.instance;
              var props = {};
              var children = [];
              if (instance.searchable && !instance.disabled) {
                children.push(this.renderInput());
                if (this.needAutoSize)
                  children.push(this.renderSizer());
              }
              if (!instance.searchable) {
                deepExtend(props, {
                  on: {
                    focus: this.onFocus,
                    blur: this.onBlur,
                    keydown: this.onKeyDown
                  },
                  ref: "input"
                });
              }
              if (!instance.searchable && !instance.disabled) {
                deepExtend(props, {
                  attrs: {
                    tabIndex: instance.tabIndex
                  }
                });
              }
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.mergeProps)({
                "class": "vue-treeselect__input-container"
              }, props), [children]);
            },
            renderInput: function renderInput() {
              var instance = this.instance;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("input", {
                "ref": "input",
                "class": "vue-treeselect__input",
                "type": "text",
                "autocomplete": "off",
                "tabIndex": instance.tabIndex,
                "required": instance.required && !instance.hasValue,
                "value": this.value,
                "style": this.inputStyle,
                "onFocus": this.onFocus,
                "onInput": this.onInput,
                "onBlur": this.onBlur,
                "onKeydown": this.onKeyDown,
                "onMousedown": this.onMouseDown
              }, null);
            },
            renderSizer: function renderSizer() {
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                "ref": "sizer",
                "class": "vue-treeselect__sizer"
              }, [this.value]);
            },
            updateInputWidth: function updateInputWidth() {
              this.inputWidth = Math.max(MIN_INPUT_WIDTH, this.$refs.sizer.scrollWidth + 15);
            },
            updateSearchQuery: function updateSearchQuery() {
              var instance = this.instance;
              instance.trigger.searchQuery = this.value;
            }
          },
          render: function render2() {
            return this.renderInputContainer();
          }
        };
        const Input_exports_ = Inputvue_type_script_lang_js;
        var Input = Input_exports_;
        var Placeholdervue_type_script_lang_js = {
          name: "vue-treeselect--placeholder",
          inject: ["instance"],
          render: function render2() {
            var instance = this.instance;
            var placeholderClass = {
              "vue-treeselect__placeholder": true,
              "vue-treeselect-helper-zoom-effect-off": true,
              "vue-treeselect-helper-hide": instance.hasValue || instance.trigger.searchQuery
            };
            return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
              "class": placeholderClass
            }, [instance.placeholder]);
          }
        };
        const Placeholder_exports_ = Placeholdervue_type_script_lang_js;
        var Placeholder = Placeholder_exports_;
        var SingleValuevue_type_script_lang_js = {
          name: "vue-treeselect--single-value",
          inject: ["instance"],
          methods: {
            renderSingleValueLabel: function renderSingleValueLabel() {
              var instance = this.instance;
              var node = instance.selectedNodes[0];
              var customValueLabelRenderer = instance.$slots["valueLabel"];
              return customValueLabelRenderer ? customValueLabelRenderer({
                node
              }) : node.label;
            }
          },
          render: function render2() {
            var instance = this.instance, renderValueContainer = this.$parent.renderValueContainer;
            var shouldShowValue = instance.hasValue && !instance.trigger.searchQuery;
            return renderValueContainer([shouldShowValue && (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
              "class": "vue-treeselect__single-value"
            }, [this.renderSingleValueLabel()]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Placeholder, null, null), (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Input, {
              "ref": "input"
            }, null)]);
          }
        };
        const SingleValue_exports_ = SingleValuevue_type_script_lang_js;
        var SingleValue = SingleValue_exports_;
        var _hoisted_110 = {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 348.333 348.333"
        };
        var _hoisted_210 = /* @__PURE__ */ (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createElementVNode)("path", {
          d: "M336.559 68.611L231.016 174.165l105.543 105.549c15.699 15.705 15.699 41.145 0 56.85-7.844 7.844-18.128 11.769-28.407 11.769-10.296 0-20.581-3.919-28.419-11.769L174.167 231.003 68.609 336.563c-7.843 7.844-18.128 11.769-28.416 11.769-10.285 0-20.563-3.919-28.413-11.769-15.699-15.698-15.699-41.139 0-56.85l105.54-105.549L11.774 68.611c-15.699-15.699-15.699-41.145 0-56.844 15.696-15.687 41.127-15.687 56.829 0l105.563 105.554L279.721 11.767c15.705-15.687 41.139-15.687 56.832 0 15.705 15.699 15.705 41.145.006 56.844z"
        }, null, -1);
        var _hoisted_38 = [_hoisted_210];
        function Deletevue_type_template_id_12b4a02e_render(_ctx, _cache, $props, $setup, $data, $options) {
          return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createElementBlock)("svg", _hoisted_110, _hoisted_38);
        }
        var Deletevue_type_script_lang_js = {
          name: "vue-treeselect--x"
        };
        var exportHelper = __webpack_require__(744);
        const Delete_exports_ = /* @__PURE__ */ (0, exportHelper.Z)(Deletevue_type_script_lang_js, [["render", Deletevue_type_template_id_12b4a02e_render]]);
        var Delete = Delete_exports_;
        var MultiValueItemvue_type_script_lang_js = {
          name: "vue-treeselect--multi-value-item",
          inject: ["instance"],
          props: {
            node: {
              type: Object,
              required: true
            }
          },
          methods: {
            handleMouseDown: onLeftClick(function handleMouseDown() {
              var instance = this.instance, node = this.node;
              instance.select(node);
            })
          },
          render: function render2() {
            var instance = this.instance, node = this.node;
            var itemClass = {
              "vue-treeselect__multi-value-item": true,
              "vue-treeselect__multi-value-item-disabled": node.isDisabled,
              "vue-treeselect__multi-value-item-new": node.isNew
            };
            var customValueLabelRenderer = instance.$slots["valueLabel"];
            var labelRenderer = customValueLabelRenderer ? customValueLabelRenderer({
              node
            }) : node.label;
            return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
              "class": "vue-treeselect__multi-value-item-container"
            }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
              "class": itemClass,
              "onMousedown": this.handleMouseDown
            }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("span", {
              "class": "vue-treeselect__multi-value-label"
            }, [labelRenderer]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("span", {
              "class": "vue-treeselect__icon vue-treeselect__value-remove"
            }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Delete, null, null)])])]);
          }
        };
        const MultiValueItem_exports_ = MultiValueItemvue_type_script_lang_js;
        var MultiValueItem = MultiValueItem_exports_;
        var MultiValuevue_type_script_lang_js = {
          name: "vue-treeselect--multi-value",
          inject: ["instance"],
          methods: {
            renderMultiValueItems: function renderMultiValueItems() {
              var instance = this.instance;
              return instance.internalValue.slice(0, instance.limit).map(instance.getNode).map(function(node) {
                return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(MultiValueItem, {
                  "key": "multi-value-item-".concat(node.id),
                  "node": node
                }, null);
              });
            },
            renderExceedLimitTip: function renderExceedLimitTip() {
              var instance = this.instance;
              var count = instance.internalValue.length - instance.limit;
              if (count <= 0)
                return null;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                "class": "vue-treeselect__limit-tip vue-treeselect-helper-zoom-effect-off",
                "key": "exceed-limit-tip"
              }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("span", {
                "class": "vue-treeselect__limit-tip-text"
              }, [instance.limitText(count)])]);
            }
          },
          render: function render2() {
            var renderValueContainer = this.$parent.renderValueContainer;
            return renderValueContainer((0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
              "class": "vue-treeselect__multi-value",
              "name": "vue-treeselect__multi-value-item--transition"
            }, [this.renderMultiValueItems(), this.renderExceedLimitTip(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Placeholder, {
              "key": "placeholder"
            }, null), (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Input, {
              "ref": "input",
              "key": "input"
            }, null)]));
          }
        };
        const MultiValue_exports_ = MultiValuevue_type_script_lang_js;
        var MultiValue = MultiValue_exports_;
        var Arrowvue_type_template_id_5d5151cb_hoisted_1 = {
          xmlns: "http://www.w3.org/2000/svg",
          viewBox: "0 0 292.362 292.362"
        };
        var Arrowvue_type_template_id_5d5151cb_hoisted_2 = /* @__PURE__ */ (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createElementVNode)("path", {
          d: "M286.935 69.377c-3.614-3.617-7.898-5.424-12.848-5.424H18.274c-4.952 0-9.233 1.807-12.85 5.424C1.807 72.998 0 77.279 0 82.228c0 4.948 1.807 9.229 5.424 12.847l127.907 127.907c3.621 3.617 7.902 5.428 12.85 5.428s9.233-1.811 12.847-5.428L286.935 95.074c3.613-3.617 5.427-7.898 5.427-12.847 0-4.948-1.814-9.229-5.427-12.85z"
        }, null, -1);
        var Arrowvue_type_template_id_5d5151cb_hoisted_3 = [Arrowvue_type_template_id_5d5151cb_hoisted_2];
        function Arrowvue_type_template_id_5d5151cb_render(_ctx, _cache, $props, $setup, $data, $options) {
          return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.openBlock)(), (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createElementBlock)("svg", Arrowvue_type_template_id_5d5151cb_hoisted_1, Arrowvue_type_template_id_5d5151cb_hoisted_3);
        }
        var Arrowvue_type_script_lang_js = {
          name: "vue-treeselect--arrow"
        };
        const Arrow_exports_ = /* @__PURE__ */ (0, exportHelper.Z)(Arrowvue_type_script_lang_js, [["render", Arrowvue_type_template_id_5d5151cb_render]]);
        var Arrow = Arrow_exports_;
        var Controlvue_type_script_lang_js = {
          name: "vue-treeselect--control",
          inject: ["instance"],
          computed: {
            /* eslint-disable valid-jsdoc */
            /**
             * Should show the "×" button that resets value?
             * @return {boolean}
             */
            shouldShowX: function shouldShowX() {
              var instance = this.instance;
              return instance.clearable && !instance.disabled && instance.hasValue && (this.hasUndisabledValue || instance.allowClearingDisabled);
            },
            /**
             * Should show the arrow button that toggles menu?
             * @return {boolean}
             */
            shouldShowArrow: function shouldShowArrow() {
              var instance = this.instance;
              if (!instance.alwaysOpen)
                return true;
              return !instance.menu.isOpen;
            },
            /**
             * Has any undisabled option been selected?
             * @type {boolean}
             */
            hasUndisabledValue: function hasUndisabledValue() {
              var instance = this.instance;
              return instance.hasValue && instance.internalValue.some(function(id) {
                return !instance.getNode(id).isDisabled;
              });
            }
            /* eslint-enable valid-jsdoc */
          },
          methods: {
            renderX: function renderX() {
              var instance = this.instance;
              var title = instance.multiple ? instance.clearAllText : instance.clearValueText;
              if (!this.shouldShowX)
                return null;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                "class": "vue-treeselect__x-container",
                "title": title,
                "onMousedown": this.handleMouseDownOnX
              }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Delete, {
                "class": "vue-treeselect__x"
              }, null)]);
            },
            renderArrow: function renderArrow() {
              var instance = this.instance;
              var arrowClass = {
                "vue-treeselect__control-arrow": true,
                "vue-treeselect__control-arrow--rotated": instance.menu.isOpen
              };
              if (!this.shouldShowArrow)
                return null;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                "class": "vue-treeselect__control-arrow-container",
                "onMousedown": this.handleMouseDownOnArrow
              }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Arrow, {
                "class": arrowClass
              }, null)]);
            },
            handleMouseDownOnX: onLeftClick(function handleMouseDownOnX(evt) {
              evt.stopPropagation();
              evt.preventDefault();
              var instance = this.instance;
              var result = instance.beforeClearAll();
              var handler = function handler2(shouldClear) {
                if (shouldClear)
                  instance.clear();
              };
              if (isPromise2(result)) {
                result.then(handler);
              } else {
                setTimeout(function() {
                  return handler(result);
                }, 0);
              }
            }),
            handleMouseDownOnArrow: onLeftClick(function handleMouseDownOnArrow(evt) {
              evt.preventDefault();
              evt.stopPropagation();
              var instance = this.instance;
              instance.focusInput();
              instance.toggleMenu();
            }),
            // This is meant to be called by child `<Value />` component.
            renderValueContainer: function renderValueContainer(children) {
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                "class": "vue-treeselect__value-container"
              }, [children]);
            }
          },
          render: function render2() {
            var instance = this.instance;
            var ValueContainer = instance.single ? SingleValue : MultiValue;
            return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
              "class": "vue-treeselect__control",
              "onMousedown": instance.handleMouseDown
            }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(ValueContainer, {
              "ref": "value-container"
            }, null), this.renderX(), this.renderArrow()]);
          }
        };
        const Control_exports_ = Controlvue_type_script_lang_js;
        var Control = Control_exports_;
        var index = function(element, listener) {
          var expand = document.createElement("_");
          var shrink = expand.appendChild(document.createElement("_"));
          var expandChild = expand.appendChild(document.createElement("_"));
          var shrinkChild = shrink.appendChild(document.createElement("_"));
          var lastWidth = void 0, lastHeight = void 0;
          shrink.style.cssText = expand.style.cssText = "height:100%;left:0;opacity:0;overflow:hidden;pointer-events:none;position:absolute;top:0;transition:0s;width:100%;z-index:-1";
          shrinkChild.style.cssText = expandChild.style.cssText = "display:block;height:100%;transition:0s;width:100%";
          shrinkChild.style.width = shrinkChild.style.height = "200%";
          element.appendChild(expand);
          test2();
          return stop2;
          function test2() {
            unbind();
            var width = element.offsetWidth;
            var height = element.offsetHeight;
            if (width !== lastWidth || height !== lastHeight) {
              lastWidth = width;
              lastHeight = height;
              expandChild.style.width = width * 2 + "px";
              expandChild.style.height = height * 2 + "px";
              expand.scrollLeft = expand.scrollWidth;
              expand.scrollTop = expand.scrollHeight;
              shrink.scrollLeft = shrink.scrollWidth;
              shrink.scrollTop = shrink.scrollHeight;
              listener({ width, height });
            }
            shrink.addEventListener("scroll", test2);
            expand.addEventListener("scroll", test2);
          }
          function unbind() {
            shrink.removeEventListener("scroll", test2);
            expand.removeEventListener("scroll", test2);
          }
          function stop2() {
            unbind();
            element.removeChild(expand);
          }
        };
        var index_es = index;
        var intervalId;
        var registered = [];
        var INTERVAL_DURATION = 100;
        function run() {
          intervalId = setInterval(function() {
            registered.forEach(test);
          }, INTERVAL_DURATION);
        }
        function stop() {
          clearInterval(intervalId);
          intervalId = null;
        }
        function test(item) {
          var $el = item.$el, listener = item.listener, lastWidth = item.lastWidth, lastHeight = item.lastHeight;
          var width = $el.offsetWidth;
          var height = $el.offsetHeight;
          if (lastWidth !== width || lastHeight !== height) {
            item.lastWidth = width;
            item.lastHeight = height;
            listener({
              width,
              height
            });
          }
        }
        function watchSizeForIE9($el, listener) {
          var item = {
            $el,
            listener,
            lastWidth: null,
            lastHeight: null
          };
          var unwatch = function unwatch2() {
            removeFromArray(registered, item);
            if (!registered.length)
              stop();
          };
          registered.push(item);
          test(item);
          run();
          return unwatch;
        }
        function watchSize($el, listener) {
          var isIE9 = document.documentMode === 9;
          var locked = true;
          var wrappedListener = function wrappedListener2() {
            return locked || listener.apply(void 0, arguments);
          };
          var implementation = isIE9 ? watchSizeForIE9 : index_es;
          var removeSizeWatcher = implementation($el, wrappedListener);
          locked = false;
          return removeSizeWatcher;
        }
        function findScrollParents($el) {
          var $scrollParents = [];
          var $parent = $el.parentNode;
          while ($parent && $parent.nodeName !== "BODY" && $parent.nodeType === document.ELEMENT_NODE) {
            if (isScrollElment($parent))
              $scrollParents.push($parent);
            $parent = $parent.parentNode;
          }
          $scrollParents.push(window);
          return $scrollParents;
        }
        function isScrollElment($el) {
          var _getComputedStyle = getComputedStyle($el), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
          return /(auto|scroll|overlay)/.test(overflow + overflowY + overflowX);
        }
        function setupResizeAndScrollEventListeners($el, listener) {
          var $scrollParents = findScrollParents($el);
          window.addEventListener("resize", listener, {
            passive: true
          });
          $scrollParents.forEach(function(scrollParent) {
            scrollParent.addEventListener("scroll", listener, {
              passive: true
            });
          });
          return function removeEventListeners() {
            window.removeEventListener("resize", listener, {
              passive: true
            });
            $scrollParents.forEach(function($scrollParent) {
              $scrollParent.removeEventListener("scroll", listener, {
                passive: true
              });
            });
          };
        }
        var Tipvue_type_script_lang_js = (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.defineComponent)({
          name: "vue-treeselect--tip",
          functional: true,
          props: {
            type: {
              type: String,
              required: true
            },
            icon: {
              type: String,
              required: true
            }
          },
          render: function render2(context) {
            var type = this.type, icon = this.icon;
            return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
              "class": "vue-treeselect__tip vue-treeselect__".concat(type, "-tip")
            }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
              "class": "vue-treeselect__icon-container"
            }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("span", {
              "class": "vue-treeselect__icon-".concat(icon)
            }, null)]), (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("span", {
              "class": "vue-treeselect__tip-text vue-treeselect__".concat(type, "-tip-text")
            }, [this.$slots.default()])]);
          }
        });
        const Tip_exports_ = Tipvue_type_script_lang_js;
        var Tip = Tip_exports_;
        function Optionvue_type_script_lang_js_defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var arrowPlaceholder, checkMark, minusMark;
        var Option = {
          name: "vue-treeselect--option",
          inject: ["instance"],
          props: {
            node: {
              type: Object,
              required: true
            }
          },
          computed: {
            shouldExpand: function shouldExpand() {
              var instance = this.instance, node = this.node;
              return node.isBranch && instance.shouldExpand(node);
            },
            shouldShow: function shouldShow() {
              var instance = this.instance, node = this.node;
              return instance.shouldShowOptionInMenu(node);
            }
          },
          methods: {
            renderOption: function renderOption() {
              var instance = this.instance, node = this.node;
              var optionClass = {
                "vue-treeselect__option": true,
                "vue-treeselect__option--disabled": node.isDisabled,
                "vue-treeselect__option--selected": instance.isSelected(node),
                "vue-treeselect__option--highlight": node.isHighlighted,
                "vue-treeselect__option--matched": instance.localSearch.active && node.isMatched,
                "vue-treeselect__option--hide": !this.shouldShow
              };
              var sepClass = {
                "vue-treeselect__option": true,
                "vue-treeselect__sep": true
              };
              if (node.isBranch) {
                optionClass["vue-treeselect__option_isBranch"] = true;
                if (this.shouldExpand) {
                  optionClass["vue-treeselect__option_expanded"] = true;
                }
              }
              var customSepRenderer = instance.$slots["sepLabel"];
              if (node.id === "sep") {
                if (customSepRenderer) {
                  return customSepRenderer({
                    node
                  });
                } else {
                  return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                    "class": sepClass
                  }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createTextVNode)(" "), node.label, (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createTextVNode)(" ")]);
                }
              } else {
                return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                  "class": optionClass,
                  "onMouseenter": this.handleMouseEnterOption,
                  "data-id": node.id
                }, [this.renderArrow(), this.renderLabelContainer([this.renderCheckboxContainer([this.renderCheckbox()]), this.renderLabel()], node.raw.nextSep)]);
              }
            },
            renderSubOptionsList: function renderSubOptionsList() {
              if (!this.shouldExpand)
                return null;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                "class": "vue-treeselect__list"
              }, [this.renderSubOptions(), this.renderNoChildrenTip(), this.renderLoadingChildrenTip(), this.renderLoadingChildrenErrorTip()]);
            },
            renderArrow: function renderArrow() {
              var instance = this.instance, node = this.node;
              if (instance.shouldFlattenOptions && this.shouldShow)
                return null;
              if (node.isBranch) {
                var arrowClass = {
                  "vue-treeselect__option-arrow": true,
                  "vue-treeselect__option-arrow--rotated": this.shouldExpand
                };
                return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                  "class": "vue-treeselect__option-arrow-container",
                  "onMousedown": this.handleMouseDownOnArrow
                }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                  "name": "vue-treeselect__option-arrow--prepare"
                }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Arrow, {
                  "class": arrowClass
                }, null)])]);
              }
              if (
                /*node.isLeaf && */
                instance.hasBranchNodes
              ) {
                if (!arrowPlaceholder)
                  arrowPlaceholder = (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                    "class": "vue-treeselect__option-arrow-placeholder"
                  }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createTextVNode)(" ")]);
                return arrowPlaceholder;
              }
              return null;
            },
            renderLabelContainer: function renderLabelContainer(children) {
              var nextSep = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var myclass = {
                "vue-treeselect__label-container": true
              };
              if (nextSep) {
                myclass["nextSep"] = true;
              }
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                "class": myclass,
                "onMousedown": this.handleMouseDownOnLabelContainer
              }, [children]);
            },
            renderCheckboxContainer: function renderCheckboxContainer(children) {
              var instance = this.instance, node = this.node;
              if (instance.single)
                return null;
              if (instance.disableBranchNodes && node.isBranch)
                return null;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                "class": "vue-treeselect__checkbox-container"
              }, [children]);
            },
            renderCheckbox: function renderCheckbox() {
              var instance = this.instance, node = this.node;
              var checkedState = instance.forest.checkedStateMap[node.id];
              var checkboxClass = {
                "vue-treeselect__checkbox": true,
                "vue-treeselect__checkbox--checked": checkedState === CHECKED,
                "vue-treeselect__checkbox--indeterminate": checkedState === INDETERMINATE,
                "vue-treeselect__checkbox--unchecked": checkedState === UNCHECKED,
                "vue-treeselect__checkbox--disabled": node.isDisabled
              };
              if (!checkMark)
                checkMark = (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("span", {
                  "class": "vue-treeselect__check-mark"
                }, null);
              if (!minusMark)
                minusMark = (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("span", {
                  "class": "vue-treeselect__minus-mark"
                }, null);
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("span", {
                "class": checkboxClass
              }, [checkMark, minusMark]);
            },
            renderLabel: function renderLabel() {
              var instance = this.instance, node = this.node;
              var shouldShowCount = node.isBranch && (instance.localSearch.active ? instance.showCountOnSearchComputed : instance.showCount);
              var count = shouldShowCount ? instance.localSearch.active ? instance.localSearch.countMap[node.id][instance.showCountOf] : node.count[instance.showCountOf] : NaN;
              var labelClassName = "vue-treeselect__label";
              var countClassName = "vue-treeselect__count";
              var customLabelRenderer = instance.$slots["optionLabel"];
              if (customLabelRenderer)
                return customLabelRenderer({
                  node,
                  shouldShowCount,
                  count,
                  labelClassName,
                  countClassName
                });
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("label", {
                "class": labelClassName
              }, [node.label, shouldShowCount && (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("span", {
                "class": countClassName
              }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createTextVNode)("("), count, (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createTextVNode)(") ")])]);
            },
            renderSubOptions: function renderSubOptions() {
              var node = this.node;
              if (!node.childrenStates.isLoaded)
                return null;
              return node.children.map(function(childNode) {
                return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)((0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.resolveComponent)("vue-treeselect--option"), {
                  "node": childNode,
                  "key": childNode.id
                }, null);
              });
            },
            renderNoChildrenTip: function renderNoChildrenTip() {
              var instance = this.instance, node = this.node;
              if (!node.childrenStates.isLoaded || node.children.length)
                return null;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Tip, {
                "type": "no-children",
                "icon": "warning"
              }, {
                default: function _default() {
                  return [instance.noChildrenText];
                }
              });
            },
            renderLoadingChildrenTip: function renderLoadingChildrenTip() {
              var instance = this.instance, node = this.node;
              if (!node.childrenStates.isLoading)
                return null;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Tip, {
                "type": "loading",
                "icon": "loader"
              }, {
                default: function _default() {
                  return [instance.loadingText];
                }
              });
            },
            renderLoadingChildrenErrorTip: function renderLoadingChildrenErrorTip() {
              var _this = this;
              var instance = this.instance, node = this.node;
              if (!node.childrenStates.loadingError)
                return null;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Tip, {
                "type": "error",
                "icon": "error"
              }, {
                default: function _default() {
                  return [node.childrenStates.loadingError, (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("a", {
                    "class": "vue-treeselect__retry",
                    "title": instance.retryTitle,
                    "onMousedown": _this.handleMouseDownOnRetry
                  }, [instance.retryText])];
                }
              });
            },
            handleMouseEnterOption: function handleMouseEnterOption(evt) {
              var instance = this.instance, node = this.node;
              if (evt.target !== evt.currentTarget)
                return;
              instance.setCurrentHighlightedOption(node, false);
            },
            handleMouseDownOnArrow: onLeftClick(function handleMouseDownOnOptionArrow() {
              var instance = this.instance, node = this.node;
              instance.toggleExpanded(node);
            }),
            handleMouseDownOnLabelContainer: onLeftClick(function handleMouseDownOnLabelContainer() {
              var instance = this.instance, node = this.node;
              if (node.isBranch && instance.disableBranchNodes) {
                instance.toggleExpanded(node);
              } else {
                instance.select(node);
              }
            }),
            handleMouseDownOnRetry: onLeftClick(function handleMouseDownOnRetry() {
              var instance = this.instance, node = this.node;
              instance.loadChildrenOptions(node);
            })
          },
          render: function render2() {
            var _listItemClass;
            var node = this.node;
            var indentLevel = this.instance.shouldFlattenOptions ? 0 : node.level;
            var listItemClass = (_listItemClass = {
              "vue-treeselect__list-item": true
            }, Optionvue_type_script_lang_js_defineProperty(_listItemClass, "vue-treeselect__indent-level-".concat(indentLevel), true), Optionvue_type_script_lang_js_defineProperty(_listItemClass, "vue-treeselect__option--hide", !this.shouldShow), _listItemClass);
            return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
              "class": listItemClass
            }, [this.renderOption(), node.isBranch ? (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", null, [this.renderSubOptionsList()]) : ""]);
          }
        };
        var Optionvue_type_script_lang_js = Option;
        const Option_exports_ = Optionvue_type_script_lang_js;
        var components_Option = Option_exports_;
        function Menuvue_type_script_lang_js_slicedToArray(arr, i) {
          return Menuvue_type_script_lang_js_arrayWithHoles(arr) || Menuvue_type_script_lang_js_iterableToArrayLimit(arr, i) || Menuvue_type_script_lang_js_unsupportedIterableToArray(arr, i) || Menuvue_type_script_lang_js_nonIterableRest();
        }
        function Menuvue_type_script_lang_js_nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function Menuvue_type_script_lang_js_unsupportedIterableToArray(o, minLen) {
          if (!o)
            return;
          if (typeof o === "string")
            return Menuvue_type_script_lang_js_arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return Array.from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return Menuvue_type_script_lang_js_arrayLikeToArray(o, minLen);
        }
        function Menuvue_type_script_lang_js_arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length)
            len = arr.length;
          for (var i = 0, arr2 = new Array(len); i < len; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        }
        function Menuvue_type_script_lang_js_iterableToArrayLimit(arr, i) {
          var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
          if (_i == null)
            return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _s, _e;
          try {
            for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null)
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        function Menuvue_type_script_lang_js_arrayWithHoles(arr) {
          if (Array.isArray(arr))
            return arr;
        }
        var directionMap = {
          top: "top",
          bottom: "bottom",
          above: "top",
          below: "bottom"
        };
        var Menuvue_type_script_lang_js = {
          name: "vue-treeselect--menu",
          inject: ["instance"],
          computed: {
            menuStyle: function menuStyle() {
              var instance = this.instance;
              return {
                maxHeight: instance.maxHeight + "px"
              };
            },
            menuContainerStyle: function menuContainerStyle() {
              var instance = this.instance;
              var style = {
                zIndex: instance.appendToBody ? null : instance.zIndex
                // width: '800px',
              };
              if (instance.menuContainerStyle) {
                var keyValuePairs = instance.menuContainerStyle.split("; ");
                keyValuePairs.forEach(function(keyValuePair) {
                  var _keyValuePair$split = keyValuePair.split(":"), _keyValuePair$split2 = Menuvue_type_script_lang_js_slicedToArray(_keyValuePair$split, 2), key = _keyValuePair$split2[0], value = _keyValuePair$split2[1];
                  style[key.trim()] = value.trim();
                });
              }
              return style;
            }
          },
          watch: {
            "instance.menu.isOpen": function instanceMenuIsOpen(newValue) {
              if (newValue) {
                this.$nextTick(this.onMenuOpen);
              } else {
                this.onMenuClose();
              }
            }
          },
          created: function created() {
            this.menuSizeWatcher = null;
            this.menuResizeAndScrollEventListeners = null;
          },
          mounted: function mounted() {
            var instance = this.instance;
            if (instance.menu.isOpen)
              this.$nextTick(this.onMenuOpen);
          },
          unmounted: function unmounted() {
            this.onMenuClose();
          },
          methods: {
            renderMenu: function renderMenu() {
              var instance = this.instance;
              if (!instance.menu.isOpen)
                return null;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                "ref": "menu",
                "class": "vue-treeselect__menu",
                "onMousedown": instance.handleMouseDown,
                "style": this.menuStyle
              }, [this.renderBeforeList(), instance.async ? this.renderAsyncSearchMenuInner() : instance.localSearch.active ? this.renderLocalSearchMenuInner() : this.renderNormalMenuInner(), this.renderAfterList()]);
            },
            renderBeforeList: function renderBeforeList() {
              var instance = this.instance;
              var beforeListRenderer = instance.$slots["before-list"];
              return beforeListRenderer ? beforeListRenderer() : null;
            },
            renderAfterList: function renderAfterList() {
              var instance = this.instance;
              var afterListRenderer = instance.$slots["after-list"];
              return afterListRenderer ? afterListRenderer() : null;
            },
            renderNormalMenuInner: function renderNormalMenuInner() {
              var instance = this.instance;
              if (instance.rootOptionsStates.isLoading) {
                return this.renderLoadingOptionsTip();
              } else if (instance.rootOptionsStates.loadingError) {
                return this.renderLoadingRootOptionsErrorTip();
              } else if (instance.rootOptionsStates.isLoaded && instance.forest.normalizedOptions.length === 0) {
                return this.renderNoAvailableOptionsTip();
              } else {
                return this.renderOptionList();
              }
            },
            renderLocalSearchMenuInner: function renderLocalSearchMenuInner() {
              var instance = this.instance;
              if (instance.rootOptionsStates.isLoading) {
                return this.renderLoadingOptionsTip();
              } else if (instance.rootOptionsStates.loadingError) {
                return this.renderLoadingRootOptionsErrorTip();
              } else if (instance.rootOptionsStates.isLoaded && instance.forest.normalizedOptions.length === 0) {
                return this.renderNoAvailableOptionsTip();
              } else if (instance.localSearch.noResults) {
                return this.renderNoResultsTip();
              } else {
                return this.renderOptionList();
              }
            },
            renderAsyncSearchMenuInner: function renderAsyncSearchMenuInner() {
              var instance = this.instance;
              var entry = instance.getRemoteSearchEntry();
              var shouldShowSearchPromptTip = instance.trigger.searchQuery === "" && !instance.defaultOptions;
              var shouldShowNoResultsTip = shouldShowSearchPromptTip ? false : entry.isLoaded && entry.options.length === 0;
              if (shouldShowSearchPromptTip) {
                return this.renderSearchPromptTip();
              } else if (entry.isLoading) {
                return this.renderLoadingOptionsTip();
              } else if (entry.loadingError) {
                return this.renderAsyncSearchLoadingErrorTip();
              } else if (shouldShowNoResultsTip) {
                return this.renderNoResultsTip();
              } else {
                return this.renderOptionList();
              }
            },
            renderOptionList: function renderOptionList() {
              var instance = this.instance;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                "class": "vue-treeselect__list"
              }, [instance.forest.normalizedOptions.map(function(rootNode) {
                return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(components_Option, {
                  "node": rootNode,
                  "key": rootNode.id
                }, null);
              })]);
            },
            renderSearchPromptTip: function renderSearchPromptTip() {
              var instance = this.instance;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Tip, {
                "type": "search-prompt",
                "icon": "warning"
              }, {
                default: function _default() {
                  return [instance.searchPromptText];
                }
              });
            },
            renderLoadingOptionsTip: function renderLoadingOptionsTip() {
              var instance = this.instance;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Tip, {
                "type": "loading",
                "icon": "loader"
              }, {
                default: function _default() {
                  return [instance.loadingText];
                }
              });
            },
            renderLoadingRootOptionsErrorTip: function renderLoadingRootOptionsErrorTip() {
              var instance = this.instance;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Tip, {
                "type": "error",
                "icon": "error"
              }, {
                default: function _default() {
                  return [instance.rootOptionsStates.loadingError, (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("a", {
                    "class": "vue-treeselect__retry",
                    "onClick": instance.loadRootOptions,
                    "title": instance.retryTitle
                  }, [instance.retryText])];
                }
              });
            },
            renderAsyncSearchLoadingErrorTip: function renderAsyncSearchLoadingErrorTip() {
              var instance = this.instance;
              var entry = instance.getRemoteSearchEntry();
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Tip, {
                "type": "error",
                "icon": "error"
              }, {
                default: function _default() {
                  return [entry.loadingError, (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("a", {
                    "class": "vue-treeselect__retry",
                    "onClick": instance.handleRemoteSearch,
                    "title": instance.retryTitle
                  }, [instance.retryText])];
                }
              });
            },
            renderNoAvailableOptionsTip: function renderNoAvailableOptionsTip() {
              var instance = this.instance;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Tip, {
                "type": "no-options",
                "icon": "warning"
              }, {
                default: function _default() {
                  return [instance.noOptionsText];
                }
              });
            },
            renderNoResultsTip: function renderNoResultsTip() {
              var instance = this.instance;
              return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Tip, {
                "type": "no-results",
                "icon": "warning"
              }, {
                default: function _default() {
                  return [instance.noResultsText];
                }
              });
            },
            onMenuOpen: function onMenuOpen() {
              this.adjustMenuOpenDirection();
              this.setupMenuSizeWatcher();
              this.setupMenuResizeAndScrollEventListeners();
            },
            onMenuClose: function onMenuClose() {
              this.removeMenuSizeWatcher();
              this.removeMenuResizeAndScrollEventListeners();
            },
            adjustMenuOpenDirection: function adjustMenuOpenDirection() {
              var instance = this.instance;
              if (!instance.menu.isOpen)
                return;
              var $menu = instance.getMenu();
              var $control = instance.getControl();
              var menuRect = $menu.getBoundingClientRect();
              var controlRect = $control.getBoundingClientRect();
              var menuHeight = menuRect.height;
              var viewportHeight = window.innerHeight;
              var spaceAbove = controlRect.top;
              var spaceBelow = window.innerHeight - controlRect.bottom;
              var isControlInViewport = controlRect.top >= 0 && controlRect.top <= viewportHeight || controlRect.top < 0 && controlRect.bottom > 0;
              var hasEnoughSpaceBelow = spaceBelow > menuHeight + MENU_BUFFER;
              var hasEnoughSpaceAbove = spaceAbove > menuHeight + MENU_BUFFER;
              if (!isControlInViewport) {
                instance.closeMenu();
              } else if (instance.openDirection !== "auto") {
                instance.menu.placement = directionMap[instance.openDirection];
              } else if (hasEnoughSpaceBelow || !hasEnoughSpaceAbove) {
                instance.menu.placement = "bottom";
              } else {
                instance.menu.placement = "top";
              }
            },
            setupMenuSizeWatcher: function setupMenuSizeWatcher() {
              var instance = this.instance;
              var $menu = instance.getMenu();
              if (this.menuSizeWatcher)
                return;
              this.menuSizeWatcher = {
                remove: watchSize($menu, this.adjustMenuOpenDirection)
              };
            },
            setupMenuResizeAndScrollEventListeners: function setupMenuResizeAndScrollEventListeners() {
              var instance = this.instance;
              var $control = instance.getControl();
              if (this.menuResizeAndScrollEventListeners)
                return;
              this.menuResizeAndScrollEventListeners = {
                remove: setupResizeAndScrollEventListeners($control, this.adjustMenuOpenDirection)
              };
            },
            removeMenuSizeWatcher: function removeMenuSizeWatcher() {
              if (!this.menuSizeWatcher)
                return;
              this.menuSizeWatcher.remove();
              this.menuSizeWatcher = null;
            },
            removeMenuResizeAndScrollEventListeners: function removeMenuResizeAndScrollEventListeners() {
              if (!this.menuResizeAndScrollEventListeners)
                return;
              this.menuResizeAndScrollEventListeners.remove();
              this.menuResizeAndScrollEventListeners = null;
            }
          },
          render: function render2() {
            return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
              "ref": "menu-container",
              "class": "vue-treeselect__menu-container",
              "style": this.menuContainerStyle
            }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
              "name": "vue-treeselect__menu--transition"
            }, [this.renderMenu()])]);
          }
        };
        const Menu_exports_ = Menuvue_type_script_lang_js;
        var Menu = Menu_exports_;
        function MenuPortalvue_type_script_lang_js_ownKeys(object, enumerableOnly) {
          var keys = Object.keys(object);
          if (Object.getOwnPropertySymbols) {
            var symbols = Object.getOwnPropertySymbols(object);
            enumerableOnly && (symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            })), keys.push.apply(keys, symbols);
          }
          return keys;
        }
        function MenuPortalvue_type_script_lang_js_objectSpread(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = null != arguments[i] ? arguments[i] : {};
            i % 2 ? MenuPortalvue_type_script_lang_js_ownKeys(Object(source), true).forEach(function(key) {
              MenuPortalvue_type_script_lang_js_defineProperty(target, key, source[key]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : MenuPortalvue_type_script_lang_js_ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
          return target;
        }
        function MenuPortalvue_type_script_lang_js_defineProperty(obj, key, value) {
          if (key in obj) {
            Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        var PortalTarget = {
          name: "vue-treeselect--portal-target",
          inject: ["instance"],
          watch: {
            "instance.menu.isOpen": function instanceMenuIsOpen(newValue) {
              if (newValue) {
                this.setupHandlers();
              } else {
                this.removeHandlers();
              }
            },
            "instance.menu.placement": function instanceMenuPlacement() {
              this.updateMenuContainerOffset();
            }
          },
          created: function created() {
            this.controlResizeAndScrollEventListeners = null;
            this.controlSizeWatcher = null;
          },
          mounted: function mounted() {
            var instance = this.instance;
            if (instance.menu.isOpen)
              this.setupHandlers();
          },
          methods: {
            setupHandlers: function setupHandlers() {
              this.updateWidth();
              this.updateMenuContainerOffset();
              this.setupControlResizeAndScrollEventListeners();
              this.setupControlSizeWatcher();
            },
            removeHandlers: function removeHandlers() {
              this.removeControlResizeAndScrollEventListeners();
              this.removeControlSizeWatcher();
            },
            setupControlResizeAndScrollEventListeners: function setupControlResizeAndScrollEventListeners() {
              var instance = this.instance;
              var $control = instance.getControl();
              if (this.controlResizeAndScrollEventListeners)
                return;
              this.controlResizeAndScrollEventListeners = {
                remove: setupResizeAndScrollEventListeners($control, this.updateMenuContainerOffset)
              };
            },
            setupControlSizeWatcher: function setupControlSizeWatcher() {
              var _this = this;
              var instance = this.instance;
              var $control = instance.getControl();
              if (this.controlSizeWatcher)
                return;
              this.controlSizeWatcher = {
                remove: watchSize($control, function() {
                  _this.updateWidth();
                  _this.updateMenuContainerOffset();
                })
              };
            },
            removeControlResizeAndScrollEventListeners: function removeControlResizeAndScrollEventListeners() {
              if (!this.controlResizeAndScrollEventListeners)
                return;
              this.controlResizeAndScrollEventListeners.remove();
              this.controlResizeAndScrollEventListeners = null;
            },
            removeControlSizeWatcher: function removeControlSizeWatcher() {
              if (!this.controlSizeWatcher)
                return;
              this.controlSizeWatcher.remove();
              this.controlSizeWatcher = null;
            },
            updateWidth: function updateWidth() {
              var instance = this.instance;
              var $portalTarget = this.$el;
              var $control = instance.getControl();
              var controlRect = $control.getBoundingClientRect();
              $portalTarget.style.width = controlRect.width + "px";
            },
            updateMenuContainerOffset: function updateMenuContainerOffset() {
              var instance = this.instance;
              var $control = instance.getControl();
              var $portalTarget = this.$el;
              var controlRect = $control.getBoundingClientRect();
              var portalTargetRect = $portalTarget.getBoundingClientRect();
              var offsetY = instance.menu.placement === "bottom" ? controlRect.height : 0;
              var left = Math.round(controlRect.left - portalTargetRect.left) + "px";
              var top = Math.round(controlRect.top - portalTargetRect.top + offsetY) + "px";
              var menuContainerStyle = this.$refs.menu.$refs["menu-container"].style;
              var transformVariations = ["transform", "webkitTransform", "MozTransform", "msTransform"];
              var transform = find(transformVariations, function(t) {
                return t in document.body.style;
              });
              menuContainerStyle[transform] = "translate(".concat(left, ", ").concat(top, ")");
            }
          },
          render: function render2() {
            var instance = this.instance;
            var portalTargetClass = ["vue-treeselect__portal-target", instance.wrapperClass];
            var portalTargetStyle = {
              zIndex: instance.zIndex
            };
            return (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
              "class": portalTargetClass,
              "style": portalTargetStyle,
              "data-instance-id": instance.getInstanceId()
            }, [(0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)(Menu, {
              "ref": "menu"
            }, null)]);
          },
          unmounted: function unmounted() {
            this.removeHandlers();
          }
        };
        var placeholder;
        var MenuPortalvue_type_script_lang_js = {
          name: "vue-treeselect--menu-portal",
          created: function created() {
            this.portalTarget = null;
          },
          mounted: function mounted() {
            this.setup();
          },
          unmounted: function unmounted() {
            this.teardown();
          },
          methods: {
            setup: function setup() {
              var el = document.createElement("div");
              document.body.appendChild(el);
              this.portalTarget = (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createApp)(MenuPortalvue_type_script_lang_js_objectSpread({
                parent: this
              }, PortalTarget));
              this.portalTarget.mount(el);
            },
            teardown: function teardown() {
              document.body.removeChild(this.portalTarget.$el);
              this.portalTarget.$el.innerHTML = "";
              this.portalTarget.$destroy();
              this.portalTarget = null;
            }
          },
          render: function render2() {
            if (!placeholder)
              placeholder = (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.createVNode)("div", {
                "class": "vue-treeselect__menu-placeholder"
              }, null);
            return placeholder;
          }
        };
        const MenuPortal_exports_ = MenuPortalvue_type_script_lang_js;
        var MenuPortal = MenuPortal_exports_;
        var Treeselectvue_type_script_lang_js = (0, external_commonjs_vue_commonjs2_vue_root_Vue_namespaceObject.defineComponent)({
          name: "vue-treeselect",
          mixins: [treeselectMixin],
          components: {
            HiddenFields,
            Control,
            Menu,
            MenuPortal
          },
          computed: {
            wrapperClass: function wrapperClass() {
              return {
                "vue-treeselect": true,
                "vue-treeselect--single": this.single,
                "vue-treeselect--multi": this.multiple,
                "vue-treeselect--searchable": this.searchable,
                "vue-treeselect--disabled": this.disabled,
                "vue-treeselect--focused": this.trigger.isFocused,
                "vue-treeselect--has-value": this.hasValue,
                "vue-treeselect--open": this.menu.isOpen,
                "vue-treeselect--open-above": this.menu.placement === "top",
                "vue-treeselect--open-below": this.menu.placement === "bottom",
                "vue-treeselect--branch-nodes-disabled": this.disableBranchNodes,
                "vue-treeselect--append-to-body": this.appendToBody
              };
            }
          }
          // render() {
          //   return (
          //     <div ref="wrapper" class={this.wrapperClass}>
          //       <HiddenFields />
          //       <Control ref="control" />
          //       {this.appendToBody ? <MenuPortal ref="portal" /> : <Menu ref="menu" />}
          //     </div>
          //   )
          // },
        });
        const Treeselect_exports_ = /* @__PURE__ */ (0, exportHelper.Z)(Treeselectvue_type_script_lang_js, [["render", render]]);
        var Treeselect2 = Treeselect_exports_;
        var src_0 = Treeselect2;
        var entry_lib = src_0;
      }();
      module2.exports = __webpack_exports__;
    })();
  })(vue3Treeselect_common);
  var vue3Treeselect_commonExports = vue3Treeselect_common.exports;
  const Treeselect = /* @__PURE__ */ getDefaultExportFromCjs(vue3Treeselect_commonExports);
  const vue3Treeselect = "";
  const _sfc_main$d = {
    name: "resource-fieldtype",
    mixins: [FieldMixin],
    components: { Treeselect },
    data() {
      return {
        matrix: {},
        form: false,
        loading: false,
        entries: null
      };
    },
    computed: {
      endpoint() {
        return `/datatable/antfusion/resource/${this.field.settings.resource}`;
      }
      // entry() {
      //     if (this.matrix.name) {
      //         return this.matrix.name.toLowerCase()
      //     } else {
      //         return 'entries'
      //     }
      // },
      // singular() {
      //     return pluralize.singular(this.entry)
      // }
    },
    methods: {
      getQueryParameters(params) {
        if (params.search !== "") {
          params["filter[search]"] = params.search;
        }
        return queryString.stringify(params);
      },
      itemMap(item) {
        return {
          id: item.id,
          label: item.name
        };
      },
      asyncFind({ action, searchQuery, callback }) {
        console.log(action);
        if (action === "ASYNC_SEARCH") {
          this.getRecords({ search: searchQuery }).then((response) => {
            console.log(response.data.records.data);
            callback(null, response.data.records.data.map(this.itemMap));
          });
        }
      },
      submit() {
      },
      // resetForm() {
      //     this.form = new Form({
      //         name: '',
      //         slug: '',
      //         status: 1,
      //     })
      // },
      getRecords(params) {
        this.loading = true;
        return axios.get(`${this.endpoint}?${this.getQueryParameters(params)}`).then((response) => {
          this.loading = false;
          return response;
        });
      }
      // fetchMatrix() {
      //     axios.get(`/api/matrices/${this.field.settings.matrix}?entries=1`).then((response) => {
      //         this.matrix = response.data.data
      //     })
      // }
    },
    mounted() {
      this.model = _.map(this.value, "id") || [];
    }
  };
  function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_treeselect = require$$0$1.resolveComponent("treeselect");
    const _component_ui_field_group = require$$0$1.resolveComponent("ui-field-group");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      require$$0$1.createVNode(_component_ui_field_group, {
        label: _ctx.field.name,
        fieldId: `${_ctx.field.handle}-field`,
        name: _ctx.field.handle,
        inline: false,
        help: _ctx.field.help,
        required: _ctx.field.required,
        "has-error": _ctx.hasError(_ctx.field.handle),
        "error-message": _ctx.errorMessage(_ctx.field.handle)
      }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createVNode(_component_treeselect, {
            async: true,
            "load-options": $options.asyncFind,
            modelValue: _ctx.model,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.model = $event),
            multiple: _ctx.field.settings.multiple
          }, null, 8, ["load-options", "modelValue", "multiple"])
        ], void 0, true),
        _: 1
      }, 8, ["label", "fieldId", "name", "help", "required", "has-error", "error-message"])
    ]);
  }
  const Field = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
  const Field$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Field
  }, Symbol.toStringTag, { value: "Module" }));
  const fieldtype = {
    props: {
      value: {
        type: Object,
        required: true
      }
    },
    computed: {
      settings: {
        get() {
          return this.value.settings || {};
        },
        set(value) {
          this.$set(this.value.settings, value);
        }
      },
      errors() {
        return this.value.errors || {};
      }
    }
  };
  const _sfc_main$c = {
    name: "taxonomy-fieldtype-settings",
    mixins: [fieldtype],
    data() {
      return {
        taxonomies: []
      };
    },
    computed: {
      options() {
        return _.map(this.taxonomies, (taxonomy) => {
          return {
            label: taxonomy.name,
            value: taxonomy.id
          };
        });
      }
    },
    created() {
      axios.get("/api/taxonomies").then((response) => this.taxonomies = response.data.data);
    }
  };
  const _hoisted_1$8 = { class: "row" };
  function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ui_select_group = require$$0$1.resolveComponent("ui-select-group");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_1$8, [
      require$$0$1.createVNode(_component_ui_select_group, {
        class: "col w-full sm:w-1/2",
        name: "taxonomy",
        label: "Taxonomy",
        help: "The taxonomy from which to show terms.",
        autocomplete: "off",
        options: $options.options,
        "has-error": _ctx.errors.has("settings.taxonomy"),
        "error-message": _ctx.errors.get("settings.taxonomy"),
        modelValue: _ctx.settings.taxonomy,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.settings.taxonomy = $event)
      }, null, 8, ["options", "has-error", "error-message", "modelValue"])
    ]);
  }
  const Settings = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
  const Settings$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Settings
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$b = {
    props: {
      value: {},
      options: {}
    },
    methods: {
      activated(value) {
        this.$emit("input", value);
      }
    }
  };
  function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ui_tab = require$$0$1.resolveComponent("ui-tab");
    const _component_ui_tabs = require$$0$1.resolveComponent("ui-tabs");
    return require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_tabs, null, {
      default: require$$0$1.withCtx(() => [
        (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($props.options, (optionValue, name2) => {
          return require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_tab, {
            key: optionValue,
            name: name2,
            onActivated: ($event) => $options.activated(optionValue)
          }, null, 8, ["name", "onActivated"]);
        }), 128))
      ], void 0, true),
      _: 1
    });
  }
  const FilterTabs = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
  const FilterTabs$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: FilterTabs
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$a = {
    props: {
      validateUrl: {},
      syncDependantFieldUrl: {},
      path: {},
      steps: {},
      value: {},
      form: {},
      footer: {},
      validateOnLastStep: {
        default: true
      },
      nextButton: {
        default: {}
      },
      prevButton: {
        default: {}
      },
      submitButton: {
        default: {}
      }
    },
    watch: {
      fieldValues: {
        handler(value) {
          Object.keys(value).forEach((key) => {
            this.form[key] = value[key];
          });
          this.$emit("input", this.form);
        },
        deep: true
      }
    },
    data() {
      return {
        loading: false,
        componentsByHandle: {},
        currentStep: 0,
        fieldValues: this.form
      };
    },
    computed: {
      hasPreviousStep() {
        return this.currentStep > 0;
      },
      hasNextStep() {
        return this.currentStep < this.steps.length - 1;
      }
    },
    mounted() {
      _.each(this.steps, (step) => {
        _.each(step.children, (component, fieldKey) => {
          this.$set(this.componentsByHandle, component.id, component);
          if (component.dependsOn) {
            this.registerWatch(component, step.children, fieldKey);
          }
        });
      });
    },
    methods: {
      registerWatch(fieldToBeUpdated, fieldCollections, fieldKey) {
        fieldToBeUpdated.dependsOn.forEach((attribute) => {
          this.$watch("form." + attribute, (value, oldValue) => {
            this.syncDependantFields(fieldToBeUpdated, attribute, fieldCollections, fieldKey);
          }, { deep: true });
        });
      },
      syncDependantFields(fieldToBeUpdated, dependsOnAttribute, fieldCollections, fieldKey) {
        let params = {
          field: fieldToBeUpdated.handle,
          path: fieldToBeUpdated.path,
          attribute: dependsOnAttribute,
          form: this.form.data()
        };
        axios.patch(this.syncDependantFieldUrl, params).then((response) => {
          let field = response.data;
          console.log("before", fieldCollections[fieldKey]);
          this.$set(fieldCollections, fieldKey, field);
          console.log("after", fieldCollections[fieldKey]);
        });
      },
      validate() {
        let params = {
          step: this.currentStep,
          path: this.path,
          form: this.form.data()
        };
        return axios.post(this.validateUrl, params);
      },
      submit() {
        this.next();
      },
      next() {
        if (this.hasNextStep || this.validateOnLastStep) {
          this.loading = true;
          this.validate().then((response) => {
            this.loading = false;
            if (this.hasNextStep) {
              this.currentStep++;
            } else {
              this.$refs.submit.click();
            }
          }).catch((error) => {
            this.loading = false;
            console.log(error.response.data);
            this.form.errors.record(error.response.data);
          });
        } else {
          this.$refs.submit.click();
        }
      },
      prev() {
        if (this.hasPreviousStep) {
          this.currentStep--;
        }
      }
    }
  };
  const _hoisted_1$7 = { key: 0 };
  const _hoisted_2$3 = { ref: "submit" };
  function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_ui_button = require$$0$1.resolveComponent("ui-button");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($props.steps, (step, index) => {
        return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", { key: index }, [
          index == $data.currentStep ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_1$7, [
            (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList(step.children, (field, index2) => {
              return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", { key: index2 }, [
                !field.is_panel ? require$$0$1.withDirectives((require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(field.component), require$$0$1.mergeProps({ key: 0 }, field, {
                  modelValue: $data.fieldValues[field.field.handle],
                  "onUpdate:modelValue": ($event) => $data.fieldValues[field.field.handle] = $event
                }, {
                  errors: $props.form.errors,
                  hasError: $props.form.errors.has(field.field.handle),
                  errorMessage: $props.form.errors.get(field.field.handle)
                }), {
                  default: require$$0$1.withCtx(() => [
                    require$$0$1.createTextVNode(require$$0$1.toDisplayString(field.text), 1)
                  ], void 0, true),
                  _: 2
                }, 1040, ["modelValue", "onUpdate:modelValue", "errors", "hasError", "errorMessage"])), [
                  [require$$0$1.vShow, !field.hide]
                ]) : require$$0$1.withDirectives((require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(field.component), require$$0$1.mergeProps({ key: 1 }, field, {
                  modelValue: $data.fieldValues,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.fieldValues = $event),
                  form: $props.form,
                  errors: $props.form.errors
                }), {
                  default: require$$0$1.withCtx(() => [
                    require$$0$1.createTextVNode(require$$0$1.toDisplayString(field.text), 1)
                  ], void 0, true),
                  _: 2
                }, 1040, ["modelValue", "form", "errors"])), [
                  [require$$0$1.vShow, !field.hide]
                ])
              ]);
            }), 128))
          ])) : require$$0$1.createCommentVNode("", true)
        ]);
      }), 128)),
      require$$0$1.createElementVNode("div", require$$0$1.normalizeProps(require$$0$1.guardReactiveProps($props.footer)), [
        require$$0$1.withDirectives(require$$0$1.createVNode(_component_ui_button, require$$0$1.mergeProps($props.prevButton, { disabled: $data.loading }, {
          onClick: require$$0$1.withModifiers($options.prev, ["prevent"])
        }), {
          default: require$$0$1.withCtx(() => [
            require$$0$1.createTextVNode(require$$0$1.toDisplayString($props.prevButton.text), 1)
          ], void 0, true),
          _: 1
        }, 16, ["disabled", "onClick"]), [
          [require$$0$1.vShow, $options.hasPreviousStep]
        ]),
        require$$0$1.withDirectives(require$$0$1.createVNode(_component_ui_button, require$$0$1.mergeProps($props.nextButton, { disabled: $data.loading }, {
          onClick: require$$0$1.withModifiers($options.next, ["prevent"])
        }), {
          default: require$$0$1.withCtx(() => [
            require$$0$1.createTextVNode(require$$0$1.toDisplayString($props.nextButton.text), 1)
          ], void 0, true),
          _: 1
        }, 16, ["disabled", "onClick"]), [
          [require$$0$1.vShow, $options.hasNextStep]
        ]),
        require$$0$1.withDirectives(require$$0$1.createVNode(_component_ui_button, require$$0$1.mergeProps($props.submitButton, { disabled: $data.loading }, {
          onClick: require$$0$1.withModifiers($options.submit, ["prevent"])
        }), {
          default: require$$0$1.withCtx(() => [
            require$$0$1.createTextVNode(require$$0$1.toDisplayString($props.submitButton.text), 1)
          ], void 0, true),
          _: 1
        }, 16, ["disabled", "onClick"]), [
          [require$$0$1.vShow, !$options.hasNextStep]
        ]),
        require$$0$1.withDirectives(require$$0$1.createElementVNode("button", _hoisted_2$3, null, 512), [
          [require$$0$1.vShow, false]
        ])
      ], 16)
    ]);
  }
  const SimpleWizard = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
  const SimpleWizard$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: SimpleWizard
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$9 = {
    props: {
      children: {}
    },
    watch: {},
    data() {
      return {};
    }
  };
  function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("table", require$$0$1.normalizeProps(require$$0$1.guardReactiveProps(_ctx.$props)), [
      require$$0$1.renderSlot(_ctx.$slots, "default")
    ], 16);
  }
  const Table = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
  const Table$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Table
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$8 = {
    props: {
      content: {},
      children: {}
    },
    watch: {},
    data() {
      return {};
    }
  };
  const _hoisted_1$6 = ["innerHTML"];
  const _hoisted_2$2 = { key: 1 };
  function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
    return $props.content ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("tr", {
      key: 0,
      innerHTML: $props.content
    }, null, 8, _hoisted_1$6)) : (require$$0$1.openBlock(), require$$0$1.createElementBlock("tr", _hoisted_2$2));
  }
  const TableHeaderRow = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
  const TableHeaderRow$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: TableHeaderRow
  }, Symbol.toStringTag, { value: "Module" }));
  const MetricItem_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$7 = {
    props: {
      icon: {},
      label: {},
      value: {},
      url: {},
      format: {
        default: false
      },
      decimalDigits: {
        default: 0
      }
    },
    computed: {
      valueString() {
        if (this.value && this.format) {
          return Number(this.value).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }
        return this.value;
      }
    }
  };
  const _hoisted_1$5 = { class: "col px-1 w-1/2 sm:w-1/4" };
  const _hoisted_2$1 = { class: "card" };
  const _hoisted_3 = { class: "card__body" };
  const _hoisted_4 = { class: "font-semibold uppercase" };
  const _hoisted_5 = { class: "text-2xl font-bold" };
  const _hoisted_6 = {
    key: 1,
    class: "text-right"
  };
  const _hoisted_7 = ["href"];
  function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_fa_icon = require$$0$1.resolveComponent("fa-icon");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_1$5, [
      require$$0$1.createElementVNode("div", _hoisted_2$1, [
        require$$0$1.createElementVNode("div", _hoisted_3, [
          $props.icon ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_fa_icon, {
            key: 0,
            icon: ["fas", $props.icon],
            "fixed-width": "",
            size: "2x"
          }, null, 8, ["icon"])) : require$$0$1.createCommentVNode("", true),
          require$$0$1.createElementVNode("div", _hoisted_4, require$$0$1.toDisplayString($props.label), 1),
          require$$0$1.createElementVNode("div", _hoisted_5, require$$0$1.toDisplayString($options.valueString), 1),
          $props.url ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_6, [
            require$$0$1.createElementVNode("a", {
              href: $props.url,
              class: ""
            }, "More", 8, _hoisted_7)
          ])) : require$$0$1.createCommentVNode("", true)
        ])
      ])
    ]);
  }
  const MetricItem = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
  const MetricItem$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: MetricItem
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$6 = {
    props: {
      components: {}
    },
    data() {
      return {
        loading: false
      };
    },
    methods: {
      onLoading() {
        this.loadingCount++;
      },
      onLoaded() {
        this.loadingCount--;
      }
    },
    computed: {
      loading() {
        return this.loadingCount > 0;
      }
    }
  };
  function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", require$$0$1.normalizeProps(require$$0$1.guardReactiveProps(_ctx.$props)), [
      (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($props.components, (component, index) => {
        return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(component.component), require$$0$1.mergeProps(component, {
          loading: $options.loading,
          onLoad: $options.onLoading,
          onLoaded: $options.onLoaded,
          key: index
        }), null, 16, ["loading", "onLoad", "onLoaded"]);
      }), 128))
    ], 16);
  }
  const ComponentContainer = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
  const ComponentContainer$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: ComponentContainer
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$5 = {
    data() {
      return {
        meta: null,
        resource: null,
        actions: null
      };
    },
    computed: {
      dropdownActions() {
        return this.actions.filter((action) => action.dropdown);
      }
    },
    beforeRouteUpdate(to, from, next) {
      axios.get("/api/antfusion/resource/" + to.params.resource).then((response) => {
        this.meta = response.data;
        this.resource = response.data.resource;
        this.actions = response.data.actions;
        console.log(response.data);
        next();
      }).catch((error) => {
        if (error.response.data.errors && error.response.data.errors["*"]) {
          let errors = error.response.data.errors["*"];
          toast(errors.join(" "), "error");
        } else {
          toast(error.response.data.message, "error");
        }
      });
    },
    beforeRouteEnter(to, from, next) {
      axios.get("/api/antfusion/resource/" + to.params.resource).then((response) => {
        next((vm2) => {
          vm2.meta = response.data;
          vm2.resource = response.data.resource;
          vm2.actions = response.data.actions;
          console.log(response.data);
        });
      }).catch((error) => {
        if (error.response.data.errors && error.response.data.errors["*"]) {
          let errors = error.response.data.errors["*"];
          toast(errors.join(" "), "error");
        } else {
          toast(error.response.data.message, "error");
        }
      });
    }
  };
  const _hoisted_1$4 = { key: 0 };
  function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_page_title = require$$0$1.resolveComponent("page-title");
    const _component_portal = require$$0$1.resolveComponent("portal");
    const _component_ui_actions = require$$0$1.resolveComponent("ui-actions");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      require$$0$1.createVNode(_component_portal, { to: "title" }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createVNode(_component_page_title, {
            icon: $data.resource.icon
          }, {
            default: require$$0$1.withCtx(() => [
              require$$0$1.createTextVNode(require$$0$1.toDisplayString($data.meta.title), 1)
            ], void 0, true),
            _: 1
          }, 8, ["icon"])
        ], void 0, true),
        _: 1
      }),
      require$$0$1.createVNode(_component_portal, { to: "actions" }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createElementVNode("div", null, [
            (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($data.actions, (action, index) => {
              return require$$0$1.openBlock(), require$$0$1.createElementBlock("span", { key: index }, [
                !action.dropdown ? (require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(action.component), require$$0$1.mergeProps({ key: 0 }, action, { onSubmitted: _ctx.load }), {
                  default: require$$0$1.withCtx(() => [
                    require$$0$1.createTextVNode(require$$0$1.toDisplayString(action.text), 1)
                  ], void 0, true),
                  _: 2
                }, 1040, ["onSubmitted"])) : require$$0$1.createCommentVNode("", true)
              ]);
            }), 128)),
            $options.dropdownActions && $options.dropdownActions.length ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_ui_actions, {
              id: "entry_actions",
              key: "entry_actions"
            }, {
              default: require$$0$1.withCtx(() => [
                (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($data.actions, (action, index) => {
                  return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", { key: index }, [
                    action.dropdown ? (require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(action.component), require$$0$1.mergeProps({ key: 0 }, action, { onSubmitted: _ctx.load }), {
                      default: require$$0$1.withCtx(() => [
                        require$$0$1.createTextVNode(require$$0$1.toDisplayString(action.text), 1)
                      ], void 0, true),
                      _: 2
                    }, 1040, ["onSubmitted"])) : require$$0$1.createCommentVNode("", true)
                  ]);
                }), 128))
              ], void 0, true),
              _: 1
            })) : require$$0$1.createCommentVNode("", true)
          ])
        ], void 0, true),
        _: 1
      }),
      $data.meta && $data.meta.components ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_1$4, [
        (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($data.meta.components, (component, index) => {
          return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(component.is), require$$0$1.mergeProps(component, {
            class: "form__group",
            key: component.id
          }), null, 16);
        }), 128))
      ])) : require$$0$1.createCommentVNode("", true)
    ]);
  }
  const Index$4 = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
  const Index$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Index$4
  }, Symbol.toStringTag, { value: "Module" }));
  var HOOKS = [
    "onChange",
    "onClose",
    "onDayCreate",
    "onDestroy",
    "onKeyDown",
    "onMonthChange",
    "onOpen",
    "onParseConfig",
    "onReady",
    "onValueUpdate",
    "onYearChange",
    "onPreCalendarPosition"
  ];
  var defaults = {
    _disable: [],
    allowInput: false,
    allowInvalidPreload: false,
    altFormat: "F j, Y",
    altInput: false,
    altInputClass: "form-control input",
    animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
    ariaDateFormat: "F j, Y",
    autoFillDefaultTime: true,
    clickOpens: true,
    closeOnSelect: true,
    conjunction: ", ",
    dateFormat: "Y-m-d",
    defaultHour: 12,
    defaultMinute: 0,
    defaultSeconds: 0,
    disable: [],
    disableMobile: false,
    enableSeconds: false,
    enableTime: false,
    errorHandler: function(err) {
      return typeof console !== "undefined" && console.warn(err);
    },
    getWeek: function(givenDate) {
      var date = new Date(givenDate.getTime());
      date.setHours(0, 0, 0, 0);
      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
      var week1 = new Date(date.getFullYear(), 0, 4);
      return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
    },
    hourIncrement: 1,
    ignoredFocusElements: [],
    inline: false,
    locale: "default",
    minuteIncrement: 5,
    mode: "single",
    monthSelectorType: "dropdown",
    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
    noCalendar: false,
    now: /* @__PURE__ */ new Date(),
    onChange: [],
    onClose: [],
    onDayCreate: [],
    onDestroy: [],
    onKeyDown: [],
    onMonthChange: [],
    onOpen: [],
    onParseConfig: [],
    onReady: [],
    onValueUpdate: [],
    onYearChange: [],
    onPreCalendarPosition: [],
    plugins: [],
    position: "auto",
    positionElement: void 0,
    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
    shorthandCurrentMonth: false,
    showMonths: 1,
    static: false,
    time_24hr: false,
    weekNumbers: false,
    wrap: false
  };
  var english = {
    weekdays: {
      shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      longhand: [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ]
    },
    months: {
      shorthand: [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ],
      longhand: [
        "January",
        "February",
        "March",
        "April",
        "May",
        "June",
        "July",
        "August",
        "September",
        "October",
        "November",
        "December"
      ]
    },
    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    firstDayOfWeek: 0,
    ordinal: function(nth) {
      var s = nth % 100;
      if (s > 3 && s < 21)
        return "th";
      switch (s % 10) {
        case 1:
          return "st";
        case 2:
          return "nd";
        case 3:
          return "rd";
        default:
          return "th";
      }
    },
    rangeSeparator: " to ",
    weekAbbreviation: "Wk",
    scrollTitle: "Scroll to increment",
    toggleTitle: "Click to toggle",
    amPM: ["AM", "PM"],
    yearAriaLabel: "Year",
    monthAriaLabel: "Month",
    hourAriaLabel: "Hour",
    minuteAriaLabel: "Minute",
    time_24hr: false
  };
  var pad = function(number, length) {
    if (length === void 0) {
      length = 2;
    }
    return ("000" + number).slice(length * -1);
  };
  var int = function(bool) {
    return bool === true ? 1 : 0;
  };
  function debounce(fn, wait) {
    var t;
    return function() {
      var _this = this;
      var args = arguments;
      clearTimeout(t);
      t = setTimeout(function() {
        return fn.apply(_this, args);
      }, wait);
    };
  }
  var arrayify = function(obj) {
    return obj instanceof Array ? obj : [obj];
  };
  function toggleClass(elem, className, bool) {
    if (bool === true)
      return elem.classList.add(className);
    elem.classList.remove(className);
  }
  function createElement(tag, className, content) {
    var e = window.document.createElement(tag);
    className = className || "";
    content = content || "";
    e.className = className;
    if (content !== void 0)
      e.textContent = content;
    return e;
  }
  function clearNode(node) {
    while (node.firstChild)
      node.removeChild(node.firstChild);
  }
  function findParent(node, condition) {
    if (condition(node))
      return node;
    else if (node.parentNode)
      return findParent(node.parentNode, condition);
    return void 0;
  }
  function createNumberInput(inputClassName, opts) {
    var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
      numInput.type = "number";
    } else {
      numInput.type = "text";
      numInput.pattern = "\\d*";
    }
    if (opts !== void 0)
      for (var key in opts)
        numInput.setAttribute(key, opts[key]);
    wrapper.appendChild(numInput);
    wrapper.appendChild(arrowUp);
    wrapper.appendChild(arrowDown);
    return wrapper;
  }
  function getEventTarget(event) {
    try {
      if (typeof event.composedPath === "function") {
        var path = event.composedPath();
        return path[0];
      }
      return event.target;
    } catch (error) {
      return event.target;
    }
  }
  var doNothing = function() {
    return void 0;
  };
  var monthToStr = function(monthNumber, shorthand, locale) {
    return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
  };
  var revFormat = {
    D: doNothing,
    F: function(dateObj, monthName, locale) {
      dateObj.setMonth(locale.months.longhand.indexOf(monthName));
    },
    G: function(dateObj, hour) {
      dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    H: function(dateObj, hour) {
      dateObj.setHours(parseFloat(hour));
    },
    J: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    K: function(dateObj, amPM, locale) {
      dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
    },
    M: function(dateObj, shortMonth, locale) {
      dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
    },
    S: function(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    U: function(_2, unixSeconds) {
      return new Date(parseFloat(unixSeconds) * 1e3);
    },
    W: function(dateObj, weekNum, locale) {
      var weekNumber = parseInt(weekNum);
      var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
      date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
      return date;
    },
    Y: function(dateObj, year) {
      dateObj.setFullYear(parseFloat(year));
    },
    Z: function(_2, ISODate) {
      return new Date(ISODate);
    },
    d: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    h: function(dateObj, hour) {
      dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    i: function(dateObj, minutes) {
      dateObj.setMinutes(parseFloat(minutes));
    },
    j: function(dateObj, day) {
      dateObj.setDate(parseFloat(day));
    },
    l: doNothing,
    m: function(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    n: function(dateObj, month) {
      dateObj.setMonth(parseFloat(month) - 1);
    },
    s: function(dateObj, seconds) {
      dateObj.setSeconds(parseFloat(seconds));
    },
    u: function(_2, unixMillSeconds) {
      return new Date(parseFloat(unixMillSeconds));
    },
    w: doNothing,
    y: function(dateObj, year) {
      dateObj.setFullYear(2e3 + parseFloat(year));
    }
  };
  var tokenRegex = {
    D: "",
    F: "",
    G: "(\\d\\d|\\d)",
    H: "(\\d\\d|\\d)",
    J: "(\\d\\d|\\d)\\w+",
    K: "",
    M: "",
    S: "(\\d\\d|\\d)",
    U: "(.+)",
    W: "(\\d\\d|\\d)",
    Y: "(\\d{4})",
    Z: "(.+)",
    d: "(\\d\\d|\\d)",
    h: "(\\d\\d|\\d)",
    i: "(\\d\\d|\\d)",
    j: "(\\d\\d|\\d)",
    l: "",
    m: "(\\d\\d|\\d)",
    n: "(\\d\\d|\\d)",
    s: "(\\d\\d|\\d)",
    u: "(.+)",
    w: "(\\d\\d|\\d)",
    y: "(\\d{2})"
  };
  var formats = {
    Z: function(date) {
      return date.toISOString();
    },
    D: function(date, locale, options) {
      return locale.weekdays.shorthand[formats.w(date, locale, options)];
    },
    F: function(date, locale, options) {
      return monthToStr(formats.n(date, locale, options) - 1, false, locale);
    },
    G: function(date, locale, options) {
      return pad(formats.h(date, locale, options));
    },
    H: function(date) {
      return pad(date.getHours());
    },
    J: function(date, locale) {
      return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
    },
    K: function(date, locale) {
      return locale.amPM[int(date.getHours() > 11)];
    },
    M: function(date, locale) {
      return monthToStr(date.getMonth(), true, locale);
    },
    S: function(date) {
      return pad(date.getSeconds());
    },
    U: function(date) {
      return date.getTime() / 1e3;
    },
    W: function(date, _2, options) {
      return options.getWeek(date);
    },
    Y: function(date) {
      return pad(date.getFullYear(), 4);
    },
    d: function(date) {
      return pad(date.getDate());
    },
    h: function(date) {
      return date.getHours() % 12 ? date.getHours() % 12 : 12;
    },
    i: function(date) {
      return pad(date.getMinutes());
    },
    j: function(date) {
      return date.getDate();
    },
    l: function(date, locale) {
      return locale.weekdays.longhand[date.getDay()];
    },
    m: function(date) {
      return pad(date.getMonth() + 1);
    },
    n: function(date) {
      return date.getMonth() + 1;
    },
    s: function(date) {
      return date.getSeconds();
    },
    u: function(date) {
      return date.getTime();
    },
    w: function(date) {
      return date.getDay();
    },
    y: function(date) {
      return String(date.getFullYear()).substring(2);
    }
  };
  var createDateFormatter = function(_a) {
    var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
    return function(dateObj, frmt, overrideLocale) {
      var locale = overrideLocale || l10n;
      if (config.formatDate !== void 0 && !isMobile) {
        return config.formatDate(dateObj, frmt, locale);
      }
      return frmt.split("").map(function(c, i, arr) {
        return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
      }).join("");
    };
  };
  var createDateParser = function(_a) {
    var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
    return function(date, givenFormat, timeless, customLocale) {
      if (date !== 0 && !date)
        return void 0;
      var locale = customLocale || l10n;
      var parsedDate;
      var dateOrig = date;
      if (date instanceof Date)
        parsedDate = new Date(date.getTime());
      else if (typeof date !== "string" && date.toFixed !== void 0)
        parsedDate = new Date(date);
      else if (typeof date === "string") {
        var format = givenFormat || (config || defaults).dateFormat;
        var datestr = String(date).trim();
        if (datestr === "today") {
          parsedDate = /* @__PURE__ */ new Date();
          timeless = true;
        } else if (config && config.parseDate) {
          parsedDate = config.parseDate(date, format);
        } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
          parsedDate = new Date(date);
        } else {
          var matched = void 0, ops = [];
          for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
            var token2 = format[i];
            var isBackSlash = token2 === "\\";
            var escaped = format[i - 1] === "\\" || isBackSlash;
            if (tokenRegex[token2] && !escaped) {
              regexStr += tokenRegex[token2];
              var match = new RegExp(regexStr).exec(date);
              if (match && (matched = true)) {
                ops[token2 !== "Y" ? "push" : "unshift"]({
                  fn: revFormat[token2],
                  val: match[++matchIndex]
                });
              }
            } else if (!isBackSlash)
              regexStr += ".";
          }
          parsedDate = !config || !config.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
          ops.forEach(function(_a2) {
            var fn = _a2.fn, val = _a2.val;
            return parsedDate = fn(parsedDate, val, locale) || parsedDate;
          });
          parsedDate = matched ? parsedDate : void 0;
        }
      }
      if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
        config.errorHandler(new Error("Invalid date provided: " + dateOrig));
        return void 0;
      }
      if (timeless === true)
        parsedDate.setHours(0, 0, 0, 0);
      return parsedDate;
    };
  };
  function compareDates(date1, date2, timeless) {
    if (timeless === void 0) {
      timeless = true;
    }
    if (timeless !== false) {
      return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
    }
    return date1.getTime() - date2.getTime();
  }
  var isBetween = function(ts, ts1, ts2) {
    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
  };
  var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
    return hours * 3600 + minutes * 60 + seconds;
  };
  var parseSeconds = function(secondsSinceMidnight) {
    var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
    return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
  };
  var duration = {
    DAY: 864e5
  };
  function getDefaultHours(config) {
    var hours = config.defaultHour;
    var minutes = config.defaultMinute;
    var seconds = config.defaultSeconds;
    if (config.minDate !== void 0) {
      var minHour = config.minDate.getHours();
      var minMinutes = config.minDate.getMinutes();
      var minSeconds = config.minDate.getSeconds();
      if (hours < minHour) {
        hours = minHour;
      }
      if (hours === minHour && minutes < minMinutes) {
        minutes = minMinutes;
      }
      if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
        seconds = config.minDate.getSeconds();
    }
    if (config.maxDate !== void 0) {
      var maxHr = config.maxDate.getHours();
      var maxMinutes = config.maxDate.getMinutes();
      hours = Math.min(hours, maxHr);
      if (hours === maxHr)
        minutes = Math.min(maxMinutes, minutes);
      if (hours === maxHr && minutes === maxMinutes)
        seconds = config.maxDate.getSeconds();
    }
    return { hours, minutes, seconds };
  }
  if (typeof Object.assign !== "function") {
    Object.assign = function(target) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      if (!target) {
        throw TypeError("Cannot convert undefined or null to object");
      }
      var _loop_1 = function(source2) {
        if (source2) {
          Object.keys(source2).forEach(function(key) {
            return target[key] = source2[key];
          });
        }
      };
      for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var source = args_1[_a];
        _loop_1(source);
      }
      return target;
    };
  }
  var __assign = globalThis && globalThis.__assign || function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __spreadArrays = globalThis && globalThis.__spreadArrays || function() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++)
      s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a2 = arguments[i], j = 0, jl = a2.length; j < jl; j++, k++)
        r[k] = a2[j];
    return r;
  };
  var DEBOUNCED_CHANGE_MS = 300;
  function FlatpickrInstance(element, instanceConfig) {
    var self2 = {
      config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
      l10n: english
    };
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
    self2._handlers = [];
    self2.pluginElements = [];
    self2.loadedPlugins = [];
    self2._bind = bind2;
    self2._setHoursFromDate = setHoursFromDate;
    self2._positionCalendar = positionCalendar;
    self2.changeMonth = changeMonth;
    self2.changeYear = changeYear;
    self2.clear = clear;
    self2.close = close;
    self2.onMouseOver = onMouseOver;
    self2._createElement = createElement;
    self2.createDay = createDay;
    self2.destroy = destroy;
    self2.isEnabled = isEnabled;
    self2.jumpToDate = jumpToDate;
    self2.updateValue = updateValue;
    self2.open = open;
    self2.redraw = redraw;
    self2.set = set;
    self2.setDate = setDate;
    self2.toggle = toggle;
    function setupHelperFunctions() {
      self2.utils = {
        getDaysInMonth: function(month, yr) {
          if (month === void 0) {
            month = self2.currentMonth;
          }
          if (yr === void 0) {
            yr = self2.currentYear;
          }
          if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
            return 29;
          return self2.l10n.daysInMonth[month];
        }
      };
    }
    function init() {
      self2.element = self2.input = element;
      self2.isOpen = false;
      parseConfig();
      setupLocale();
      setupInputs();
      setupDates();
      setupHelperFunctions();
      if (!self2.isMobile)
        build();
      bindEvents();
      if (self2.selectedDates.length || self2.config.noCalendar) {
        if (self2.config.enableTime) {
          setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
        }
        updateValue(false);
      }
      setCalendarWidth();
      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (!self2.isMobile && isSafari) {
        positionCalendar();
      }
      triggerEvent("onReady");
    }
    function getClosestActiveElement() {
      var _a;
      return ((_a = self2.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
    }
    function bindToInstance(fn) {
      return fn.bind(self2);
    }
    function setCalendarWidth() {
      var config = self2.config;
      if (config.weekNumbers === false && config.showMonths === 1) {
        return;
      } else if (config.noCalendar !== true) {
        window.requestAnimationFrame(function() {
          if (self2.calendarContainer !== void 0) {
            self2.calendarContainer.style.visibility = "hidden";
            self2.calendarContainer.style.display = "block";
          }
          if (self2.daysContainer !== void 0) {
            var daysWidth = (self2.days.offsetWidth + 1) * config.showMonths;
            self2.daysContainer.style.width = daysWidth + "px";
            self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
            self2.calendarContainer.style.removeProperty("visibility");
            self2.calendarContainer.style.removeProperty("display");
          }
        });
      }
    }
    function updateTime(e) {
      if (self2.selectedDates.length === 0) {
        var defaultDate = self2.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
        var defaults2 = getDefaultHours(self2.config);
        defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
        self2.selectedDates = [defaultDate];
        self2.latestSelectedDateObj = defaultDate;
      }
      if (e !== void 0 && e.type !== "blur") {
        timeWrapper(e);
      }
      var prevValue = self2._input.value;
      setHoursFromInputs();
      updateValue();
      if (self2._input.value !== prevValue) {
        self2._debouncedChange();
      }
    }
    function ampm2military(hour, amPM) {
      return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
    }
    function military2ampm(hour) {
      switch (hour % 24) {
        case 0:
        case 12:
          return 12;
        default:
          return hour % 12;
      }
    }
    function setHoursFromInputs() {
      if (self2.hourElement === void 0 || self2.minuteElement === void 0)
        return;
      var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
      if (self2.amPM !== void 0) {
        hours = ampm2military(hours, self2.amPM.textContent);
      }
      var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
      var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
      if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
        var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
        var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
        var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
        if (currentTime > maxBound && currentTime < minBound) {
          var result = parseSeconds(minBound);
          hours = result[0];
          minutes = result[1];
          seconds = result[2];
        }
      } else {
        if (limitMaxHours) {
          var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
          hours = Math.min(hours, maxTime.getHours());
          if (hours === maxTime.getHours())
            minutes = Math.min(minutes, maxTime.getMinutes());
          if (minutes === maxTime.getMinutes())
            seconds = Math.min(seconds, maxTime.getSeconds());
        }
        if (limitMinHours) {
          var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
          hours = Math.max(hours, minTime.getHours());
          if (hours === minTime.getHours() && minutes < minTime.getMinutes())
            minutes = minTime.getMinutes();
          if (minutes === minTime.getMinutes())
            seconds = Math.max(seconds, minTime.getSeconds());
        }
      }
      setHours(hours, minutes, seconds);
    }
    function setHoursFromDate(dateObj) {
      var date = dateObj || self2.latestSelectedDateObj;
      if (date && date instanceof Date) {
        setHours(date.getHours(), date.getMinutes(), date.getSeconds());
      }
    }
    function setHours(hours, minutes, seconds) {
      if (self2.latestSelectedDateObj !== void 0) {
        self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
      }
      if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
        return;
      self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
      self2.minuteElement.value = pad(minutes);
      if (self2.amPM !== void 0)
        self2.amPM.textContent = self2.l10n.amPM[int(hours >= 12)];
      if (self2.secondElement !== void 0)
        self2.secondElement.value = pad(seconds);
    }
    function onYearInput(event) {
      var eventTarget = getEventTarget(event);
      var year = parseInt(eventTarget.value) + (event.delta || 0);
      if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
        changeYear(year);
      }
    }
    function bind2(element2, event, handler, options) {
      if (event instanceof Array)
        return event.forEach(function(ev) {
          return bind2(element2, ev, handler, options);
        });
      if (element2 instanceof Array)
        return element2.forEach(function(el) {
          return bind2(el, event, handler, options);
        });
      element2.addEventListener(event, handler, options);
      self2._handlers.push({
        remove: function() {
          return element2.removeEventListener(event, handler, options);
        }
      });
    }
    function triggerChange() {
      triggerEvent("onChange");
    }
    function bindEvents() {
      if (self2.config.wrap) {
        ["open", "close", "toggle", "clear"].forEach(function(evt) {
          Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
            return bind2(el, "click", self2[evt]);
          });
        });
      }
      if (self2.isMobile) {
        setupMobile();
        return;
      }
      var debouncedResize = debounce(onResize, 50);
      self2._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
      if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
        bind2(self2.daysContainer, "mouseover", function(e) {
          if (self2.config.mode === "range")
            onMouseOver(getEventTarget(e));
        });
      bind2(self2._input, "keydown", onKeyDown);
      if (self2.calendarContainer !== void 0) {
        bind2(self2.calendarContainer, "keydown", onKeyDown);
      }
      if (!self2.config.inline && !self2.config.static)
        bind2(window, "resize", debouncedResize);
      if (window.ontouchstart !== void 0)
        bind2(window.document, "touchstart", documentClick);
      else
        bind2(window.document, "mousedown", documentClick);
      bind2(window.document, "focus", documentClick, { capture: true });
      if (self2.config.clickOpens === true) {
        bind2(self2._input, "focus", self2.open);
        bind2(self2._input, "click", self2.open);
      }
      if (self2.daysContainer !== void 0) {
        bind2(self2.monthNav, "click", onMonthNavClick);
        bind2(self2.monthNav, ["keyup", "increment"], onYearInput);
        bind2(self2.daysContainer, "click", selectDate);
      }
      if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
        var selText = function(e) {
          return getEventTarget(e).select();
        };
        bind2(self2.timeContainer, ["increment"], updateTime);
        bind2(self2.timeContainer, "blur", updateTime, { capture: true });
        bind2(self2.timeContainer, "click", timeIncrement);
        bind2([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
        if (self2.secondElement !== void 0)
          bind2(self2.secondElement, "focus", function() {
            return self2.secondElement && self2.secondElement.select();
          });
        if (self2.amPM !== void 0) {
          bind2(self2.amPM, "click", function(e) {
            updateTime(e);
          });
        }
      }
      if (self2.config.allowInput) {
        bind2(self2._input, "blur", onBlur);
      }
    }
    function jumpToDate(jumpDate, triggerChange2) {
      var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
      var oldYear = self2.currentYear;
      var oldMonth = self2.currentMonth;
      try {
        if (jumpTo !== void 0) {
          self2.currentYear = jumpTo.getFullYear();
          self2.currentMonth = jumpTo.getMonth();
        }
      } catch (e) {
        e.message = "Invalid date supplied: " + jumpTo;
        self2.config.errorHandler(e);
      }
      if (triggerChange2 && self2.currentYear !== oldYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
        triggerEvent("onMonthChange");
      }
      self2.redraw();
    }
    function timeIncrement(e) {
      var eventTarget = getEventTarget(e);
      if (~eventTarget.className.indexOf("arrow"))
        incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
    }
    function incrementNumInput(e, delta, inputElem) {
      var target = e && getEventTarget(e);
      var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
      var event = createEvent("increment");
      event.delta = delta;
      input && input.dispatchEvent(event);
    }
    function build() {
      var fragment = window.document.createDocumentFragment();
      self2.calendarContainer = createElement("div", "flatpickr-calendar");
      self2.calendarContainer.tabIndex = -1;
      if (!self2.config.noCalendar) {
        fragment.appendChild(buildMonthNav());
        self2.innerContainer = createElement("div", "flatpickr-innerContainer");
        if (self2.config.weekNumbers) {
          var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
          self2.innerContainer.appendChild(weekWrapper);
          self2.weekNumbers = weekNumbers;
          self2.weekWrapper = weekWrapper;
        }
        self2.rContainer = createElement("div", "flatpickr-rContainer");
        self2.rContainer.appendChild(buildWeekdays());
        if (!self2.daysContainer) {
          self2.daysContainer = createElement("div", "flatpickr-days");
          self2.daysContainer.tabIndex = -1;
        }
        buildDays();
        self2.rContainer.appendChild(self2.daysContainer);
        self2.innerContainer.appendChild(self2.rContainer);
        fragment.appendChild(self2.innerContainer);
      }
      if (self2.config.enableTime) {
        fragment.appendChild(buildTime());
      }
      toggleClass(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
      toggleClass(self2.calendarContainer, "animate", self2.config.animate === true);
      toggleClass(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
      self2.calendarContainer.appendChild(fragment);
      var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
      if (self2.config.inline || self2.config.static) {
        self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
        if (self2.config.inline) {
          if (!customAppend && self2.element.parentNode)
            self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
          else if (self2.config.appendTo !== void 0)
            self2.config.appendTo.appendChild(self2.calendarContainer);
        }
        if (self2.config.static) {
          var wrapper = createElement("div", "flatpickr-wrapper");
          if (self2.element.parentNode)
            self2.element.parentNode.insertBefore(wrapper, self2.element);
          wrapper.appendChild(self2.element);
          if (self2.altInput)
            wrapper.appendChild(self2.altInput);
          wrapper.appendChild(self2.calendarContainer);
        }
      }
      if (!self2.config.static && !self2.config.inline)
        (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
    }
    function createDay(className, date, _dayNumber, i) {
      var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", className, date.getDate().toString());
      dayElement.dateObj = date;
      dayElement.$i = i;
      dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
      if (className.indexOf("hidden") === -1 && compareDates(date, self2.now) === 0) {
        self2.todayDateElem = dayElement;
        dayElement.classList.add("today");
        dayElement.setAttribute("aria-current", "date");
      }
      if (dateIsEnabled) {
        dayElement.tabIndex = -1;
        if (isDateSelected(date)) {
          dayElement.classList.add("selected");
          self2.selectedDateElem = dayElement;
          if (self2.config.mode === "range") {
            toggleClass(dayElement, "startRange", self2.selectedDates[0] && compareDates(date, self2.selectedDates[0], true) === 0);
            toggleClass(dayElement, "endRange", self2.selectedDates[1] && compareDates(date, self2.selectedDates[1], true) === 0);
            if (className === "nextMonthDay")
              dayElement.classList.add("inRange");
          }
        }
      } else {
        dayElement.classList.add("flatpickr-disabled");
      }
      if (self2.config.mode === "range") {
        if (isDateInRange(date) && !isDateSelected(date))
          dayElement.classList.add("inRange");
      }
      if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i % 7 === 6) {
        self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
      }
      triggerEvent("onDayCreate", dayElement);
      return dayElement;
    }
    function focusOnDayElem(targetNode) {
      targetNode.focus();
      if (self2.config.mode === "range")
        onMouseOver(targetNode);
    }
    function getFirstAvailableDay(delta) {
      var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
      var endMonth = delta > 0 ? self2.config.showMonths : -1;
      for (var m = startMonth; m != endMonth; m += delta) {
        var month = self2.daysContainer.children[m];
        var startIndex = delta > 0 ? 0 : month.children.length - 1;
        var endIndex = delta > 0 ? month.children.length : -1;
        for (var i = startIndex; i != endIndex; i += delta) {
          var c = month.children[i];
          if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
            return c;
        }
      }
      return void 0;
    }
    function getNextAvailableDay(current, delta) {
      var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
      var endMonth = delta > 0 ? self2.config.showMonths : -1;
      var loopDelta = delta > 0 ? 1 : -1;
      for (var m = givenMonth - self2.currentMonth; m != endMonth; m += loopDelta) {
        var month = self2.daysContainer.children[m];
        var startIndex = givenMonth - self2.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
        var numMonthDays = month.children.length;
        for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
          var c = month.children[i];
          if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta))
            return focusOnDayElem(c);
        }
      }
      self2.changeMonth(loopDelta);
      focusOnDay(getFirstAvailableDay(loopDelta), 0);
      return void 0;
    }
    function focusOnDay(current, offset) {
      var activeElement = getClosestActiveElement();
      var dayFocused = isInView(activeElement || document.body);
      var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
      if (startElem === void 0) {
        self2._input.focus();
      } else if (!dayFocused) {
        focusOnDayElem(startElem);
      } else {
        getNextAvailableDay(startElem, offset);
      }
    }
    function buildMonthDays(year, month) {
      var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
      var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
      var daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
      var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
      for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
      }
      for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
      }
      for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
        days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
      }
      var dayContainer = createElement("div", "dayContainer");
      dayContainer.appendChild(days);
      return dayContainer;
    }
    function buildDays() {
      if (self2.daysContainer === void 0) {
        return;
      }
      clearNode(self2.daysContainer);
      if (self2.weekNumbers)
        clearNode(self2.weekNumbers);
      var frag = document.createDocumentFragment();
      for (var i = 0; i < self2.config.showMonths; i++) {
        var d = new Date(self2.currentYear, self2.currentMonth, 1);
        d.setMonth(self2.currentMonth + i);
        frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
      }
      self2.daysContainer.appendChild(frag);
      self2.days = self2.daysContainer.firstChild;
      if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
        onMouseOver();
      }
    }
    function buildMonthSwitch() {
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
        return;
      var shouldBuildMonth = function(month2) {
        if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
          return false;
        }
        return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
      };
      self2.monthsDropdownContainer.tabIndex = -1;
      self2.monthsDropdownContainer.innerHTML = "";
      for (var i = 0; i < 12; i++) {
        if (!shouldBuildMonth(i))
          continue;
        var month = createElement("option", "flatpickr-monthDropdown-month");
        month.value = new Date(self2.currentYear, i).getMonth().toString();
        month.textContent = monthToStr(i, self2.config.shorthandCurrentMonth, self2.l10n);
        month.tabIndex = -1;
        if (self2.currentMonth === i) {
          month.selected = true;
        }
        self2.monthsDropdownContainer.appendChild(month);
      }
    }
    function buildMonth() {
      var container = createElement("div", "flatpickr-month");
      var monthNavFragment = window.document.createDocumentFragment();
      var monthElement;
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        monthElement = createElement("span", "cur-month");
      } else {
        self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
        self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
        bind2(self2.monthsDropdownContainer, "change", function(e) {
          var target = getEventTarget(e);
          var selectedMonth = parseInt(target.value, 10);
          self2.changeMonth(selectedMonth - self2.currentMonth);
          triggerEvent("onMonthChange");
        });
        buildMonthSwitch();
        monthElement = self2.monthsDropdownContainer;
      }
      var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
      var yearElement = yearInput.getElementsByTagName("input")[0];
      yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
      if (self2.config.minDate) {
        yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
      }
      if (self2.config.maxDate) {
        yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
        yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
      }
      var currentMonth = createElement("div", "flatpickr-current-month");
      currentMonth.appendChild(monthElement);
      currentMonth.appendChild(yearInput);
      monthNavFragment.appendChild(currentMonth);
      container.appendChild(monthNavFragment);
      return {
        container,
        yearElement,
        monthElement
      };
    }
    function buildMonths() {
      clearNode(self2.monthNav);
      self2.monthNav.appendChild(self2.prevMonthNav);
      if (self2.config.showMonths) {
        self2.yearElements = [];
        self2.monthElements = [];
      }
      for (var m = self2.config.showMonths; m--; ) {
        var month = buildMonth();
        self2.yearElements.push(month.yearElement);
        self2.monthElements.push(month.monthElement);
        self2.monthNav.appendChild(month.container);
      }
      self2.monthNav.appendChild(self2.nextMonthNav);
    }
    function buildMonthNav() {
      self2.monthNav = createElement("div", "flatpickr-months");
      self2.yearElements = [];
      self2.monthElements = [];
      self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
      self2.prevMonthNav.innerHTML = self2.config.prevArrow;
      self2.nextMonthNav = createElement("span", "flatpickr-next-month");
      self2.nextMonthNav.innerHTML = self2.config.nextArrow;
      buildMonths();
      Object.defineProperty(self2, "_hidePrevMonthArrow", {
        get: function() {
          return self2.__hidePrevMonthArrow;
        },
        set: function(bool) {
          if (self2.__hidePrevMonthArrow !== bool) {
            toggleClass(self2.prevMonthNav, "flatpickr-disabled", bool);
            self2.__hidePrevMonthArrow = bool;
          }
        }
      });
      Object.defineProperty(self2, "_hideNextMonthArrow", {
        get: function() {
          return self2.__hideNextMonthArrow;
        },
        set: function(bool) {
          if (self2.__hideNextMonthArrow !== bool) {
            toggleClass(self2.nextMonthNav, "flatpickr-disabled", bool);
            self2.__hideNextMonthArrow = bool;
          }
        }
      });
      self2.currentYearElement = self2.yearElements[0];
      updateNavigationCurrentMonth();
      return self2.monthNav;
    }
    function buildTime() {
      self2.calendarContainer.classList.add("hasTime");
      if (self2.config.noCalendar)
        self2.calendarContainer.classList.add("noCalendar");
      var defaults2 = getDefaultHours(self2.config);
      self2.timeContainer = createElement("div", "flatpickr-time");
      self2.timeContainer.tabIndex = -1;
      var separator = createElement("span", "flatpickr-time-separator", ":");
      var hourInput = createNumberInput("flatpickr-hour", {
        "aria-label": self2.l10n.hourAriaLabel
      });
      self2.hourElement = hourInput.getElementsByTagName("input")[0];
      var minuteInput = createNumberInput("flatpickr-minute", {
        "aria-label": self2.l10n.minuteAriaLabel
      });
      self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
      self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
      self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
      self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults2.minutes);
      self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
      self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
      self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
      self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
      self2.hourElement.setAttribute("maxlength", "2");
      self2.minuteElement.setAttribute("min", "0");
      self2.minuteElement.setAttribute("max", "59");
      self2.minuteElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(hourInput);
      self2.timeContainer.appendChild(separator);
      self2.timeContainer.appendChild(minuteInput);
      if (self2.config.time_24hr)
        self2.timeContainer.classList.add("time24hr");
      if (self2.config.enableSeconds) {
        self2.timeContainer.classList.add("hasSeconds");
        var secondInput = createNumberInput("flatpickr-second");
        self2.secondElement = secondInput.getElementsByTagName("input")[0];
        self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults2.seconds);
        self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
        self2.secondElement.setAttribute("min", "0");
        self2.secondElement.setAttribute("max", "59");
        self2.secondElement.setAttribute("maxlength", "2");
        self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
        self2.timeContainer.appendChild(secondInput);
      }
      if (!self2.config.time_24hr) {
        self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
        self2.amPM.title = self2.l10n.toggleTitle;
        self2.amPM.tabIndex = -1;
        self2.timeContainer.appendChild(self2.amPM);
      }
      return self2.timeContainer;
    }
    function buildWeekdays() {
      if (!self2.weekdayContainer)
        self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
      else
        clearNode(self2.weekdayContainer);
      for (var i = self2.config.showMonths; i--; ) {
        var container = createElement("div", "flatpickr-weekdaycontainer");
        self2.weekdayContainer.appendChild(container);
      }
      updateWeekdays();
      return self2.weekdayContainer;
    }
    function updateWeekdays() {
      if (!self2.weekdayContainer) {
        return;
      }
      var firstDayOfWeek = self2.l10n.firstDayOfWeek;
      var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
      if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
        weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
      }
      for (var i = self2.config.showMonths; i--; ) {
        self2.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
      }
    }
    function buildWeeks() {
      self2.calendarContainer.classList.add("hasWeeks");
      var weekWrapper = createElement("div", "flatpickr-weekwrapper");
      weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
      var weekNumbers = createElement("div", "flatpickr-weeks");
      weekWrapper.appendChild(weekNumbers);
      return {
        weekWrapper,
        weekNumbers
      };
    }
    function changeMonth(value, isOffset) {
      if (isOffset === void 0) {
        isOffset = true;
      }
      var delta = isOffset ? value : value - self2.currentMonth;
      if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
        return;
      self2.currentMonth += delta;
      if (self2.currentMonth < 0 || self2.currentMonth > 11) {
        self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
        self2.currentMonth = (self2.currentMonth + 12) % 12;
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      buildDays();
      triggerEvent("onMonthChange");
      updateNavigationCurrentMonth();
    }
    function clear(triggerChangeEvent, toInitial) {
      if (triggerChangeEvent === void 0) {
        triggerChangeEvent = true;
      }
      if (toInitial === void 0) {
        toInitial = true;
      }
      self2.input.value = "";
      if (self2.altInput !== void 0)
        self2.altInput.value = "";
      if (self2.mobileInput !== void 0)
        self2.mobileInput.value = "";
      self2.selectedDates = [];
      self2.latestSelectedDateObj = void 0;
      if (toInitial === true) {
        self2.currentYear = self2._initialDate.getFullYear();
        self2.currentMonth = self2._initialDate.getMonth();
      }
      if (self2.config.enableTime === true) {
        var _a = getDefaultHours(self2.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
        setHours(hours, minutes, seconds);
      }
      self2.redraw();
      if (triggerChangeEvent)
        triggerEvent("onChange");
    }
    function close() {
      self2.isOpen = false;
      if (!self2.isMobile) {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.classList.remove("open");
        }
        if (self2._input !== void 0) {
          self2._input.classList.remove("active");
        }
      }
      triggerEvent("onClose");
    }
    function destroy() {
      if (self2.config !== void 0)
        triggerEvent("onDestroy");
      for (var i = self2._handlers.length; i--; ) {
        self2._handlers[i].remove();
      }
      self2._handlers = [];
      if (self2.mobileInput) {
        if (self2.mobileInput.parentNode)
          self2.mobileInput.parentNode.removeChild(self2.mobileInput);
        self2.mobileInput = void 0;
      } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
        if (self2.config.static && self2.calendarContainer.parentNode) {
          var wrapper = self2.calendarContainer.parentNode;
          wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
          if (wrapper.parentNode) {
            while (wrapper.firstChild)
              wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
            wrapper.parentNode.removeChild(wrapper);
          }
        } else
          self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
      }
      if (self2.altInput) {
        self2.input.type = "text";
        if (self2.altInput.parentNode)
          self2.altInput.parentNode.removeChild(self2.altInput);
        delete self2.altInput;
      }
      if (self2.input) {
        self2.input.type = self2.input._type;
        self2.input.classList.remove("flatpickr-input");
        self2.input.removeAttribute("readonly");
      }
      [
        "_showTimeInput",
        "latestSelectedDateObj",
        "_hideNextMonthArrow",
        "_hidePrevMonthArrow",
        "__hideNextMonthArrow",
        "__hidePrevMonthArrow",
        "isMobile",
        "isOpen",
        "selectedDateElem",
        "minDateHasTime",
        "maxDateHasTime",
        "days",
        "daysContainer",
        "_input",
        "_positionElement",
        "innerContainer",
        "rContainer",
        "monthNav",
        "todayDateElem",
        "calendarContainer",
        "weekdayContainer",
        "prevMonthNav",
        "nextMonthNav",
        "monthsDropdownContainer",
        "currentMonthElement",
        "currentYearElement",
        "navigationCurrentMonth",
        "selectedDateElem",
        "config"
      ].forEach(function(k) {
        try {
          delete self2[k];
        } catch (_2) {
        }
      });
    }
    function isCalendarElem(elem) {
      return self2.calendarContainer.contains(elem);
    }
    function documentClick(e) {
      if (self2.isOpen && !self2.config.inline) {
        var eventTarget_1 = getEventTarget(e);
        var isCalendarElement = isCalendarElem(eventTarget_1);
        var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e.path && e.path.indexOf && (~e.path.indexOf(self2.input) || ~e.path.indexOf(self2.altInput));
        var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
        var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
          return elem.contains(eventTarget_1);
        });
        if (lostFocus && isIgnored) {
          if (self2.config.allowInput) {
            self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
          }
          if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
            updateTime();
          }
          self2.close();
          if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
            self2.clear(false);
        }
      }
    }
    function changeYear(newYear) {
      if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
        return;
      var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
      self2.currentYear = newYearNum || self2.currentYear;
      if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
        self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
      } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
        self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
      }
      if (isNewYear) {
        self2.redraw();
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
    }
    function isEnabled(date, timeless) {
      var _a;
      if (timeless === void 0) {
        timeless = true;
      }
      var dateToCheck = self2.parseDate(date, void 0, timeless);
      if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
        return false;
      if (!self2.config.enable && self2.config.disable.length === 0)
        return true;
      if (dateToCheck === void 0)
        return false;
      var bool = !!self2.config.enable, array = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
      for (var i = 0, d = void 0; i < array.length; i++) {
        d = array[i];
        if (typeof d === "function" && d(dateToCheck))
          return bool;
        else if (d instanceof Date && dateToCheck !== void 0 && d.getTime() === dateToCheck.getTime())
          return bool;
        else if (typeof d === "string") {
          var parsed = self2.parseDate(d, void 0, true);
          return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
        } else if (typeof d === "object" && dateToCheck !== void 0 && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime())
          return bool;
      }
      return !bool;
    }
    function isInView(elem) {
      if (self2.daysContainer !== void 0)
        return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
      return false;
    }
    function onBlur(e) {
      var isInput = e.target === self2._input;
      var valueChanged = self2._input.value.trimEnd() !== getDateStr();
      if (isInput && valueChanged && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
        self2.setDate(self2._input.value, true, e.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
      }
    }
    function onKeyDown(e) {
      var eventTarget = getEventTarget(e);
      var isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
      var allowInput = self2.config.allowInput;
      var allowKeydown = self2.isOpen && (!allowInput || !isInput);
      var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
      if (e.keyCode === 13 && isInput) {
        if (allowInput) {
          self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
          self2.close();
          return eventTarget.blur();
        } else {
          self2.open();
        }
      } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
        var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
        switch (e.keyCode) {
          case 13:
            if (isTimeObj) {
              e.preventDefault();
              updateTime();
              focusAndClose();
            } else
              selectDate(e);
            break;
          case 27:
            e.preventDefault();
            focusAndClose();
            break;
          case 8:
          case 46:
            if (isInput && !self2.config.allowInput) {
              e.preventDefault();
              self2.clear();
            }
            break;
          case 37:
          case 39:
            if (!isTimeObj && !isInput) {
              e.preventDefault();
              var activeElement = getClosestActiveElement();
              if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
                var delta_1 = e.keyCode === 39 ? 1 : -1;
                if (!e.ctrlKey)
                  focusOnDay(void 0, delta_1);
                else {
                  e.stopPropagation();
                  changeMonth(delta_1);
                  focusOnDay(getFirstAvailableDay(1), 0);
                }
              }
            } else if (self2.hourElement)
              self2.hourElement.focus();
            break;
          case 38:
          case 40:
            e.preventDefault();
            var delta = e.keyCode === 40 ? 1 : -1;
            if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
              if (e.ctrlKey) {
                e.stopPropagation();
                changeYear(self2.currentYear - delta);
                focusOnDay(getFirstAvailableDay(1), 0);
              } else if (!isTimeObj)
                focusOnDay(void 0, delta * 7);
            } else if (eventTarget === self2.currentYearElement) {
              changeYear(self2.currentYear - delta);
            } else if (self2.config.enableTime) {
              if (!isTimeObj && self2.hourElement)
                self2.hourElement.focus();
              updateTime(e);
              self2._debouncedChange();
            }
            break;
          case 9:
            if (isTimeObj) {
              var elems = [
                self2.hourElement,
                self2.minuteElement,
                self2.secondElement,
                self2.amPM
              ].concat(self2.pluginElements).filter(function(x) {
                return x;
              });
              var i = elems.indexOf(eventTarget);
              if (i !== -1) {
                var target = elems[i + (e.shiftKey ? -1 : 1)];
                e.preventDefault();
                (target || self2._input).focus();
              }
            } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e.shiftKey) {
              e.preventDefault();
              self2._input.focus();
            }
            break;
        }
      }
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        switch (e.key) {
          case self2.l10n.amPM[0].charAt(0):
          case self2.l10n.amPM[0].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[0];
            setHoursFromInputs();
            updateValue();
            break;
          case self2.l10n.amPM[1].charAt(0):
          case self2.l10n.amPM[1].charAt(0).toLowerCase():
            self2.amPM.textContent = self2.l10n.amPM[1];
            setHoursFromInputs();
            updateValue();
            break;
        }
      }
      if (isInput || isCalendarElem(eventTarget)) {
        triggerEvent("onKeyDown", e);
      }
    }
    function onMouseOver(elem, cellClass) {
      if (cellClass === void 0) {
        cellClass = "flatpickr-day";
      }
      if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
        return;
      var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
      var containsDisabled = false;
      var minRange = 0, maxRange = 0;
      for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
        if (!isEnabled(new Date(t), true)) {
          containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
          if (t < initialDate && (!minRange || t > minRange))
            minRange = t;
          else if (t > initialDate && (!maxRange || t < maxRange))
            maxRange = t;
        }
      }
      var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
      hoverableCells.forEach(function(dayElem) {
        var date = dayElem.dateObj;
        var timestamp = date.getTime();
        var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
        if (outOfRange) {
          dayElem.classList.add("notAllowed");
          ["inRange", "startRange", "endRange"].forEach(function(c) {
            dayElem.classList.remove(c);
          });
          return;
        } else if (containsDisabled && !outOfRange)
          return;
        ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c) {
          dayElem.classList.remove(c);
        });
        if (elem !== void 0) {
          elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
          if (initialDate < hoverDate && timestamp === initialDate)
            dayElem.classList.add("startRange");
          else if (initialDate > hoverDate && timestamp === initialDate)
            dayElem.classList.add("endRange");
          if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
            dayElem.classList.add("inRange");
        }
      });
    }
    function onResize() {
      if (self2.isOpen && !self2.config.static && !self2.config.inline)
        positionCalendar();
    }
    function open(e, positionElement) {
      if (positionElement === void 0) {
        positionElement = self2._positionElement;
      }
      if (self2.isMobile === true) {
        if (e) {
          e.preventDefault();
          var eventTarget = getEventTarget(e);
          if (eventTarget) {
            eventTarget.blur();
          }
        }
        if (self2.mobileInput !== void 0) {
          self2.mobileInput.focus();
          self2.mobileInput.click();
        }
        triggerEvent("onOpen");
        return;
      } else if (self2._input.disabled || self2.config.inline) {
        return;
      }
      var wasOpen = self2.isOpen;
      self2.isOpen = true;
      if (!wasOpen) {
        self2.calendarContainer.classList.add("open");
        self2._input.classList.add("active");
        triggerEvent("onOpen");
        positionCalendar(positionElement);
      }
      if (self2.config.enableTime === true && self2.config.noCalendar === true) {
        if (self2.config.allowInput === false && (e === void 0 || !self2.timeContainer.contains(e.relatedTarget))) {
          setTimeout(function() {
            return self2.hourElement.select();
          }, 50);
        }
      }
    }
    function minMaxDateSetter(type) {
      return function(date) {
        var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date, self2.config.dateFormat);
        var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
        if (dateObj !== void 0) {
          self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
        }
        if (self2.selectedDates) {
          self2.selectedDates = self2.selectedDates.filter(function(d) {
            return isEnabled(d);
          });
          if (!self2.selectedDates.length && type === "min")
            setHoursFromDate(dateObj);
          updateValue();
        }
        if (self2.daysContainer) {
          redraw();
          if (dateObj !== void 0)
            self2.currentYearElement[type] = dateObj.getFullYear().toString();
          else
            self2.currentYearElement.removeAttribute(type);
          self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
        }
      };
    }
    function parseConfig() {
      var boolOpts = [
        "wrap",
        "weekNumbers",
        "allowInput",
        "allowInvalidPreload",
        "clickOpens",
        "time_24hr",
        "enableTime",
        "noCalendar",
        "altInput",
        "shorthandCurrentMonth",
        "inline",
        "static",
        "enableSeconds",
        "disableMobile"
      ];
      var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
      var formats2 = {};
      self2.config.parseDate = userConfig.parseDate;
      self2.config.formatDate = userConfig.formatDate;
      Object.defineProperty(self2.config, "enable", {
        get: function() {
          return self2.config._enable;
        },
        set: function(dates) {
          self2.config._enable = parseDateRules(dates);
        }
      });
      Object.defineProperty(self2.config, "disable", {
        get: function() {
          return self2.config._disable;
        },
        set: function(dates) {
          self2.config._disable = parseDateRules(dates);
        }
      });
      var timeMode = userConfig.mode === "time";
      if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
        var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
        formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
      }
      if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
        var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
        formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
      }
      Object.defineProperty(self2.config, "minDate", {
        get: function() {
          return self2.config._minDate;
        },
        set: minMaxDateSetter("min")
      });
      Object.defineProperty(self2.config, "maxDate", {
        get: function() {
          return self2.config._maxDate;
        },
        set: minMaxDateSetter("max")
      });
      var minMaxTimeSetter = function(type) {
        return function(val) {
          self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
        };
      };
      Object.defineProperty(self2.config, "minTime", {
        get: function() {
          return self2.config._minTime;
        },
        set: minMaxTimeSetter("min")
      });
      Object.defineProperty(self2.config, "maxTime", {
        get: function() {
          return self2.config._maxTime;
        },
        set: minMaxTimeSetter("max")
      });
      if (userConfig.mode === "time") {
        self2.config.noCalendar = true;
        self2.config.enableTime = true;
      }
      Object.assign(self2.config, formats2, userConfig);
      for (var i = 0; i < boolOpts.length; i++)
        self2.config[boolOpts[i]] = self2.config[boolOpts[i]] === true || self2.config[boolOpts[i]] === "true";
      HOOKS.filter(function(hook) {
        return self2.config[hook] !== void 0;
      }).forEach(function(hook) {
        self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
      });
      self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      for (var i = 0; i < self2.config.plugins.length; i++) {
        var pluginConf = self2.config.plugins[i](self2) || {};
        for (var key in pluginConf) {
          if (HOOKS.indexOf(key) > -1) {
            self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
          } else if (typeof userConfig[key] === "undefined")
            self2.config[key] = pluginConf[key];
        }
      }
      if (!userConfig.altInputClass) {
        self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
      }
      triggerEvent("onParseConfig");
    }
    function getInputElem() {
      return self2.config.wrap ? element.querySelector("[data-input]") : element;
    }
    function setupLocale() {
      if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
        self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
      self2.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
      tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
      tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
      tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
      tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
      tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
      var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
      if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
        self2.config.time_24hr = self2.l10n.time_24hr;
      }
      self2.formatDate = createDateFormatter(self2);
      self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
    }
    function positionCalendar(customPositionElement) {
      if (typeof self2.config.position === "function") {
        return void self2.config.position(self2, customPositionElement);
      }
      if (self2.calendarContainer === void 0)
        return;
      triggerEvent("onPreCalendarPosition");
      var positionElement = customPositionElement || self2._positionElement;
      var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
        return acc + child.offsetHeight;
      }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
      var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
      toggleClass(self2.calendarContainer, "arrowTop", !showOnTop);
      toggleClass(self2.calendarContainer, "arrowBottom", showOnTop);
      if (self2.config.inline)
        return;
      var left = window.pageXOffset + inputBounds.left;
      var isCenter = false;
      var isRight = false;
      if (configPosHorizontal === "center") {
        left -= (calendarWidth - inputBounds.width) / 2;
        isCenter = true;
      } else if (configPosHorizontal === "right") {
        left -= calendarWidth - inputBounds.width;
        isRight = true;
      }
      toggleClass(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
      toggleClass(self2.calendarContainer, "arrowCenter", isCenter);
      toggleClass(self2.calendarContainer, "arrowRight", isRight);
      var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
      var rightMost = left + calendarWidth > window.document.body.offsetWidth;
      var centerMost = right + calendarWidth > window.document.body.offsetWidth;
      toggleClass(self2.calendarContainer, "rightMost", rightMost);
      if (self2.config.static)
        return;
      self2.calendarContainer.style.top = top + "px";
      if (!rightMost) {
        self2.calendarContainer.style.left = left + "px";
        self2.calendarContainer.style.right = "auto";
      } else if (!centerMost) {
        self2.calendarContainer.style.left = "auto";
        self2.calendarContainer.style.right = right + "px";
      } else {
        var doc = getDocumentStyleSheet();
        if (doc === void 0)
          return;
        var bodyWidth = window.document.body.offsetWidth;
        var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
        var centerBefore = ".flatpickr-calendar.centerMost:before";
        var centerAfter = ".flatpickr-calendar.centerMost:after";
        var centerIndex = doc.cssRules.length;
        var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
        toggleClass(self2.calendarContainer, "rightMost", false);
        toggleClass(self2.calendarContainer, "centerMost", true);
        doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
        self2.calendarContainer.style.left = centerLeft + "px";
        self2.calendarContainer.style.right = "auto";
      }
    }
    function getDocumentStyleSheet() {
      var editableSheet = null;
      for (var i = 0; i < document.styleSheets.length; i++) {
        var sheet = document.styleSheets[i];
        if (!sheet.cssRules)
          continue;
        try {
          sheet.cssRules;
        } catch (err) {
          continue;
        }
        editableSheet = sheet;
        break;
      }
      return editableSheet != null ? editableSheet : createStyleSheet();
    }
    function createStyleSheet() {
      var style = document.createElement("style");
      document.head.appendChild(style);
      return style.sheet;
    }
    function redraw() {
      if (self2.config.noCalendar || self2.isMobile)
        return;
      buildMonthSwitch();
      updateNavigationCurrentMonth();
      buildDays();
    }
    function focusAndClose() {
      self2._input.focus();
      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
        setTimeout(self2.close, 0);
      } else {
        self2.close();
      }
    }
    function selectDate(e) {
      e.preventDefault();
      e.stopPropagation();
      var isSelectable = function(day) {
        return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
      };
      var t = findParent(getEventTarget(e), isSelectable);
      if (t === void 0)
        return;
      var target = t;
      var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
      var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
      self2.selectedDateElem = target;
      if (self2.config.mode === "single")
        self2.selectedDates = [selectedDate];
      else if (self2.config.mode === "multiple") {
        var selectedIndex = isDateSelected(selectedDate);
        if (selectedIndex)
          self2.selectedDates.splice(parseInt(selectedIndex), 1);
        else
          self2.selectedDates.push(selectedDate);
      } else if (self2.config.mode === "range") {
        if (self2.selectedDates.length === 2) {
          self2.clear(false, false);
        }
        self2.latestSelectedDateObj = selectedDate;
        self2.selectedDates.push(selectedDate);
        if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
          self2.selectedDates.sort(function(a2, b) {
            return a2.getTime() - b.getTime();
          });
      }
      setHoursFromInputs();
      if (shouldChangeMonth) {
        var isNewYear = self2.currentYear !== selectedDate.getFullYear();
        self2.currentYear = selectedDate.getFullYear();
        self2.currentMonth = selectedDate.getMonth();
        if (isNewYear) {
          triggerEvent("onYearChange");
          buildMonthSwitch();
        }
        triggerEvent("onMonthChange");
      }
      updateNavigationCurrentMonth();
      buildDays();
      updateValue();
      if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
        focusOnDayElem(target);
      else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
        self2.selectedDateElem && self2.selectedDateElem.focus();
      }
      if (self2.hourElement !== void 0)
        self2.hourElement !== void 0 && self2.hourElement.focus();
      if (self2.config.closeOnSelect) {
        var single = self2.config.mode === "single" && !self2.config.enableTime;
        var range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
        if (single || range) {
          focusAndClose();
        }
      }
      triggerChange();
    }
    var CALLBACKS = {
      locale: [setupLocale, updateWeekdays],
      showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
      minDate: [jumpToDate],
      maxDate: [jumpToDate],
      positionElement: [updatePositionElement],
      clickOpens: [
        function() {
          if (self2.config.clickOpens === true) {
            bind2(self2._input, "focus", self2.open);
            bind2(self2._input, "click", self2.open);
          } else {
            self2._input.removeEventListener("focus", self2.open);
            self2._input.removeEventListener("click", self2.open);
          }
        }
      ]
    };
    function set(option, value) {
      if (option !== null && typeof option === "object") {
        Object.assign(self2.config, option);
        for (var key in option) {
          if (CALLBACKS[key] !== void 0)
            CALLBACKS[key].forEach(function(x) {
              return x();
            });
        }
      } else {
        self2.config[option] = value;
        if (CALLBACKS[option] !== void 0)
          CALLBACKS[option].forEach(function(x) {
            return x();
          });
        else if (HOOKS.indexOf(option) > -1)
          self2.config[option] = arrayify(value);
      }
      self2.redraw();
      updateValue(true);
    }
    function setSelectedDate(inputDate, format) {
      var dates = [];
      if (inputDate instanceof Array)
        dates = inputDate.map(function(d) {
          return self2.parseDate(d, format);
        });
      else if (inputDate instanceof Date || typeof inputDate === "number")
        dates = [self2.parseDate(inputDate, format)];
      else if (typeof inputDate === "string") {
        switch (self2.config.mode) {
          case "single":
          case "time":
            dates = [self2.parseDate(inputDate, format)];
            break;
          case "multiple":
            dates = inputDate.split(self2.config.conjunction).map(function(date) {
              return self2.parseDate(date, format);
            });
            break;
          case "range":
            dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date) {
              return self2.parseDate(date, format);
            });
            break;
        }
      } else
        self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
      self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d) {
        return d instanceof Date && isEnabled(d, false);
      });
      if (self2.config.mode === "range")
        self2.selectedDates.sort(function(a2, b) {
          return a2.getTime() - b.getTime();
        });
    }
    function setDate(date, triggerChange2, format) {
      if (triggerChange2 === void 0) {
        triggerChange2 = false;
      }
      if (format === void 0) {
        format = self2.config.dateFormat;
      }
      if (date !== 0 && !date || date instanceof Array && date.length === 0)
        return self2.clear(triggerChange2);
      setSelectedDate(date, format);
      self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
      self2.redraw();
      jumpToDate(void 0, triggerChange2);
      setHoursFromDate();
      if (self2.selectedDates.length === 0) {
        self2.clear(false);
      }
      updateValue(triggerChange2);
      if (triggerChange2)
        triggerEvent("onChange");
    }
    function parseDateRules(arr) {
      return arr.slice().map(function(rule) {
        if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
          return self2.parseDate(rule, void 0, true);
        } else if (rule && typeof rule === "object" && rule.from && rule.to)
          return {
            from: self2.parseDate(rule.from, void 0),
            to: self2.parseDate(rule.to, void 0)
          };
        return rule;
      }).filter(function(x) {
        return x;
      });
    }
    function setupDates() {
      self2.selectedDates = [];
      self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
      var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
      if (preloadedDate)
        setSelectedDate(preloadedDate, self2.config.dateFormat);
      self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
      if (self2.selectedDates.length > 0)
        self2.latestSelectedDateObj = self2.selectedDates[0];
      if (self2.config.minTime !== void 0)
        self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
      if (self2.config.maxTime !== void 0)
        self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
      self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
      self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
    }
    function setupInputs() {
      self2.input = getInputElem();
      if (!self2.input) {
        self2.config.errorHandler(new Error("Invalid input element specified"));
        return;
      }
      self2.input._type = self2.input.type;
      self2.input.type = "text";
      self2.input.classList.add("flatpickr-input");
      self2._input = self2.input;
      if (self2.config.altInput) {
        self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
        self2._input = self2.altInput;
        self2.altInput.placeholder = self2.input.placeholder;
        self2.altInput.disabled = self2.input.disabled;
        self2.altInput.required = self2.input.required;
        self2.altInput.tabIndex = self2.input.tabIndex;
        self2.altInput.type = "text";
        self2.input.setAttribute("type", "hidden");
        if (!self2.config.static && self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
      }
      if (!self2.config.allowInput)
        self2._input.setAttribute("readonly", "readonly");
      updatePositionElement();
    }
    function updatePositionElement() {
      self2._positionElement = self2.config.positionElement || self2._input;
    }
    function setupMobile() {
      var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
      self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
      self2.mobileInput.tabIndex = 1;
      self2.mobileInput.type = inputType;
      self2.mobileInput.disabled = self2.input.disabled;
      self2.mobileInput.required = self2.input.required;
      self2.mobileInput.placeholder = self2.input.placeholder;
      self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
      if (self2.selectedDates.length > 0) {
        self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
      }
      if (self2.config.minDate)
        self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
      if (self2.config.maxDate)
        self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
      if (self2.input.getAttribute("step"))
        self2.mobileInput.step = String(self2.input.getAttribute("step"));
      self2.input.type = "hidden";
      if (self2.altInput !== void 0)
        self2.altInput.type = "hidden";
      try {
        if (self2.input.parentNode)
          self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
      } catch (_a) {
      }
      bind2(self2.mobileInput, "change", function(e) {
        self2.setDate(getEventTarget(e).value, false, self2.mobileFormatStr);
        triggerEvent("onChange");
        triggerEvent("onClose");
      });
    }
    function toggle(e) {
      if (self2.isOpen === true)
        return self2.close();
      self2.open(e);
    }
    function triggerEvent(event, data) {
      if (self2.config === void 0)
        return;
      var hooks = self2.config[event];
      if (hooks !== void 0 && hooks.length > 0) {
        for (var i = 0; hooks[i] && i < hooks.length; i++)
          hooks[i](self2.selectedDates, self2.input.value, self2, data);
      }
      if (event === "onChange") {
        self2.input.dispatchEvent(createEvent("change"));
        self2.input.dispatchEvent(createEvent("input"));
      }
    }
    function createEvent(name2) {
      var e = document.createEvent("Event");
      e.initEvent(name2, true, true);
      return e;
    }
    function isDateSelected(date) {
      for (var i = 0; i < self2.selectedDates.length; i++) {
        var selectedDate = self2.selectedDates[i];
        if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0)
          return "" + i;
      }
      return false;
    }
    function isDateInRange(date) {
      if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
        return false;
      return compareDates(date, self2.selectedDates[0]) >= 0 && compareDates(date, self2.selectedDates[1]) <= 0;
    }
    function updateNavigationCurrentMonth() {
      if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
        return;
      self2.yearElements.forEach(function(yearElement, i) {
        var d = new Date(self2.currentYear, self2.currentMonth, 1);
        d.setMonth(self2.currentMonth + i);
        if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
          self2.monthElements[i].textContent = monthToStr(d.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
        } else {
          self2.monthsDropdownContainer.value = d.getMonth().toString();
        }
        yearElement.value = d.getFullYear().toString();
      });
      self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
      self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
    }
    function getDateStr(specificFormat) {
      var format = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
      return self2.selectedDates.map(function(dObj) {
        return self2.formatDate(dObj, format);
      }).filter(function(d, i, arr) {
        return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d) === i;
      }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
    }
    function updateValue(triggerChange2) {
      if (triggerChange2 === void 0) {
        triggerChange2 = true;
      }
      if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
        self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
      }
      self2.input.value = getDateStr(self2.config.dateFormat);
      if (self2.altInput !== void 0) {
        self2.altInput.value = getDateStr(self2.config.altFormat);
      }
      if (triggerChange2 !== false)
        triggerEvent("onValueUpdate");
    }
    function onMonthNavClick(e) {
      var eventTarget = getEventTarget(e);
      var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
      var isNextMonth = self2.nextMonthNav.contains(eventTarget);
      if (isPrevMonth || isNextMonth) {
        changeMonth(isPrevMonth ? -1 : 1);
      } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
        eventTarget.select();
      } else if (eventTarget.classList.contains("arrowUp")) {
        self2.changeYear(self2.currentYear + 1);
      } else if (eventTarget.classList.contains("arrowDown")) {
        self2.changeYear(self2.currentYear - 1);
      }
    }
    function timeWrapper(e) {
      e.preventDefault();
      var isKeyDown = e.type === "keydown", eventTarget = getEventTarget(e), input = eventTarget;
      if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
      var newValue = curValue + step * delta;
      if (typeof input.value !== "undefined" && input.value.length === 2) {
        var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
        if (newValue < min) {
          newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
          if (isMinuteElem)
            incrementNumInput(void 0, -1, self2.hourElement);
        } else if (newValue > max) {
          newValue = input === self2.hourElement ? newValue - max - int(!self2.amPM) : min;
          if (isMinuteElem)
            incrementNumInput(void 0, 1, self2.hourElement);
        }
        if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
          self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
        }
        input.value = pad(newValue);
      }
    }
    init();
    return self2;
  }
  function _flatpickr(nodeList, config) {
    var nodes = Array.prototype.slice.call(nodeList).filter(function(x) {
      return x instanceof HTMLElement;
    });
    var instances = [];
    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      try {
        if (node.getAttribute("data-fp-omit") !== null)
          continue;
        if (node._flatpickr !== void 0) {
          node._flatpickr.destroy();
          node._flatpickr = void 0;
        }
        node._flatpickr = FlatpickrInstance(node, config || {});
        instances.push(node._flatpickr);
      } catch (e) {
        console.error(e);
      }
    }
    return instances.length === 1 ? instances[0] : instances;
  }
  if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
      return _flatpickr(this, config);
    };
    HTMLElement.prototype.flatpickr = function(config) {
      return _flatpickr([this], config);
    };
  }
  var flatpickr = function(selector, config) {
    if (typeof selector === "string") {
      return _flatpickr(window.document.querySelectorAll(selector), config);
    } else if (selector instanceof Node) {
      return _flatpickr([selector], config);
    } else {
      return _flatpickr(selector, config);
    }
  };
  flatpickr.defaultConfig = {};
  flatpickr.l10ns = {
    en: __assign({}, english),
    default: __assign({}, english)
  };
  flatpickr.localize = function(l10n) {
    flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
  };
  flatpickr.setDefaults = function(config) {
    flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config);
  };
  flatpickr.parseDate = createDateParser({});
  flatpickr.formatDate = createDateFormatter({});
  flatpickr.compareDates = compareDates;
  if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
    jQuery.fn.flatpickr = function(config) {
      return _flatpickr(this, config);
    };
  }
  Date.prototype.fp_incr = function(days) {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
  };
  if (typeof window !== "undefined") {
    window.flatpickr = flatpickr;
  }
  const Flatpickr_vue_vue_type_style_index_0_lang = "";
  const _sfc_main$4 = {
    props: {
      entry: {
        required: false
      },
      actions: {},
      resource: {
        required: true
      },
      meta: {
        required: true
      },
      form: {
        type: Object,
        required: true
      },
      loading: {
        type: Boolean,
        required: false
      }
    },
    data() {
      return {
        editSlug: false,
        slugValue: ""
      };
    },
    computed: {
      sections() {
        let body = _.filter(this.children, (field) => !field.section || field.section == "body");
        let sidebarRight = _.filter(this.children, (field) => field.section == "sidebar" || field.section == "sidebar-right");
        let sidebarLeft = _.filter(this.children, (field) => field.section == "sidebar-left");
        return { body, sidebarRight, sidebarLeft };
      },
      children() {
        return this.meta.children;
      },
      fields() {
        return this.meta.fields;
      }
    },
    methods: {}
  };
  function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_portal = require$$0$1.resolveComponent("portal");
    const _component_section_card = require$$0$1.resolveComponent("section-card");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      require$$0$1.createVNode(_component_portal, { to: "actions" }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createElementVNode("div", null, [
            (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($props.actions, (action, index) => {
              return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(action.component), require$$0$1.mergeProps(action, { parent: _ctx.$parent }, require$$0$1.toHandlers(action.events), { key: index }), {
                default: require$$0$1.withCtx(() => [
                  require$$0$1.createTextVNode(require$$0$1.toDisplayString(action.text), 1)
                ], void 0, true),
                _: 2
              }, 1040, ["parent"]);
            }), 128))
          ])
        ], void 0, true),
        _: 1
      }),
      require$$0$1.withDirectives(require$$0$1.createVNode(_component_section_card, { title: "Loading..." }, null, 512), [
        [require$$0$1.vShow, $props.loading]
      ]),
      require$$0$1.withDirectives(require$$0$1.createElementVNode("div", null, [
        require$$0$1.createVNode(_component_portal, { to: "sidebar-left" }, {
          default: require$$0$1.withCtx(() => [
            (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($options.sections.sidebarLeft, (field, index) => {
              return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", { key: index }, [
                field.is_panel ? (require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(field.component), require$$0$1.mergeProps({ key: 0 }, field, { form: $props.form }), {
                  default: require$$0$1.withCtx(() => [
                    require$$0$1.createTextVNode(require$$0$1.toDisplayString(field.text), 1)
                  ], void 0, true),
                  _: 2
                }, 1040, ["form"])) : (require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(field.component), require$$0$1.mergeProps({ key: 1 }, field, {
                  modelValue: $props.form[field.field.handle],
                  "onUpdate:modelValue": ($event) => $props.form[field.field.handle] = $event
                }, {
                  form: $props.form,
                  "has-error": $props.form.errors.has(field.field.handle),
                  "error-message": $props.form.errors.get(field.field.handle)
                }), {
                  default: require$$0$1.withCtx(() => [
                    require$$0$1.createTextVNode(require$$0$1.toDisplayString(field.text), 1)
                  ], void 0, true),
                  _: 2
                }, 1040, ["modelValue", "onUpdate:modelValue", "form", "has-error", "error-message"]))
              ]);
            }), 128))
          ], void 0, true),
          _: 1
        }),
        (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($options.sections.body, (field, index) => {
          return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", { key: index }, [
            field.is_panel ? (require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(field.component), require$$0$1.mergeProps({ key: 0 }, field, { form: $props.form }), {
              default: require$$0$1.withCtx(() => [
                require$$0$1.createTextVNode(require$$0$1.toDisplayString(field.text), 1)
              ], void 0, true),
              _: 2
            }, 1040, ["form"])) : (require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(field.component), require$$0$1.mergeProps({ key: 1 }, field, {
              modelValue: $props.form[field.field.handle],
              "onUpdate:modelValue": ($event) => $props.form[field.field.handle] = $event
            }, {
              form: $props.form,
              "has-error": $props.form.errors.has(field.field.handle),
              "error-message": $props.form.errors.get(field.field.handle)
            }), {
              default: require$$0$1.withCtx(() => [
                require$$0$1.createTextVNode(require$$0$1.toDisplayString(field.text), 1)
              ], void 0, true),
              _: 2
            }, 1040, ["modelValue", "onUpdate:modelValue", "form", "has-error", "error-message"]))
          ]);
        }), 128)),
        require$$0$1.createVNode(_component_portal, { to: "sidebar-right" }, {
          default: require$$0$1.withCtx(() => [
            (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($options.sections.sidebarRight, (field, index) => {
              return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", { key: index }, [
                field.is_panel ? (require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(field.component), require$$0$1.mergeProps({ key: 0 }, field, { form: $props.form }), {
                  default: require$$0$1.withCtx(() => [
                    require$$0$1.createTextVNode(require$$0$1.toDisplayString(field.text), 1)
                  ], void 0, true),
                  _: 2
                }, 1040, ["form"])) : (require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(field.component), require$$0$1.mergeProps({ key: 1 }, field, {
                  modelValue: $props.form[field.field.handle],
                  "onUpdate:modelValue": ($event) => $props.form[field.field.handle] = $event
                }, {
                  form: $props.form,
                  "has-error": $props.form.errors.has(field.field.handle),
                  "error-message": $props.form.errors.get(field.field.handle)
                }), {
                  default: require$$0$1.withCtx(() => [
                    require$$0$1.createTextVNode(require$$0$1.toDisplayString(field.text), 1)
                  ], void 0, true),
                  _: 2
                }, 1040, ["modelValue", "onUpdate:modelValue", "form", "has-error", "error-message"]))
              ]);
            }), 128))
          ], void 0, true),
          _: 1
        })
      ], 512), [
        [require$$0$1.vShow, !$props.loading]
      ])
    ]);
  }
  const SharedForm = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
  const _sfc_main$3 = {
    head: {
      title() {
        return {
          inner: this.resource.name || "Loading..."
        };
      }
    },
    data() {
      return {
        meta: null,
        resource: null,
        form: null,
        loading: false
      };
    },
    components: {
      "shared-form": SharedForm
    },
    methods: {
      submit() {
        this.loading = true;
        this.form.post(`/api/antfusion/resource/${this.resource.slug}`).then((response) => {
          toast("Entry saved successfully", "success");
          this.$router.push(`/resource/${this.resource.slug}`);
        }).catch((error) => {
          this.loading = false;
          if (error.errors) {
            this.errors = error.errors;
            var message = Object.keys(error.errors).map((key) => {
              return error.errors[key].join(" ");
            }).join(" ");
            toast(message, "failed");
          } else {
            toast(error.message, "failed");
          }
        });
      }
    },
    beforeRouteEnter(to, from, next) {
      axios.get(`/api/antfusion/resource/${to.params.resource}/create`).then((response) => {
        next((vm2) => {
          let meta = response.data;
          let resource = response.data.resource;
          let form2 = {
            name: "",
            slug: "",
            publish_at: null,
            expire_at: null,
            status: 1
          };
          _.each(meta.fields, (field) => {
            form2[field.field.handle] = field.field.default;
          });
          vm2.meta = meta;
          vm2.resource = resource;
          vm2.form = new Form(form2, true);
          vm2.$emit("updateHead");
        });
      }).catch(() => {
        vm.$router.push(`/resource/${vm.$router.currentRoute.params.resource}`);
        toast("Requested entry could not be found.", "danger");
      });
    }
  };
  const _hoisted_1$3 = { class: "resource-page" };
  function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_page_title = require$$0$1.resolveComponent("page-title");
    const _component_portal = require$$0$1.resolveComponent("portal");
    const _component_shared_form = require$$0$1.resolveComponent("shared-form");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_1$3, [
      require$$0$1.createVNode(_component_portal, { to: "title" }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createVNode(_component_page_title, {
            icon: $data.resource.icon || "pencil-alt",
            subtitle: $data.meta.subtitle
          }, {
            default: require$$0$1.withCtx(() => [
              require$$0$1.createTextVNode(require$$0$1.toDisplayString($data.meta.title), 1)
            ], void 0, true),
            _: 1
          }, 8, ["icon", "subtitle"])
        ], void 0, true),
        _: 1
      }),
      $data.form ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_shared_form, {
        key: 0,
        loading: $data.loading,
        form: $data.form,
        actions: $data.meta.actions,
        meta: $data.meta,
        resource: $data.resource
      }, null, 8, ["loading", "form", "actions", "meta", "resource"])) : require$$0$1.createCommentVNode("", true)
    ]);
  }
  const Create = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
  const Create$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Create
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$2 = {
    head: {
      title() {
        return {
          inner: this.resource.name || "Loading..."
        };
      }
    },
    data() {
      return {
        meta: null,
        resource: null,
        form: null,
        record: null,
        loading: false
      };
    },
    components: {
      "shared-form": SharedForm
    },
    methods: {
      submit() {
        this.loading = true;
        this.form.patch(`/api/antfusion/resource/${this.resource.slug}/${this.record.id}`).then((response) => {
          toast("Entry saved successfully", "success");
          this.$router.push(`/resource/${this.resource.slug}`);
        }).catch((error) => {
          this.loading = false;
          if (error.errors) {
            this.errors = error.errors;
            var message = Object.keys(error.errors).map((key) => {
              return error.errors[key].join(" ");
            }).join(" ");
            toast(message, "failed");
          } else {
            toast(error.message, "failed");
          }
        });
      }
    },
    beforeRouteEnter(to, from, next) {
      axios.get(`/api/antfusion/resource/${to.params.resource}/${to.params.id}/edit`).then((response) => {
        next((vm2) => {
          let meta = response.data;
          let resource = response.data.resource;
          let record = response.data.record;
          let form2 = {
            name: "",
            slug: "",
            publish_at: null,
            expire_at: null,
            status: 1
          };
          _.each(meta.fields, (field) => {
            form2[field.field.handle] = _.get(record, field.field.handle);
          });
          vm2.meta = meta;
          vm2.resource = resource;
          vm2.record = record;
          vm2.form = new Form(form2, true);
          vm2.$emit("updateHead");
        });
      }).catch(() => {
        vm.$router.push(`/resource/${vm.$router.currentRoute.params.resource}`);
        toast("Requested entry could not be found.", "danger");
      });
    }
  };
  const _hoisted_1$2 = { class: "resource-page" };
  function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_page_title = require$$0$1.resolveComponent("page-title");
    const _component_portal = require$$0$1.resolveComponent("portal");
    const _component_shared_form = require$$0$1.resolveComponent("shared-form");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_1$2, [
      require$$0$1.createVNode(_component_portal, { to: "title" }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createVNode(_component_page_title, {
            icon: $data.resource.icon || "pencil-alt",
            subtitle: $data.meta.subtitle
          }, {
            default: require$$0$1.withCtx(() => [
              require$$0$1.createTextVNode(require$$0$1.toDisplayString($data.meta.title), 1)
            ], void 0, true),
            _: 1
          }, 8, ["icon", "subtitle"])
        ], void 0, true),
        _: 1
      }),
      $data.form ? (require$$0$1.openBlock(), require$$0$1.createBlock(_component_shared_form, {
        key: 0,
        loading: $data.loading,
        form: $data.form,
        actions: $data.meta.actions,
        meta: $data.meta,
        resource: $data.resource
      }, null, 8, ["loading", "form", "actions", "meta", "resource"])) : require$$0$1.createCommentVNode("", true)
    ]);
  }
  const Edit = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
  const Edit$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Edit
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main$1 = {
    data() {
      return {
        meta: null,
        page: null,
        resource: null,
        actions: null
      };
    },
    beforeRouteUpdate(to, from, next) {
      axios.get("/api/antfusion/report/" + to.params.report).then((response) => {
        this.meta = response.data;
        this.page = response.data.page;
        this.actions = response.data.actions;
        console.log(response.data);
      }).catch((error) => {
        if (error.response.data.errors && error.response.data.errors["*"]) {
          let errors = error.response.data.errors["*"];
          toast(errors.join(" "), "error");
        } else {
          toast(error.response.data.message, "error");
        }
      });
    },
    beforeRouteEnter(to, from, next) {
      axios.get("/api/antfusion/report/" + to.params.report).then((response) => {
        next((vm2) => {
          vm2.meta = response.data;
          vm2.page = response.data.page;
          vm2.resource = response.data.resource;
          vm2.actions = response.data.actions;
          console.log(response.data);
        });
      }).catch((error) => {
        if (error.response.data.errors && error.response.data.errors["*"]) {
          let errors = error.response.data.errors["*"];
          toast(errors.join(" "), "error");
        } else {
          toast(error.response.data.message, "error");
        }
      });
    }
  };
  const _hoisted_1$1 = { key: 0 };
  function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_page_title = require$$0$1.resolveComponent("page-title");
    const _component_portal = require$$0$1.resolveComponent("portal");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      require$$0$1.createVNode(_component_portal, { to: "title" }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createVNode(_component_page_title, {
            icon: $data.page.icon
          }, {
            default: require$$0$1.withCtx(() => [
              require$$0$1.createTextVNode(require$$0$1.toDisplayString($data.page.title), 1)
            ], void 0, true),
            _: 1
          }, 8, ["icon"])
        ], void 0, true),
        _: 1
      }),
      require$$0$1.createVNode(_component_portal, { to: "actions" }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createElementVNode("div", null, [
            (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($data.actions, (action, index) => {
              return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(action.component), require$$0$1.mergeProps(action, {
                onSubmitted: _ctx.load,
                key: index
              }), {
                default: require$$0$1.withCtx(() => [
                  require$$0$1.createTextVNode(require$$0$1.toDisplayString(action.text), 1)
                ], void 0, true),
                _: 2
              }, 1040, ["onSubmitted"]);
            }), 128))
          ])
        ], void 0, true),
        _: 1
      }),
      $data.meta && $data.meta.components ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_1$1, [
        (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($data.meta.components, (component, index) => {
          return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(component.is), require$$0$1.mergeProps(component, {
            class: "form__group",
            key: index
          }), null, 16);
        }), 128))
      ])) : require$$0$1.createCommentVNode("", true)
    ]);
  }
  const Index$2 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
  const Index$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Index$2
  }, Symbol.toStringTag, { value: "Module" }));
  const _sfc_main = {
    data() {
      return {
        loadingCount: 0,
        meta: null,
        page: null,
        resource: null,
        actions: null
      };
    },
    methods: {
      onLoading() {
        this.loadingCount++;
      },
      onLoaded() {
        this.loadingCount--;
      }
    },
    computed: {
      loading() {
        return this.loadingCount > 0;
      }
    },
    beforeRouteUpdate(to, from, next) {
      axios.get("/api/antfusion/page/" + to.params.page).then((response) => {
        this.meta = response.data;
        this.page = response.data.page;
        this.actions = response.data.actions;
        console.log(response.data);
      }).catch((error) => {
        if (error.response.data.errors && error.response.data.errors["*"]) {
          let errors = error.response.data.errors["*"];
          toast(errors.join(" "), "error");
        } else {
          toast(error.response.data.message, "error");
        }
      });
    },
    beforeRouteEnter(to, from, next) {
      axios.get("/api/antfusion/page/" + to.params.page).then((response) => {
        next((vm2) => {
          vm2.meta = response.data;
          vm2.page = response.data.page;
          vm2.resource = response.data.resource;
          vm2.actions = response.data.actions;
          console.log(response.data);
        });
      }).catch((error) => {
        if (error.response.data.errors && error.response.data.errors["*"]) {
          let errors = error.response.data.errors["*"];
          toast(errors.join(" "), "error");
        } else {
          toast(error.response.data.message, "error");
        }
      });
    }
  };
  const _hoisted_1 = { class: "print:hidden" };
  const _hoisted_2 = { key: 0 };
  function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_page_title = require$$0$1.resolveComponent("page-title");
    const _component_portal = require$$0$1.resolveComponent("portal");
    return require$$0$1.openBlock(), require$$0$1.createElementBlock("div", null, [
      require$$0$1.createVNode(_component_portal, { to: "title" }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createVNode(_component_page_title, {
            icon: $data.page.icon || "layer-group"
          }, {
            default: require$$0$1.withCtx(() => [
              require$$0$1.createTextVNode(require$$0$1.toDisplayString($data.page.title), 1)
            ], void 0, true),
            _: 1
          }, 8, ["icon"])
        ], void 0, true),
        _: 1
      }),
      require$$0$1.createVNode(_component_portal, { to: "actions" }, {
        default: require$$0$1.withCtx(() => [
          require$$0$1.createElementVNode("span", _hoisted_1, [
            (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($data.actions, (action, index) => {
              return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(action.component), require$$0$1.mergeProps(action, {
                loading: $options.loading,
                onLoad: $options.onLoading,
                onLoaded: $options.onLoaded,
                onSubmitted: _ctx.load,
                key: index
              }), {
                default: require$$0$1.withCtx(() => [
                  require$$0$1.createTextVNode(require$$0$1.toDisplayString(action.text), 1)
                ], void 0, true),
                _: 2
              }, 1040, ["loading", "onLoad", "onLoaded", "onSubmitted"]);
            }), 128))
          ])
        ], void 0, true),
        _: 1
      }),
      $data.meta && $data.meta.components ? (require$$0$1.openBlock(), require$$0$1.createElementBlock("div", _hoisted_2, [
        (require$$0$1.openBlock(true), require$$0$1.createElementBlock(require$$0$1.Fragment, null, require$$0$1.renderList($data.meta.components, (component, index) => {
          return require$$0$1.openBlock(), require$$0$1.createBlock(require$$0$1.resolveDynamicComponent(component.component), require$$0$1.mergeProps(component, {
            loading: $options.loading,
            onLoad: $options.onLoading,
            onLoaded: $options.onLoaded,
            key: index
          }), null, 16, ["loading", "onLoad", "onLoaded"]);
        }), 128))
      ])) : require$$0$1.createCommentVNode("", true)
    ]);
  }
  const Index = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
  const Index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Index
  }, Symbol.toStringTag, { value: "Module" }));
});
